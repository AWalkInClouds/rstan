\documentclass[12pt]{article}
\usepackage{Sweave}
\usepackage{hyperref}
\usepackage{times}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{url}
\usepackage{booktabs} 
\usepackage{enumerate}
\usepackage{alltt}
\usepackage{multirow}
\usepackage{makeidx}
\usepackage{verbatimbox}


\DefineVerbatimEnvironment{Sinput}{Verbatim} {xleftmargin=2em,fontsize=\footnotesize} 
\DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=2em,fontsize=\footnotesize} 
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=2em,fontsize=\footnotesize}

\newcommand{\R}{R\xspace}
\newcommand{\Stan}{Stan\xspace}
\newcommand{\RStan}{RStan\xspace}
\newcommand{\stanc}{{\ttfamily stanc}\xspace}
\newcommand*{\Cpp}{C\raise.2ex\hbox{\footnotesize ++}\xspace} %\ensuremath{++}
\newcommand{\clang}{{\ttfamily clang\raise.2ex\hbox{\footnotesize ++}}\xspace} 
\newcommand{\gpp}{{\ttfamily g\raise.2ex\hbox{\footnotesize ++}}\xspace} 
\newcommand{\clangpp}{{\ttfamily clang\raise.2ex\hbox{\footnotesize ++}}\xspace} 

\providecommand{\T}{\rule{0pt}{2.6ex}}
\providecommand{\B}{\rule[-1.2ex]{0pt}{0pt}}

\providecommand{\rstanfunidx}[1]{\index{\pkg{rstan} functions!#1}}

\newcommand{\acronym}[1]{{\sc #1}\xspace}

\newcommand{\ASCII}{\acronym{ascii}}
\newcommand{\BNF}{\acronym{bnf}}
\newcommand{\MATLAB}{\acronym{matlab}}
\newcommand{\SPLUS}{\acronym{s}}
\newcommand{\BUGS}{\acronym{bugs}}
\newcommand{\JAGS}{\acronym{jags}}
\newcommand{\MCMC}{\acronym{mcmc}}
\newcommand{\HMC}{\acronym{hmc}}
\newcommand{\NUTS}{\acronym{nuts}}
\newcommand{\MSVC}{\acronym{msvc}}
\newcommand{\LKJ}{\acronym{lkj}}
\newcommand{\CPC}{\acronym{cpc}}

\newcommand{\code}[1]{{\tt #1}}

\newcommand{\strong}[1]{\texorpdfstring%
{{\normalfont\fontseries{b}\selectfont #1}}%
{#1}}
\let\pkg=\strong
\newcommand{\CRANpkg}[1]{\href{http://cran.r-project.org/package=#1}{\pkg{#1}}}%
\let\cpkg=\CRANpkg
\newcommand{\ctv}[1]{\href{http://CRAN.R-project.org/view=#1}{\emph{#1}}}
\newenvironment{example}{\begin{alltt}}{\end{alltt}}
\newenvironment{smallexample}{\begin{alltt}\small}{\end{alltt}}

\newcommand{\E}{\mathsf{E}}
\newcommand{\VAR}{\mathsf{VAR}}
\newcommand{\COV}{\mathsf{COV}}
\newcommand{\Prob}{\mathsf{P}}

\bibliographystyle{apalike}

%\VignetteIndexEntry{RStan} 

% The next line is needed for inverse search...
\SweaveOpts{concordance=TRUE, keep.source=TRUE, cache=TRUE}
<<echo=false>>=
options(width=60)
@

\title{\RStan: the \R interface to \Stan} 

\author{The Stan Development Team \\ stan@mc-stan.org}
\makeindex


\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

\Stan is a package for Bayesian sampling mainly using the No-U-Turn sampler (NUTS)
(\citealt{hoffman-gelman:2012}), providing a new and scalable tool for Bayesian 
model estimation. \RStan is a package\xspace\footnote{The name of 
this package is \pkg{rstan}, so we should use
\code{library(rstan)} to load it in \R.} % 
that allows to use \Stan conveniently in \R (\citealt{rprj}). In general, the website
for \Stan and \RStan, \url{http://mc-stan.org}, provides the
update-to-date information and how to get started with \Stan and \RStan. For
example, ``\RStan Getting Started`` (\citealt{rstangettingstarted2012})
provides information on how to install package \pkg{rstan} in \R and uses a couple 
of examples to demonstrate the basic usage. 
In this vignette, we give a complete introduction to 
the functionality of package \pkg{rstan}.  
As a complement to the documentation about functions and classes in package
\pkg{rstan}, this vignette try to provide pointers to many functions in package 
\pkg{rstan}. 
 

We start with the prerequisites for using package \pkg{rstan} 
(section \ref{subsec0pre}) and a typical workflow of using \Stan
and \RStan (section \ref{subsec0workflow}). 
In section \ref{sec0example} we use an example
to illustrate the process of using \pkg{rstan} to conduct Bayesian model
estimation. 
In section \ref{sec0examplesteps}, we fit the same example in multiple steps. 
Section \ref{sec0moredetails} presents more details about using \pkg{rstan}. 
Section \ref{sec0parallel} talks about how to run multiple chains in parallel. 
In section \ref{sec0workwstan}, we talk about some functions that \pkg{rstan}
provides to help use \Stan from the command line. 


\subsection{Prerequisites} 
\label{subsec0pre}

Undoubtedly, we assume that users have known Bayesian statistics. There
are many good textbooks on this subject, for example, 
\cite{GelmanCarlinSternRubin:2003}. Second, users need to know how to specify
a model using \Stan modeling language, the details for which can be 
found in the manual of \Stan (\citealt{StanManual:2013}).


To use \pkg{rstan}, we do not need to install \Stan.  Currently, \Stan runs
from the command line, which seems hard for some users. Package \pkg{rstan} makes it easier 
by including all the key parts of \Stan. So though we refer to \RStan as an \R
interface to \Stan, installing \Stan is not needed for using \pkg{rstan}. In addition,
\pkg{rstan} can help use \Stan from the command line. 

\RStan needs a \Cpp compiler to compile models the same as in \Stan. 
To install a \Cpp compiler and make sure that is accessible
in \R,  refer to ``\RStan Getting Started'' (\citealt{rstangettingstarted2012})
and the manual of \Stan. 

Package \pkg{rstan} depends on other two \R packages: \cpkg{Rcpp},
\cpkg{inline}.  As \Stan is written using \Cpp, \cpkg{Rcpp} makes it much 
easier for bridging the \R code and \Stan's \Cpp code. Package \cpkg{inline} facilitates
compiling the \Cpp code for \Stan model and making it possible to run the compiled model.
To minimize problems we might encounter, it might be better to install packages \cpkg{Rcpp}
and \cpkg{inline} before installing \pkg{rstan}. 

\subsection{Typical workflow of using \pkg{rstan}}
\label{subsec0workflow}

First, we review the typical workflow of using \Stan as it
is similar to using \pkg{rstan}. \Stan has a
modeling language, which is similar to BUGS (\citealt{WinBUGS}) but different
from many respects. In \Stan, we use \stanc\footnote{Using \Stan from the
command line, \code{stanc} is an executable program.} %
to translate a model expressed in \Stan modeling language to \Cpp code. The \Cpp code
is then compiled to an executable program by using a \Cpp compiler such as
\gpp\footnote{\url{http://gcc.gnu.org}} and \clangpp\footnote{\url{http://clang.llvm.org}}.
Then this program can be executed to draw samples given data and other input. 
In summary, the following are typical steps of using \Stan. 
\begin{enumerate}[a.]\addtolength{\itemsep}{-0.6\baselineskip}
\item Represent a statistical model in \Stan modeling language 
\item Translate model coded in \Stan modeling language to \Cpp code using \stanc 
\item Compile the \Cpp code for the model using a \Cpp compiler to
      create an executable program 
\item Prepare Data  
\item Run the executable to sample from posterior distribution
\item Diagnose convergence of MCMC chains 
\item Conduct model inference based on the samples 
\end{enumerate}

Knowing the above steps is helpful sometimes 
when, for example, we encounter a problem and want to identify the problematic step. 
In \pkg{rstan}, we have almost the same steps as above but packaged 
in different \R functions. 
However, there are some differences for \pkg{rstan} compared with \Stan in these
steps. First, to simplify the interface, function \code{stan}\rstanfunidx{stan} in
package \pkg{rstan} wraps some of the above steps.
Second, in \pkg{rstan}, we compile the \Cpp code generated for a model into a 
dynamic shared object (DSO) or called dynamic link library (DLL) to be loaded by \R
rather than an executable program.  We will give more details later.


\section{An example of using \pkg{rstan}}
\label{sec0example} 

In this section, we use an example to demonstrate using \pkg{rstan}.
In section 5.5 of \cite{GelmanCarlinSternRubin:2003}, a hierarchical model is used to model 
coaching effects from eight schools. For short, we call this example ``eight schools.'' 
For these eight schools, data are the estimated treatment effects and their standard errors, 
given in table \ref{tab08schoolsdata}.  The statistical model is specified as 
\begin{align}
y_j &\sim \text{normal}(\theta_j, \sigma_j), \quad j=1,\ldots,8, \label{eq08schoolmodeleq1} \\ 
\theta_1, \ldots, \theta_8 &\overset{IID}{\sim} \text{normal}(\mu, \tau^2), 
\end{align} 
where in \eqref{eq08schoolmodeleq1}, $\sigma_j$ is known. 
Further we have prior for $(\mu, \tau)$ as specified in \cite{GelmanCarlinSternRubin:2003}. 

\begin{table}[ht]
\centering 
\caption{Data of Eight schools example}
\label{tab08schoolsdata}
\begin{tabular}{ccc} 
\toprule 
School  & 
\begin{minipage}[t]{0.16\columnwidth}%
Estimated treatment effect, $y_j$ 
\end{minipage} &
\begin{minipage}[t]{0.16\columnwidth}%
s.e.\ of effect estimate, $\sigma_j$  
\end{minipage}  \\
\midrule
A     &  28   & 15  \\
B     &   8   & 10  \\
C     &  -3   & 16  \\
D     &   7   & 11  \\
E     &  -1   &  9  \\
F     &   1   & 11  \\
G     &  18   & 10  \\
H     &  12   & 18  \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Express the model in Stan}

In both \Stan and \RStan, we first need to express this model in 
\Stan modeling language. \pkg{rstan} allows the model to be coded 
in a text file (typically with suffix \code{.stan}) or a character string in \R. 
Here we use a character string. 
<<echo=TRUE>>=
library(rstan) 
schools_code0 <- '
  data {
    int<lower=0> J; // number of schools 
    real y[J];      // estimated treatment effects
    real<lower=0> sigma[J]; // s.e. of effect estimates 
  }
  parameters {
    real mu; 
    real<lower=0> tau;
    real theta[J];
  }
  model {
    theta ~ normal(mu, tau);
    y ~ normal(theta, sigma);
  }
'
@

For better performance of sampling, we would use the following
equivalent code for this model. See the manual of Stan for more
details. 

<<echo=TRUE>>=
library(rstan) 
schools_code <- '
  data {
    int<lower=0> J; // number of schools 
    real y[J];      // estimated treatment effects
    real<lower=0> sigma[J]; // s.e. of effect estimates 
  }
  parameters {
    real mu; 
    real<lower=0> tau;
    real eta[J];
  }
  transformed parameters {
    real theta[J];
    for (j in 1:J)
      theta[j] <- mu + tau * eta[j];
  }
  model {
    eta ~ normal(0, 1);
    y ~ normal(theta, sigma);
  }
'
@

\subsection{Prepare data}

\pkg{rstan} accepts data as a \code{list} or an \code{environment}. 
So to prepare the data in \R, we create a \code{list} as follows. 
<<echo=TRUE>>=
dat <- list(J = 8, 
            y = c(28,  8, -3,  7, -1,  1, 18, 12),
            sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
@

Often we would already have the elements of the data for a model
defined in our workspace. In \pkg{rstan}, a convenient way is to 
provide just the names instead of creating a new list. The following
\R code demonstrates this feature. 
<<echo=TRUE>>=
J <- 8
y <- c(28,  8, -3,  7, -1,  1, 18, 12)
sigma <- c(15, 10, 16, 11,  9, 11, 10, 18)
dat <- c("J", "y", "sigma") 
@

\subsection{Draw sample for the model} 
\label{subsec0stansampling}

Next, we can call function \code{stan} to sample for the model. 
<<callstan, echo=TRUE, results=hide, cache=TRUE>>=
fit <- stan(model_code = schools_code, data = dat, 
            iter = 100, chains = 4)
@

Function \code{stan} wraps the following three steps, which are similar to some
steps mentioned above for \Stan. But the deep integration of \Stan in \pkg{rstan} 
makes it much easier to start from a model and finish with samples drawn from the 
posterior distribution. In particular, the difficulty of compiling the \Cpp code
generated from a model is almost taken away from users. 
\begin{enumerate}[a.]\addtolength{\itemsep}{-0.6\baselineskip}
\item Translate a model in \Stan code to \Cpp code 
\item Compile the \Cpp code to dynamic shared object (DSO) and load the DSO
\item Sample given some user-specified data and other settings
\end{enumerate}

Function \code{stan} returns an object of S4\footnote{For those who are not familiar 
with the concept of class and S4 class in \R, refer to \cite{chambers2010software}. 
Simply speaking, a class consists of some attributes (data) to model an object and 
some methods to model the behavior of the object. From a user's perspective,  
once a \code{stanfit} object is created, we are mainly concerned about what methods 
are defined for class \code{stanfit}.} class \code{stanfit}.
If no error occurs, the returned \code{stanfit} 
object includes the samples drawn from the posterior distribution for the 
model parameters and other quantities defined in the model. 
If there is an error, \code{stan} will either quit, 
for example, when we have syntax error in our \Stan code,
or return a \code{stanfit} object that contains no sample but the DSO. 
Including the DSO as part of a \code{stanfit} object allows to save the 
time for compiling the model when we want to sample again for 
the same model with the same or different input of data and other settings.
Also if the error is due to wrong input such as data and inital values,
we can reuse the previous compiled model. 
For class \code{stanfit}, many methods such as \code{print} and \code{plot} 
are defined to work with the samples and model inference. For example, 
the following shows a summary of the parameters for the eight school
example using function \code{print}.
<<echo=TRUE>>=
print(fit, pars=c("theta", "mu", "tau", "lp__"), 
      probs=c(.1,.5,.9))
@

It is simple to just use function \code{stan} to execute all the above
steps. However, these steps are implemented in \pkg{rstan} separately. 
So in \pkg{rstan}, we can do the above steps one by one.  
This might serve us better sometimes (for
example, to debug our \Stan model code or \R code). 
In next section, we describe the steps that function \code{stan} consists of
and the corresponding functions in \pkg{rstan}. 

\section{Eight schools example step by step}
\label{sec0examplesteps} 

In the preceding section, we run the eight schools example in \pkg{rstan}
just using function \code{stan}. In fact, what \code{stan} does is just
wrapping a few functions that implement the series of steps.
So \pkg{rstan} also allow us to fit a model step by step as in \Stan. 

First, we can use \code{stanc}\rstanfunidx{stanc} function to translate the
model in \Stan modeling language to \Cpp code. When we have syntax errors in the 
model's \Stan code, the error information from \code{stanc} would 
be reported to help debug. A list is returned from \code{stanc} with one 
element being the generated \Cpp code for the model. For the eight schools
example, we use 
<<echo=TRUE, results=hide>>=
rt <- stanc(model_code = schools_code, 
            model_name = '8schools') 
@

Second, after translating a model from \Stan code to \Cpp code, we can
use function \code{stan\_model}\rstanfunidx{stan\_model} to compile the \Cpp
code to a DSO and load the DSO into \R. 
In this step (as in calling \code{stan}), the
\Cpp compiler might spew out a lot of intermediate message such as the \Cpp
code and warning message especially if \code{verbose=TRUE}.  In most cases,
these messages can be ignored unless there is an error. 
<<callstanmodel, echo=TRUE, results=hide, cache = TRUE>>=
sm <- stan_model(stanc_ret = rt, verbose = FALSE)
@

Also we can construct a model from the model's \Stan code
using function \code{stan\_model}. If the input 
for \code{stan\_model} is given by \code{file} or \code{model\_code}
that provides the \Stan code for a model, function \code{stanc} will
be called to translate the model from \Stan code to \Cpp code. 
<<callstanmodel2, echo=TRUE, results=hide, cache=TRUE>>=
sm <- stan_model(model_code = schools_code, 
                 model_name = '8schools', 
                 verbose = FALSE)
@

Function \code{stan\_model} returns an object of S4 class \code{stanmodel}
that comprises of mainly the DSO for the model. The most important 
method defined for S4 class \code{stanmodel} is \code{sampling}\rstanfunidx{sampling}, 
which calls \Stan's sampler to sample from the posterior distribution with
input of data, initial values, and other specification of sampling
parameters such as \code{chains} (number of chains) and \code{iter} (number of
iterations). 
<<callcampling, echo=TRUE, results=hide, cache=TRUE>>= 
fit <- sampling(sm, data = dat, chains = 4)
@

In fact, the final step in function \code{stan} is to call 
\code{sampling} for a \code{stanmodel} object created during the process.  
The object returned from the above function \code{sampling} is an object
of S4 class \code{stanfit} as discussed in section \ref{subsec0stansampling}. 
Also the arguments to control the sampling procedure
are the same as those for function \code{stan}. 

\section{More details and other functions of \pkg{rstan}}
\label{sec0moredetails}

In this section, we begin with talking about the arguments of function
\code{stan}.  Then we talk about data preprocessing for the data passed 
to \Stan.  Last, we talk about S4 class \code{stanfit} 
in more details, in particular other methods that can be used to diagnose 
the convergence of Markov chains, to extract samples, and to obtain 
information about the sampler.  

\subsection{Arguments of function \code{stan}} 

The arguments for sampling (in function \code{stan} and 
\code{sampling}) mainly include data, inital values, and the settings 
to control the sampler 
such as \code{chains}, \code{iter}, and \code{warmup}. 
In particular, \code{warmup} specifies the number of iterations 
that is used by NUTS sampler (or other samplers implemented in \Stan) in the
phase of adaptation (hence the sample should not be used for inference as it may not
theoretically guarantee the draws are from the object distribution). 
After the warmup period, the sampler turns off adaptation. 
So the summaries for the parameters printed out by function \code{print}
are calculated using the samples after warmup period. 

For function \code{stan}, argument \code{init} is used for specifying
the initial values.  There are several options for \code{init} and the 
details can be found in the documentation of \code{stan}. Here
we just point out that currently it does not allow partially specifying initial
values if \code{init} is given as an \R list or a function. 

In \Stan, we use a \code{seed} and \code{chain\_id} to initialized the
random number generator used by \Stan's sampler. So even we are sampling
multiple chains for calling function \code{stan}, we only need to specify one
seed, which is randomly generated in \R if not specified. 

Through changing some of augments for calling function \code{stan}, we
can use other samplers implemented by \Stan such as HMC. All the details
can be found in the help documentation of function \code{stan}. As \Stan
and \pkg{rstan} is being actively developed, other samplers might be 
added.  The help documentation in package \pkg{rstan} should always have the
up-to-date details.

The test gradient mode in \Stan can be used by setting argument 
\code{test\_gard} to \code{TRUE}. As in \Stan, the test gradient mode
will not do sampling, but only print out the gradients for the log probability 
density function at an initial value calculated by approaches of 
both the algorithmic differentiation (AD) in \Stan and finite difference.
The \code{stanfit} object returned from \code{stan} 
will be in test gradient mode and will not contain any sample.

\subsection{Data preprocessing and passing}

The data passed to \code{stan} will go through a preprocessing. 
The details of this preprocessing is documented in the help 
for function \code{stan}. Here we stress a few important steps.  
First in general, each element in the list should be numeric data
that matches the declaration in the model specification. So
\code{factor} type in \R is not supported as data element for \RStan.
\Stan modeling language differentiates integer and double input of data
and variables (type \code{int} and \code{real} in Stan modeling language,
respectively). But typically in \R, we are using type of \code{double}
most of the time since that is the default in \R. So an important data 
preprocessing step inside function \code{stan} is to convert some data to type
of \code{integer} if possible. 

In \Stan, we have scalars and others that are a set
of scalars (for example, vectors and matrices). 
But \R does not have scalars.  The behavior in \pkg{rstan} is to treat vector
length 1 to be a scalar. However, we might have a model with data block 
defined as in Figure~\ref{fig0datablock}, in which $N$ can be $1$ as a special case.
So if we know that $N$ is always larger than $1$, we can a vector of length $N$ in \R
as the data input for $y$. If we want to make our input of $y$ is still treated as 
an array when $N=1$,
we need to explicitly make it an array as the following \R code shows.


\begin{verbbox}

 data {                
   int<lower=0> N;      
   real y[N];
 } 

\end{verbbox} 

\begin{figure}[hb]
\centering
\frame{
\theverbbox
}
\caption{Data block of an example model in \Stan code}
\label{fig0datablock} 
\end{figure}

<<echo=TRUE>>=
y <- array(y, dim = length(y))
@

As Stan cannot handle missing values in data automatically, all elements of
data cannot contain \code{NA} in \R. An important step in \pkg{rstan}'s data
preprocessing is to check missing values and issue an error if any.


\subsection{Methods of class \code{stanfit}} 

For the fitted object, S4 class \code{stanfit}, we have defined methods such as
\code{print}, \code{summary}, \code{plot}, and \code{traceplot}.  Using these
functions, we first can assess the convergence of the Markov chains by looking
at the trace plots and calculating the split $\hat{R}$.\footnote{Split
$\hat{R}$ is a revised version of $\hat{R}$ statistic proposed in
\cite{GelmanRubin:1992}: the split $\hat{R}$ is based on splitting each chain
into two halves. See \Stan manual for more details.} %
The summaries including mean, standard deviation, quantiles of interest, split
$\hat{R}$, and effective sample sizes based on the samples after warmup phase
can be obtained by \code{summary}\rstanfunidx{summary} function.  Function
\code{print}\rstanfunidx{print} prints some of the summaries for all chains
combined (demonstrated in Section \ref{sec0example}) and
function \code{plot}\rstanfunidx{plot} provides an overview plot.

Function \code{plot} intends to give us an overview of the inference 
for all the parameters (if possible) in the model. 
Figure~\ref{fig0stanfitplot} presents the plot of the eight schools example. 
In this plot, credible intervals (by default 80\%) for all the parameters
as well as \code{lp\_\_} (the log of posterior density function up to an additive
constant), 
and the median of each chain are displayed. In addition, under the lines
representing intervals, a small colored area is used to indicate the 
value of split $\hat{R}$, in which the color indicates the value of split
$\hat{R}$.  Function \code{traceplot}\rstanfunidx{traceplot} plots the traces of
all chains for the parameters 
specified. If we include the warmup sample by setting \code{inc\_warmup=TRUE} (the 
default), the background color of the warmup area is different from after warmup.   
An example for parameter $\theta$ of the eight schools example is presented in
Figure~\ref{fig0stanfitplot}. 
\begin{figure}[ht]
\centering
<<echo=false, fig=TRUE, label=stanfit_plot>>=
plot(fit)
@
\caption{An overview plot for the inference of eight schools example} 
\label{fig0stanfitplot}
\end{figure}

\begin{figure}[ht]
\centering
<<echo=false, fig=TRUE, label=stanfit_tplot, height=4, width=6>>=
traceplot(fit, pars = "tau")
@
\caption{Trace plots of $\tau$ in the eight schools model} 
\label{fig0stanfittplot}
\end{figure}


Class \code{stanfit} defines a series of functions to work with the samples drawn 
from the posterior distribution. First, function \code{extract}\rstanfunidx{extract} provides 
different ways to access the samples. If argument \code{permuted} is \code{TRUE}
for calling \code{extract}, the sample after warmup period 
are returned in an permuted order as a list, each element of which is the 
sample for a parameter.  When \code{permuted=FALSE}, we could extract sample for 
parameters with or without warmup depending on argument \code{inc\_warmup}.
In this case, the returned object is an array with the first dimension indicating
iterations, the second indicating chains, and the third indicating parameters. 
<<echo=TRUE>>=
s <- extract(fit, pars = c("theta", "mu"), permuted = TRUE)
names(s)
dim(s$theta)
dim(s$mu)
s2 <- extract(fit, pars = "theta", permuted = FALSE)
dim(s2)
dimnames(s2)
@

In addition, methods \code{as.array}\rstanfunidx{as.array}, \code{as.matrix}\rstanfunidx{as.matrix}, and
\code{as.data.frame}\rstanfunidx{as.data.frame} are defined for \code{stanfit} object. These
function returns the draws of samples in forms of a 3-dimension array or a matrix.  The
three dimensions in order are iterations, chains, and parameters. 
In the form of a matrix or a data frame, multiple chains are merged. 
Additionally, function \code{pairs}\rstanfunidx{pairs}
creates a matrix of scatter plots of samples, which
can help diagnose convergence as well as providing a way to look
at the pairwise relationship between parameters. 


In the \code{stanfit} object, we keep all 
the information regarding the sampling procedure, for example, the model
in \Stan code, the initial
values for all parameters, the seed for random number generating,
and parameters (for example, the step size for NUTS) used for the sampler. 
The methods for obtaining this information are listed in table
\ref{tab0stanfitfuns} along with other methods defined for class
\code{stanfit}. 

Last, a common feature for some functions of class \code{stanfit} is that 
there is an argument of name \code{pars}.  This argument is used to 
to specify parameters of interest so that only part of 
the results for the fitted model are, for example, printed (plotted). This
feature is helpful when there are too many parameters in the model. For instance,
in the ``eight schools'' example, we have parameter $\theta$ defined as
``\code{real theta[J]}''. So we can specify
\code{pars="theta"} or \code{pars="theta[1]"}.
However, specifying part of $\theta$ (i.e., \code{pars="theta[1:2]"}) as in \R
is not allowed---a workaround for this is to specify \code{pars=c("theta[1]","theta[2]")}. 


\subsection{The log posterior function and its gradient} 

Essentially, we define the log of the probability
density of a posterior distribution up to additive constant (coded
as \code{lp\_\_}) in \Stan. 
Often \code{lp\_\_} becomes one quantity we are interested. 
In \pkg{rstan}, \code{lp\_\_} is treated as if it is a parameter 
in the summary and the calculation of split $\hat{R}$ and effective
sample size. 

A nice feature of \pkg{rstan} is that functions for calculating \code{lp\_\_}
and its gradients for a \code{stanfit} object are exposed. They are defined
on a \code{stanfit} object as we need data to create an instance of an 
abstract model. These two functions are \code{log\_prob}\rstanfunidx{log\_prob}
and \code{grad\_log\_prob}\rstanfunidx{grad\_log\_prob} respectively. Both functions take parameters
on the \textit{unconstrained} space, when the support of a parameter 
is not the whole real line. See \cite{StanManual:2013} for more details
about transformation. Also the number of unconstrained parameters 
might be less than the number of parameters. For example, when
a parameter is a simplex of length $K$, the number of unconstrained 
parameters are $K-1$. 
Function \code{get\_num\_upars}\rstanfunidx{get\_num\_upars} is provided 
to get the number of unconstrained parameters, 
To transform parameters between the constrained space and 
the unconstrained, we can use functions \code{unconstrained\_pars}\rstanfunidx{unconstrained\_pars} 
and \code{constrained\_pars}\rstanfunidx{constrained\_pars}. The former takes a list of parameters 
as input and transforms it to unconstrained space, and the latter 
does the inversion. Using these functions, we can implement other algorithms 
such as stochastic MAP estimation for Bayesian models using \pkg{rstan}.


\begin{table}
\caption{Methods of S4 class \code{stanfit}} 
\label{tab0stanfitfuns} 
\begin{tabular}{lp{0.6\linewidth}} 
\toprule 
Name  &    Function    \\ 
\midrule
\code{print}         & print the summary for parameters obtained using all chains  \\
\code{summary}       & summarize the sample from all chains and individual chains for parameters \\
\code{plot}          & plot the inferences (intervals and medians) for parameters \\
\code{traceplot}     & plot the traces of chains  \\
\code{extract}       & extract sample of parameters  \\
\code{get\_stancode}     & extract the \Stan modeling language code of the model  \\
\code{get\_stanmodel}     & extract the \code{stanmodel} object \\ 
\code{get\_seed}      & get the seed used for sampling  \\
\code{get\_inits}     & get the initial values used for sampling  \\
\code{get\_logposterior}     & get the log posterior  \\
\code{get\_sampler\_params}    & get parameters used by the sampler such as \code{treedepth} of NUTS  \\
\code{get\_adaptation\_info}    & get adaptation information, if any, of the sampler \\ 
\code{get\_num\_upars}    & get the number of parameters on unconstrained space \\ 
\code{unconstrain\_pars}    & transform parameter to unconstrained space \\ 
\code{constrain\_pars}    & transform parameter from unconstrained space to its defined space \\
\code{log\_prob}    & evaluate the log posterior for parameter on unconstrained space \\
\code{grad\_log\_prob}    & evaluate the gradient of the log posterior for parameter on unconstrained space \\
\code{as.array}        & \multirow{3}{\linewidth}{extract the samples excluding warmup to a three dimension array, matrix, data.frame}  \\
\code{as.matrix}       & \\
\code{as.data.frame}   & \\
\code{pairs} & make a matrix of scatter plots for the samples of parameters  \\
\bottomrule 
\end{tabular}
\end{table}


\subsection{Model compiling in \pkg{rstan}}

In \RStan, for every model, we use function \code{stanc} to translate the 
model from Stan modeling language code to \Cpp code 
and then compile the \Cpp code to dynamic shared object (DSO),
which is loaded into \R and executed to draw sample. 
The process of compiling \Cpp code to DSO, sometimes, takes a while. 
When the model is the same, we could reuse the DSO from previous run. 
In function \code{stan}, if parameter \code{fit} is specified
with a previous fitted object, the compiled model is reused. 
When reusing a previous fitted model, we can specify different 
data and other parameters for function \code{stan}. 

In addition, if fitted models (objects in our working space of \R)
are saved, for example, by \R function
\code{save} and \code{save.image}, \pkg{rstan} is able to save the 
DSO for models, so that they can be used across \R sessions. 
Saving the DSO is optional by specifying parameter \code{save\_dso}, which
is \code{TRUE} by default, for function \code{stan}. 

Last, there are some options that configures compiling the \Cpp code
by a compiler such as \gpp. In particular, we can specify the optimization level
that is used for a \Cpp compiler. \pkg{rstan} provides function 
\code{set\_cppo} to configure some of the flags, details of which
can be found in the online document. We strongly suggest using \code{set\_cppo('fast')} 
for better speed of sampling.


\section{Run multiple chains in parallel}
\label{sec0parallel}

For function \code{stan}, we can specify the number of chains using argument
\code{chains}. \pkg{rstan} runs chains serially using one 
\R process, which means that \pkg{rstan} does not support sampling in parallel
directly. But \pkg{rstan} provides a function named \code{sflist2stanfit} to
merge multiple \code{stanfit} object into one \code{stanfit} object. As a 
result, if we can run multiple chains in parallel using any approach provided by 
other packages on one computer (or a cluster), then we can essentially 
run multiple chains in parallel. For example, we can easily achieve this goal
on one computer using function \code{mclapply} in package
\pkg{parallel}\footnote{\pkg{parallel} works only for non-Windows, so we set
\code{mc.cores} to $1$ for Windows.}%
as follows.  
<<parallel, echo=TRUE, results=hide, cache=TRUE>>=
library(rstan)
library(parallel)
f1 <- stan(model_code = schools_code, data = dat, 
           chains = 1, iter = 1)
WINDOWS <- .Platform$OS.type == "windows"
seed <- 12345 
sflist1 <-
  mclapply(1:4, mc.cores = ifelse(WINDOWS, 1, 4),
           function(i) stan(fit = f1, seed = seed, 
                            data = dat, 
                            chains = 1, chain_id = i, 
                            refresh = -1))
fit <- sflist2stanfit(sflist1)
@

Note in the above code, we specify the same seed for all the chains but use
different chain ID (argument \code{chain\_id}). This is to make sure 
that the random numbers generated in \Stan for all chains are independent. 

\section{Work with \Stan} 
\label{sec0workwstan}

\pkg{rstan} provides some function to make it more convenient 
to work with \Stan from the command line. First, when \Stan reads data or initial
values, it supports a subset of the syntax of \R dump data formats.  
Function \code{stan\_rdump} in \pkg{rstan} dumps the data in \R to the format that is 
supported by \Stan. The usage of this function is very similar to
the \code{dump} function in \R. 


Second, function \code{read\_stan\_csv}\rstanfunidx{read\_stan\_csv}
in \pkg{rstan} creates a \code{stanfit} object from reading the comma separated
files (CSV) generated from using \Stan. As a result, we can use many methods
defined for \code{stanfit} class to work with the samples. In other words, 
we can easily use \R to analyze the samples generated by using \Stan from
the command line.


\section{Summary} 
\label{sec0summary}

In this vignetter, we talks about the main functionality of \pkg{rstan} 
from a user perspective. The online document shoud provide more details
for all the \pkg{rstan} functions. When it comes to \Stan, refer 
to its manual (\citealt{StanManual:2013}), which provides a lot of 
details and includes a variety of model examples. \pkg{rstan} provides
function \code{stan\_demo}\rstanfunidx{stan\_demo} to choose and then run an
example included in \Stan.  Some of these examples are detailed in \Stan's
manual and some of the models originated from the examples of BUGS
(\citealt{WinBUGS}). 


As \Stan is still being developed, there would be more features of \Stan. 
In general, \pkg{rstan} would always implement the interfaces for all the 
functionality of \Stan and its document would provide all the details. 
For more help, check out the information at Stan's website (http://mc-stan.org). 

\nocite{*} 
\bibliography{rstan} 

\printindex

\end{document} 

