
R Under development (unstable) (2019-04-20 r76407) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bayesplot"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bayesplot')
This is bayesplot version 1.6.0
- Online documentation and vignettes at mc-stan.org/bayesplot
- bayesplot theme set to bayesplot::theme_default()
   * Does _not_ affect other ggplot2 plots
   * See ?bayesplot_theme_set for details on theme setting
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("MCMC-combos")
> ### * MCMC-combos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-combos
> ### Title: Combination plots
> ### Aliases: MCMC-combos mcmc_combo
> 
> ### ** Examples
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> mcmc_combo(x, pars = c("alpha", "sigma"))
> mcmc_combo(x, pars = c("alpha", "sigma"), widths = c(1, 2))
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-diagnostics")
> ### * MCMC-diagnostics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-diagnostics
> ### Title: General MCMC diagnostics
> ### Aliases: MCMC-diagnostics mcmc_rhat mcmc_rhat_hist mcmc_rhat_data
> ###   mcmc_neff mcmc_neff_hist mcmc_neff_data mcmc_acf mcmc_acf_bar
> 
> ### ** Examples
> 
> # autocorrelation
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> color_scheme_set("green")
> mcmc_acf(x, pars = c("alpha", "beta[1]"))
> 
> # fake rhat values to use for demonstration
> rhat <- c(runif(100, 1, 1.15))
> mcmc_rhat_hist(rhat)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_rhat(rhat)
> 
> # lollipops
> color_scheme_set("purple")
> mcmc_rhat(rhat[1:10], size = 5)
> 
> color_scheme_set("blue")
> mcmc_rhat(runif(1000, 1, 1.07))
> mcmc_rhat(runif(1000, 1, 1.3)) + legend_move("top") # add legend above plot
> 
> # fake neff ratio values to use for demonstration
> ratio <- c(runif(100, 0, 1))
> mcmc_neff_hist(ratio)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_neff(ratio)
> 
> ## Not run: 
> ##D # Example using rstanarm model (requires rstanarm package)
> ##D library(rstanarm)
> ##D 
> ##D # intentionally use small 'iter' so there are some
> ##D # problems with rhat and neff for demonstration
> ##D fit <- stan_glm(mpg ~ ., data = mtcars, iter = 50)
> ##D rhats <- rhat(fit)
> ##D ratios <- neff_ratio(fit)
> ##D mcmc_rhat(rhats)
> ##D mcmc_neff(ratios, size = 3)
> ##D 
> ##D # there's a small enough number of parameters in the
> ##D # model that we can display their names on the y-axis
> ##D mcmc_neff(ratios) + yaxis_text(hjust = 1)
> ##D 
> ##D # can also look at autocorrelation
> ##D draws <- as.array(fit)
> ##D mcmc_acf(draws, pars = c("wt", "cyl"), lags = 10)
> ##D 
> ##D # increase number of iterations and plots look much better
> ##D fit2 <- update(fit, iter = 500)
> ##D mcmc_rhat(rhat(fit2))
> ##D mcmc_neff(neff_ratio(fit2))
> ##D mcmc_acf(as.array(fit2), pars = c("wt", "cyl"), lags = 10)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-distributions")
> ### * MCMC-distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-distributions
> ### Title: Histograms and kernel density plots of MCMC draws
> ### Aliases: MCMC-distributions mcmc_hist mcmc_dens mcmc_hist_by_chain
> ###   mcmc_dens_overlay mcmc_dens_chains mcmc_dens_chains_data mcmc_violin
> 
> ### ** Examples
> 
> set.seed(9262017)
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws()
> dim(x)
[1] 250   4   4
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> ##################
> ### Histograms ###
> ##################
> 
> # histograms of all parameters
> color_scheme_set("brightblue")
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # histograms of some parameters
> color_scheme_set("pink")
> mcmc_hist(x, pars = c("alpha", "beta[2]"))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> # example of using 'transformations' argument to plot log(sigma),
> # and parsing facet labels (e.g. to get greek letters for parameters)
> mcmc_hist(x, transformations = list(sigma = "log"),
+           facet_args = list(labeller = ggplot2::label_parsed)) +
+           facet_text(size = 15)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> #################
> ### Densities ###
> #################
> 
> mcmc_dens(x, pars = c("sigma", "beta[2]"),
+           facet_args = list(nrow = 2))
> # separate chains as violin plots
> color_scheme_set("green")
> mcmc_violin(x) + panel_bg(color = "gray20", size = 2, fill = "gray30")
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-intervals")
> ### * MCMC-intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-intervals
> ### Title: Plot interval estimates from MCMC draws
> ### Aliases: MCMC-intervals mcmc_intervals mcmc_areas mcmc_areas_ridges
> ###   mcmc_intervals_data mcmc_areas_data mcmc_areas_ridges_data
> 
> ### ** Examples
> 
> set.seed(9262017)
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(params = 6)
> dim(x)
[1] 250   4   6
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> color_scheme_set("brightblue")
> mcmc_intervals(x)
> mcmc_intervals(x, pars = c("beta[1]", "beta[2]"))
> mcmc_areas(x, regex_pars = "beta\\[[1-3]", prob = 0.8) +
+  ggplot2::labs(
+    title = "Posterior distributions",
+    subtitle = "with medians and 80% intervals"
+  )
> 
> color_scheme_set("red")
> mcmc_areas(
+    x,
+    pars = c("alpha", "beta[4]"),
+    prob = 2/3,
+    prob_outer = 0.9,
+    point_est = "mean"
+ )
> 
> # color by rhat value
> color_scheme_set("blue")
> fake_rhat_values <- c(1, 1.07, 1.3, 1.01, 1.15, 1.005)
> mcmc_intervals(x, rhat = fake_rhat_values)
> 
> mcmc_intervals_data(x)
# A tibble: 6 x 9
  parameter outer_width inner_width point_est      ll       l       m       h
  <fct>           <dbl>       <dbl> <chr>       <dbl>   <dbl>   <dbl>   <dbl>
1 alpha             0.9         0.5 median    -42.7   -28.7   -18.5    -7.46 
2 sigma             0.9         0.5 median     17.1    17.6    18.0    18.4  
3 beta[1]           0.9         0.5 median     -0.165   0.136   0.358   0.601
4 beta[2]           0.9         0.5 median     -0.722  -0.578  -0.469  -0.362
5 beta[3]           0.9         0.5 median      0.718   0.858   0.950   1.05 
6 beta[4]           0.9         0.5 median     24.9    39.1    49.2    59.4  
# … with 1 more variable: hh <dbl>
> mcmc_intervals_data(x, rhat = fake_rhat_values)
# A tibble: 6 x 12
  parameter outer_width inner_width point_est      ll       l       m       h
  <fct>           <dbl>       <dbl> <chr>       <dbl>   <dbl>   <dbl>   <dbl>
1 alpha             0.9         0.5 median    -42.7   -28.7   -18.5    -7.46 
2 sigma             0.9         0.5 median     17.1    17.6    18.0    18.4  
3 beta[1]           0.9         0.5 median     -0.165   0.136   0.358   0.601
4 beta[2]           0.9         0.5 median     -0.722  -0.578  -0.469  -0.362
5 beta[3]           0.9         0.5 median      0.718   0.858   0.950   1.05 
6 beta[4]           0.9         0.5 median     24.9    39.1    49.2    59.4  
# … with 4 more variables: hh <dbl>, rhat_value <dbl>, rhat_rating <fct>,
#   rhat_description <chr>
> mcmc_areas_data(x, pars = "alpha")
# A tibble: 2,091 x 5
   parameter interval interval_width     x density
   <fct>     <chr>             <dbl> <dbl>   <dbl>
 1 alpha     inner               0.5 -28.7  0.0221
 2 alpha     inner               0.5 -28.7  0.0221
 3 alpha     inner               0.5 -28.7  0.0221
 4 alpha     inner               0.5 -28.7  0.0221
 5 alpha     inner               0.5 -28.6  0.0221
 6 alpha     inner               0.5 -28.6  0.0221
 7 alpha     inner               0.5 -28.6  0.0221
 8 alpha     inner               0.5 -28.6  0.0222
 9 alpha     inner               0.5 -28.5  0.0222
10 alpha     inner               0.5 -28.5  0.0222
# … with 2,081 more rows
> 
> color_scheme_set("gray")
> p <- mcmc_areas(x, pars = c("alpha", "beta[4]"), rhat = c(1, 1.1))
> p + legend_move("bottom")
> p + legend_move("none") # or p + legend_none()
> 
> 
> ## Not run: 
> ##D # example using fitted model from rstanarm package
> ##D library(rstanarm)
> ##D fit <- stan_glm(
> ##D  mpg ~ 0 + wt + factor(cyl),
> ##D  data = mtcars,
> ##D  iter = 500
> ##D )
> ##D x <- as.matrix(fit)
> ##D 
> ##D color_scheme_set("teal")
> ##D mcmc_intervals(x, point_est = "mean", prob = 0.8, prob_outer = 0.95)
> ##D mcmc_areas(x, regex_pars = "cyl", bw = "SJ",
> ##D            rhat = rhat(fit, regex_pars = "cyl"))
> ## End(Not run)
> 
> ## Not run: 
> ##D # Example of hierarchically related parameters
> ##D # plotted with ridgelines
> ##D m <- shinystan::eight_schools@posterior_sample
> ##D mcmc_areas_ridges(m, pars = "mu", regex_pars = "theta") +
> ##D  ggplot2::ggtitle("Treatment effect on eight schools (Rubin, 1981)")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-nuts")
> ### * MCMC-nuts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-nuts
> ### Title: Diagnostic plots for the No-U-Turn-Sampler (NUTS)
> ### Aliases: MCMC-nuts NUTS mcmc_nuts_acceptance mcmc_nuts_divergence
> ###   mcmc_nuts_stepsize mcmc_nuts_treedepth mcmc_nuts_energy
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(ggplot2)
> ##D library(rstanarm)
> ##D fit <- stan_glm(mpg ~ wt + am, data = mtcars, iter = 1000)
> ##D np <- nuts_params(fit)
> ##D lp <- log_posterior(fit)
> ##D 
> ##D color_scheme_set("brightblue")
> ##D mcmc_nuts_acceptance(np, lp)
> ##D mcmc_nuts_acceptance(np, lp, chain = 2)
> ##D 
> ##D mcmc_nuts_divergence(np, lp)
> ##D mcmc_nuts_stepsize(np, lp)
> ##D mcmc_nuts_treedepth(np, lp)
> ##D 
> ##D color_scheme_set("red")
> ##D mcmc_nuts_energy(np)
> ##D mcmc_nuts_energy(np, merge_chains = TRUE, binwidth = .15)
> ##D mcmc_nuts_energy(np) +
> ##D  facet_wrap(~ Chain, nrow = 1) +
> ##D  coord_fixed(ratio = 150) +
> ##D  ggtitle("NUTS Energy Diagnostic")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-parcoord")
> ### * MCMC-parcoord
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-parcoord
> ### Title: Parallel coordinates plot of MCMC draws
> ### Aliases: MCMC-parcoord mcmc_parcoord mcmc_parcoord_data
> ###   parcoord_style_np
> 
> ### ** Examples
> 
> color_scheme_set("pink")
> x <- example_mcmc_draws(params = 5)
> mcmc_parcoord(x)
> mcmc_parcoord(x, regex_pars = "beta")
> 
> ## Not run: 
> ##D # Example using a Stan demo model
> ##D library(rstan)
> ##D fit <- stan_demo("eight_schools")
> ##D draws <- as.array(fit, pars = c("mu", "tau", "theta", "lp__"))
> ##D np <- nuts_params(fit)
> ##D str(np)
> ##D levels(np$Parameter)
> ##D 
> ##D color_scheme_set("brightblue")
> ##D mcmc_parcoord(draws, alpha = 0.05)
> ##D mcmc_parcoord(draws, np = np)
> ##D 
> ##D # customize appearance of divergences
> ##D color_scheme_set("darkgray")
> ##D div_style <- parcoord_style_np(div_color = "green", div_size = 0.05, div_alpha = 0.4)
> ##D mcmc_parcoord(draws, size = 0.25, alpha = 0.1,
> ##D               np = np, np_style = div_style)
> ##D 
> ##D # to use a transformation (e.g., to standarde all the variables)
> ##D # specify the 'transformations' argument (though partial argument name
> ##D # matching means we can just use 'trans' or 'transform')
> ##D mcmc_parcoord(
> ##D   draws,
> ##D   transform = function(x) {(x - mean(x)) / sd(x)},
> ##D   size = 0.25,
> ##D   alpha = 0.1,
> ##D   np = np,
> ##D   np_style = div_style
> ##D  )
> ##D 
> ##D # mcmc_parcoord_data returns just the data in a conventient form for plotting
> ##D d <- mcmc_parcoord_data(x, np = np)
> ##D head(d)
> ##D tail(d)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-recover")
> ### * MCMC-recover
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-recover
> ### Title: Compare MCMC estimates to "true" parameter values
> ### Aliases: MCMC-recover mcmc_recover_intervals mcmc_recover_scatter
> ###   mcmc_recover_hist
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D alpha <- 1; beta <- rnorm(10, 0, 3); sigma <- 2
> ##D X <- matrix(rnorm(1000), 100, 10)
> ##D y <- rnorm(100, mean = c(alpha + X %*% beta), sd = sigma)
> ##D fit <- stan_glm(y ~ ., data = data.frame(y, X))
> ##D draws <- as.matrix(fit)
> ##D print(colnames(draws))
> ##D true <- c(alpha, beta, sigma)
> ##D 
> ##D mcmc_recover_intervals(draws, true)
> ##D 
> ##D # put the coefficients on X into the same batch
> ##D mcmc_recover_intervals(draws, true, batch = c(1, rep(2, 10), 1))
> ##D # equivalent
> ##D mcmc_recover_intervals(draws, true, batch = grepl("X", colnames(draws)))
> ##D # same but facets stacked vertically
> ##D mcmc_recover_intervals(draws, true,
> ##D                        batch = grepl("X", colnames(draws)),
> ##D                        facet_args = list(ncol = 1),
> ##D                        size = 3)
> ##D 
> ##D # each parameter in its own facet
> ##D mcmc_recover_intervals(draws, true, batch = 1:ncol(draws))
> ##D # same but in a different order
> ##D mcmc_recover_intervals(draws, true, batch = c(1, 3, 4, 2, 5:12))
> ##D # present as bias by centering with true values
> ##D mcmc_recover_intervals(sweep(draws, 2, true), rep(0, ncol(draws))) + hline_0()
> ##D 
> ##D 
> ##D # scatterplot of posterior means vs true values
> ##D mcmc_recover_scatter(draws, true, point_est = "mean")
> ##D 
> ##D 
> ##D # histograms of parameter draws with true value added as vertical line
> ##D color_scheme_set("brightblue")
> ##D mcmc_recover_hist(draws[, 1:4], true[1:4])
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("MCMC-scatterplots")
> ### * MCMC-scatterplots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-scatterplots
> ### Title: Scatterplots of MCMC draws
> ### Aliases: MCMC-scatterplots mcmc_scatter mcmc_hex mcmc_pairs
> ###   scatter_style_np pairs_style_np pairs_condition
> 
> ### ** Examples
> 
> library("ggplot2")
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(params = 6)
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> # scatterplot of alpha vs log(sigma)
> color_scheme_set("teal")
> (p <- mcmc_scatter(x, pars = c("alpha", "sigma"),
+                   transform = list(sigma = "log")))
> p +
+   labs(
+     title = "Insert your own headline-grabbing title",
+     subtitle = "with a provocative subtitle",
+     caption = "and a controversial caption",
+     x = expression(alpha),
+     y = expression(log(sigma))
+    )
> 
> # add ellipse
> p + stat_ellipse(level = 0.9, color = "gray20", size = 1)
> 
> # add contour
> color_scheme_set("red")
> p2 <- mcmc_scatter(x, pars = c("alpha", "sigma"), size = 3.5, alpha = 0.25)
> p2 + stat_density_2d(color = "black", size = .5)
> 
> # can also add lines/smooths
> color_scheme_set("pink")
> (p3 <- mcmc_scatter(x, pars = c("alpha", "beta[3]"), alpha = 0.25, size = 3))
> p3 + geom_smooth(method = "lm", se = FALSE, color = "gray20",
+                  size = .75, linetype = 2)
> 
> 
> ## Not run: 
> ##D ### Adding NUTS diagnostics to scatterplots and pairs plots
> ##D 
> ##D # examples using rstanarm package
> ##D library(rstanarm)
> ##D 
> ##D # for demonstration purposes, intentionally fit a model that
> ##D # will (almost certainly) have some divergences
> ##D fit <- stan_glm(
> ##D   mpg ~ ., data = mtcars,
> ##D   iter = 1000,
> ##D   # this combo of prior and adapt_delta should lead to some divergences
> ##D   prior = hs(),
> ##D   adapt_delta = 0.9
> ##D )
> ##D posterior <- as.array(fit)
> ##D np <- nuts_params(fit)
> ##D 
> ##D # mcmc_scatter with divergences highlighted
> ##D color_scheme_set("brightblue")
> ##D mcmc_scatter(posterior, pars = c("wt", "sigma"), np = np)
> ##D 
> ##D color_scheme_set("darkgray")
> ##D div_style <- scatter_style_np(div_color = "green", div_shape = 4, div_size = 4)
> ##D mcmc_scatter(posterior, pars = c("sigma", "(Intercept)"),
> ##D              np = np, np_style = div_style)
> ##D 
> ##D # split the draws according to above/below median accept_stat__
> ##D # and show approximate location of divergences (red points)
> ##D color_scheme_set("brightblue")
> ##D mcmc_pairs(
> ##D   posterior,
> ##D   pars = c("wt", "cyl", "sigma"),
> ##D   off_diag_args = list(size = 1, alpha = 1/3),
> ##D   condition = pairs_condition(nuts = "accept_stat__"),
> ##D   np = np
> ##D )
> ##D 
> ##D # more customizations:
> ##D # - transform sigma to log(sigma)
> ##D # - median log-posterior as 'condition'
> ##D # - hex instead of scatter for off-diagonal plots
> ##D # - show points where max treedepth hit in blue
> ##D color_scheme_set("darkgray")
> ##D mcmc_pairs(
> ##D   posterior,
> ##D   pars = c("wt", "cyl", "sigma"),
> ##D   transform = list(sigma = "log"),
> ##D   off_diag_fun = "hex",
> ##D   condition = pairs_condition(nuts = "lp__"),
> ##D   lp = log_posterior(fit),
> ##D   np = np,
> ##D   np_style = pairs_style_np(div_color = "firebrick",
> ##D                             td_color = "blue",
> ##D                             td_size = 2),
> ##D   # for demonstration purposes, set max_treedepth to a value that will
> ##D   # result in at least a few max treedepth warnings
> ##D   max_treedepth = with(np, -1 + max(Value[Parameter == "treedepth__"]))
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("MCMC-traces")
> ### * MCMC-traces
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: MCMC-traces
> ### Title: Trace plot (time series plot) of MCMC draws
> ### Aliases: MCMC-traces mcmc_trace mcmc_trace_highlight trace_style_np
> 
> ### ** Examples
> 
> # some parameter draws to use for demonstration
> x <- example_mcmc_draws(chains = 4, params = 6)
> dim(x)
[1] 250   4   6
> dimnames(x)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"

> 
> # trace plots of the betas
> color_scheme_set("viridis")
> mcmc_trace(x, regex_pars = "beta")
> 
> # mix color schemes
> color_scheme_set("mix-blue-red")
> mcmc_trace(x, regex_pars = "beta")
> 
> # use traditional ggplot discrete color scale
> mcmc_trace(x, pars = c("alpha", "sigma")) +
+  ggplot2::scale_color_discrete()
Scale for 'colour' is already present. Adding another scale for 'colour',
which will replace the existing scale.
> 
> # zoom in on a window of iterations, increase line size,
> # add tick marks, move legend to the top, add gray background
> color_scheme_set("viridisA")
> mcmc_trace(x[,, 1:4], window = c(100, 130), size = 1) +
+   panel_bg(fill = "gray90", color = NA) +
+   legend_move("top")
> 
> ## Not run: 
> ##D # parse facet label text
> ##D color_scheme_set("purple")
> ##D p <- mcmc_trace(
> ##D   x,
> ##D   regex_pars = "beta\\[[1,3]\\]",
> ##D   facet_args = list(labeller = ggplot2::label_parsed)
> ##D )
> ##D p + facet_text(size = 15)
> ##D 
> ##D # mark first 100 draws as warmup
> ##D mcmc_trace(x, n_warmup = 100)
> ##D 
> ##D # plot as points, highlighting chain 2
> ##D color_scheme_set("brightblue")
> ##D mcmc_trace_highlight(x, pars = "sigma", highlight = 2, size = 2)
> ##D 
> ##D # for models fit using HMC/NUTS divergences can be displayed in the trace plot
> ##D library("rstanarm")
> ##D fit <- stan_glm(mpg ~ ., data = mtcars,
> ##D   # next line to keep example fast and also ensure we get some divergences
> ##D                 prior = hs(), iter = 400, adapt_delta = 0.8)
> ##D 
> ##D # extract draws using as.array (instead of as.matrix) to keep
> ##D # chains separate for trace plot
> ##D posterior <- as.array(fit)
> ##D 
> ##D # for stanfit and stanreg objects use nuts_params() to get the divergences
> ##D mcmc_trace(posterior, pars = "sigma", np = nuts_params(fit))
> ##D 
> ##D color_scheme_set("viridis")
> ##D mcmc_trace(
> ##D   posterior,
> ##D   pars = c("wt", "sigma"),
> ##D   size = 0.5,
> ##D   facet_args = list(nrow = 2),
> ##D   np = nuts_params(fit),
> ##D   np_style = trace_style_np(div_color = "black", div_size = 0.5)
> ##D )
> ##D 
> ##D color_scheme_set("viridis")
> ##D mcmc_trace(
> ##D   posterior,
> ##D   pars = c("wt", "sigma"),
> ##D   size = 0.8,
> ##D   facet_args = list(nrow = 2),
> ##D   divergences = nuts_params(fit),
> ##D   div_color = "black"
> ##D )
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-discrete")
> ### * PPC-discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-discrete
> ### Title: PPCs for discrete outcomes
> ### Aliases: PPC-discrete ppc_bars ppc_bars_grouped ppc_rootogram
> 
> ### ** Examples
> 
> set.seed(9222017)
> 
> # bar plots
> f <- function(N) {
+   sample(1:4, size = N, replace = TRUE, prob = c(0.25, 0.4, 0.1, 0.25))
+ }
> y <- f(100)
> yrep <- t(replicate(500, f(100)))
> dim(yrep)
[1] 500 100
> group <- gl(2, 50, length = 100, labels = c("GroupA", "GroupB"))
> 
> color_scheme_set("mix-pink-blue")
> ppc_bars(y, yrep)
> 
> # split by group, change interval width, and display proportion
> # instead of count on y-axis
> color_scheme_set("mix-blue-pink")
> ppc_bars_grouped(y, yrep, group, prob = 0.5, freq = FALSE)
> 
> # rootograms for counts
> y <- rpois(100, 20)
> yrep <- matrix(rpois(10000, 20), ncol = 100)
> 
> color_scheme_set("brightblue")
> ppc_rootogram(y, yrep)
> ppc_rootogram(y, yrep, prob = 0)
> 
> ppc_rootogram(y, yrep, style = "hanging", prob = 0.8)
> ppc_rootogram(y, yrep, style = "suspended")
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-distributions")
> ### * PPC-distributions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-distributions
> ### Title: PPC distributions
> ### Aliases: PPC-distributions ppc_data ppc_hist ppc_boxplot ppc_freqpoly
> ###   ppc_freqpoly_grouped ppc_dens ppc_dens_overlay ppc_ecdf_overlay
> ###   ppc_violin_grouped
> 
> ### ** Examples
> 
> color_scheme_set("brightblue")
> y <- example_y_data()
> yrep <- example_yrep_draws()
> dim(yrep)
[1] 500 434
> ppc_dens_overlay(y, yrep[1:25, ])
> 
> # for ppc_hist,dens,freqpoly,boxplot definitely use a subset yrep rows so
> # only a few (instead of nrow(yrep)) histograms are plotted
> ppc_hist(y, yrep[1:8, ])
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> ppc_freqpoly(y, yrep[1:3,], alpha = 0.1, size = 1, binwidth = 5)
> 
> # if groups are different sizes then the 'freq' argument can be useful
> group <- example_group_data()
> ppc_freqpoly_grouped(y, yrep[1:3,], group) + yaxis_text()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # don't need to only use small number of rows for ppc_violin_grouped
> # (as it pools yrep draws within groups)
> color_scheme_set("gray")
> ppc_violin_grouped(y, yrep, group, size = 1.5)
> 
> 
> 
> cleanEx()
> nameEx("PPC-errors")
> ### * PPC-errors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-errors
> ### Title: PPC errors
> ### Aliases: PPC-errors ppc_error_hist ppc_error_hist_grouped
> ###   ppc_error_scatter ppc_error_scatter_avg ppc_error_scatter_avg_vs_x
> ###   ppc_error_binned
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_error_hist(y, yrep[1:3, ])
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # errors within groups
> group <- example_group_data()
> (p1 <- ppc_error_hist_grouped(y, yrep[1:3, ], group))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> p1 + yaxis_text() # defaults to showing counts on y-axis
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # scatterplots
> ppc_error_scatter(y, yrep[10:14, ])
> ppc_error_scatter_avg(y, yrep)
> 
> x <- example_x_data()
> ppc_error_scatter_avg_vs_x(y, yrep, x)
> 
> # ppc_error_binned with binomial model from rstanarm
> ## Not run: 
> ##D library(rstanarm)
> ##D example("example_model", package = "rstanarm")
> ##D formula(example_model)
> ##D 
> ##D # get observed proportion of "successes"
> ##D y <- example_model$y  # matrix of "success" and "failure" counts
> ##D trials <- rowSums(y)
> ##D y_prop <- y[, 1] / trials  # proportions
> ##D 
> ##D # get predicted success proportions
> ##D yrep <- posterior_predict(example_model)
> ##D yrep_prop <- sweep(yrep, 2, trials, "/")
> ##D 
> ##D ppc_error_binned(y_prop, yrep_prop[1:6, ])
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-intervals")
> ### * PPC-intervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-intervals
> ### Title: PPC intervals
> ### Aliases: PPC-intervals ppc_intervals ppc_intervals_grouped ppc_ribbon
> ###   ppc_ribbon_grouped ppc_intervals_data ppc_ribbon_data
> 
> ### ** Examples
> 
> y <- rnorm(50)
> yrep <- matrix(rnorm(5000, 0, 2), ncol = 50)
> 
> color_scheme_set("brightblue")
> ppc_ribbon(y, yrep)
> ppc_intervals(y, yrep)
> 
> # change x axis to y values (instead of indices) and add x = y line
> ppc_intervals(y, yrep, x = y) + abline_01()
> 
> 
> color_scheme_set("teal")
> year <- 1950:1999
> ppc_ribbon(y, yrep, x = year, alpha = 0, size = 0.75) + ggplot2::xlab("Year")
> 
> color_scheme_set("pink")
> year <- rep(2000:2009, each = 5)
> group <- gl(5, 1, length = 50, labels = LETTERS[1:5])
> ppc_ribbon_grouped(y, yrep, x = year, group) +
+   ggplot2::scale_x_continuous(breaks = pretty)
> 
> ppc_ribbon_grouped(
+  y, yrep, x = year, group,
+  facet_args = list(scales = "fixed"),
+  alpha = 1,
+  size = 2
+ ) +
+  xaxis_text(FALSE) +
+  xaxis_ticks(FALSE) +
+  panel_bg(fill = "gray20")
> 
> ppc_dat <- ppc_intervals_data(y, yrep, x = year, prob = 0.5)
> ppc_group_dat <- ppc_intervals_data(y, yrep, x = year, group = group, prob = 0.5)
> 
> ## Not run: 
> ##D library("rstanarm")
> ##D fit <- stan_glmer(mpg ~ wt + (1|cyl), data = mtcars)
> ##D yrep <- posterior_predict(fit)
> ##D 
> ##D color_scheme_set("purple")
> ##D with(mtcars, ppc_intervals(mpg, yrep, x = wt, prob = 0.5)) +
> ##D  panel_bg(fill="gray90", color = NA) +
> ##D  grid_lines(color = "white")
> ##D 
> ##D ppc_intervals_grouped(y = mtcars$mpg, yrep, prob = 0.8,
> ##D                       x = mtcars$wt, group = mtcars$cyl)
> ##D 
> ##D 
> ##D color_scheme_set("gray")
> ##D ppc_intervals(mtcars$mpg, yrep, prob = 0.5) +
> ##D  ggplot2::scale_x_continuous(
> ##D    labels = rownames(mtcars),
> ##D    breaks = 1:nrow(mtcars)
> ##D  ) +
> ##D  xaxis_text(angle = -70, vjust = 1, hjust = 0)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-loo")
> ### * PPC-loo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-loo
> ### Title: LOO predictive checks
> ### Aliases: PPC-loo ppc_loo_pit_overlay ppc_loo_pit_qq ppc_loo_pit
> ###   ppc_loo_intervals ppc_loo_ribbon
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D library(loo)
> ##D 
> ##D head(radon)
> ##D fit <- stan_lmer(
> ##D   log_radon ~ floor + log_uranium + floor:log_uranium
> ##D                + (1 + floor | county),
> ##D   data = radon,
> ##D   iter = 1000,
> ##D   chains = 2  # ,cores = 2
> ##D  )
> ##D y <- radon$log_radon
> ##D yrep <- posterior_predict(fit)
> ##D 
> ##D loo1 <- loo(fit, save_psis = TRUE, cores = 2)
> ##D psis1 <- loo1$psis_object
> ##D lw <- weights(psis1)
> ##D 
> ##D # marginal predictive check using LOO probability integral transform
> ##D color_scheme_set("orange")
> ##D ppc_loo_pit_overlay(y, yrep, lw = lw)
> ##D 
> ##D ppc_loo_pit_qq(y, yrep, lw = lw)
> ##D ppc_loo_pit_qq(y, yrep, lw = lw, compare = "normal")
> ##D 
> ##D 
> ##D # loo predictive intervals vs observations
> ##D keep_obs <- 1:50
> ##D ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs)
> ##D 
> ##D color_scheme_set("gray")
> ##D ppc_loo_intervals(y, yrep, psis_object = psis1, subset = keep_obs,
> ##D                   order = "median")
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-scatterplots")
> ### * PPC-scatterplots
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-scatterplots
> ### Title: PPC scatterplots
> ### Aliases: PPC-scatterplots ppc_scatter ppc_scatter_avg
> ###   ppc_scatter_avg_grouped
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> p1 <- ppc_scatter_avg(y, yrep)
> p1
> p2 <- ppc_scatter(y, yrep[20:23, ], alpha = 0.5, size = 1.5)
> p2
> 
> # give x and y axes the same limits
> lims <- ggplot2::lims(x = c(0, 160), y = c(0, 160))
> p1 + lims
> p2 + lims
Warning: Removed 1 rows containing missing values (geom_point).
> 
> group <- example_group_data()
> ppc_scatter_avg_grouped(y, yrep, group, alpha = 0.7) + lims
> 
> 
> 
> 
> cleanEx()
> nameEx("PPC-test-statistics")
> ### * PPC-test-statistics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: PPC-test-statistics
> ### Title: PPC test statistics
> ### Aliases: PPC-test-statistics ppc_stat ppc_stat_grouped
> ###   ppc_stat_freqpoly_grouped ppc_stat_2d
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_stat(y, yrep)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppc_stat(y, yrep, stat = "sd") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ppc_stat_2d(y, yrep)
> ppc_stat_2d(y, yrep, stat = c("median", "mean")) + legend_move("bottom")
> 
> color_scheme_set("teal")
> group <- example_group_data()
> ppc_stat_grouped(y, yrep, group)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> color_scheme_set("mix-red-blue")
> ppc_stat_freqpoly_grouped(y, yrep, group, facet_args = list(nrow = 2))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # use your own function to compute test statistics
> color_scheme_set("brightblue")
> q25 <- function(y) quantile(y, 0.25)
> ppc_stat(y, yrep, stat = "q25") # legend includes function name
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # can define the function in the 'stat' argument but then
> # the legend doesn't include a function name
> ppc_stat(y, yrep, stat = function(y) quantile(y, 0.25))
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()
> nameEx("available_ppc")
> ### * available_ppc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: available_ppc
> ### Title: Get or view the names of available plotting functions
> ### Aliases: available_ppc available_mcmc
> 
> ### ** Examples
> 
> available_mcmc()
bayesplot MCMC module:
  mcmc_acf
  mcmc_acf_bar
  mcmc_areas
  mcmc_areas_data
  mcmc_areas_ridges
  mcmc_areas_ridges_data
  mcmc_combo
  mcmc_dens
  mcmc_dens_chains
  mcmc_dens_chains_data
  mcmc_dens_overlay
  mcmc_hex
  mcmc_hist
  mcmc_hist_by_chain
  mcmc_intervals
  mcmc_intervals_data
  mcmc_neff
  mcmc_neff_data
  mcmc_neff_hist
  mcmc_nuts_acceptance
  mcmc_nuts_divergence
  mcmc_nuts_energy
  mcmc_nuts_stepsize
  mcmc_nuts_treedepth
  mcmc_pairs
  mcmc_parcoord
  mcmc_parcoord_data
  mcmc_recover_hist
  mcmc_recover_intervals
  mcmc_recover_scatter
  mcmc_rhat
  mcmc_rhat_data
  mcmc_rhat_hist
  mcmc_scatter
  mcmc_trace
  mcmc_trace_highlight
  mcmc_violin
> available_mcmc("nuts")
bayesplot MCMC module:
(matching pattern 'nuts') 
  mcmc_nuts_acceptance
  mcmc_nuts_divergence
  mcmc_nuts_energy
  mcmc_nuts_stepsize
  mcmc_nuts_treedepth
> available_mcmc("rhat|neff")
bayesplot MCMC module:
(matching pattern 'rhat|neff') 
  mcmc_neff
  mcmc_neff_data
  mcmc_neff_hist
  mcmc_rhat
  mcmc_rhat_data
  mcmc_rhat_hist
> available_ppc("grouped")
bayesplot PPC module:
(matching pattern 'grouped') 
  ppc_bars_grouped
  ppc_error_hist_grouped
  ppc_freqpoly_grouped
  ppc_intervals_grouped
  ppc_ribbon_grouped
  ppc_scatter_avg_grouped
  ppc_stat_freqpoly_grouped
  ppc_stat_grouped
  ppc_violin_grouped
> available_ppc("grouped", invert = TRUE)
bayesplot PPC module:
(excluding pattern 'grouped') 
  ppc_bars
  ppc_boxplot
  ppc_data
  ppc_dens
  ppc_dens_overlay
  ppc_ecdf_overlay
  ppc_error_binned
  ppc_error_hist
  ppc_error_scatter
  ppc_error_scatter_avg
  ppc_error_scatter_avg_vs_x
  ppc_freqpoly
  ppc_hist
  ppc_intervals
  ppc_intervals_data
  ppc_loo_intervals
  ppc_loo_pit
  ppc_loo_pit_overlay
  ppc_loo_pit_qq
  ppc_loo_ribbon
  ppc_ribbon
  ppc_ribbon_data
  ppc_rootogram
  ppc_scatter
  ppc_scatter_avg
  ppc_stat
  ppc_stat_2d
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-colors")
> ### * bayesplot-colors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-colors
> ### Title: Set, get, or view color schemes
> ### Aliases: bayesplot-colors color_scheme_set color_scheme_get
> ###   color_scheme_view
> 
> ### ** Examples
> 
> color_scheme_set("blue")
> color_scheme_view()
> 
> color_scheme_get()
     blue
1 #d1e1ec
2 #b3cde0
3 #6497b1
4 #005b96
5 #03396c
6 #011f4b
> color_scheme_get(i = c(3, 5)) # 3rd and 5th colors only
$mid
[1] "#6497b1"

$dark
[1] "#03396c"

> 
> color_scheme_get("brightblue")
  brightblue
1    #cce5ff
2    #99cbff
3    #4ca5ff
4    #198bff
5    #0065cc
6    #004c99
> color_scheme_view("brightblue")
> 
> # compare multiple schemes
> color_scheme_view(c("pink", "gray", "teal"))
> color_scheme_view(c("viridis", "viridisA", "viridisB", "viridisC"))
> 
> color_scheme_set("pink")
> x <- example_mcmc_draws()
> mcmc_intervals(x)
> 
> color_scheme_set("teal")
> color_scheme_view()
> mcmc_intervals(x)
> 
> color_scheme_set("red")
> mcmc_areas(x, regex_pars = "beta")
> 
> color_scheme_set("purple")
> color_scheme_view()
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_stat(y, yrep, stat = "mean") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> ###########################
> ### custom color scheme ###
> ###########################
> orange_scheme <- c("#ffebcc", "#ffcc80",
+                    "#ffad33", "#e68a00",
+                    "#995c00", "#663d00")
> color_scheme_set(orange_scheme)
> mcmc_areas(x, regex_pars = "alpha")
> mcmc_dens_overlay(x)
> ppc_stat(y, yrep, stat = "var") + legend_none()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-extractors")
> ### * bayesplot-extractors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-extractors
> ### Title: Extract quantities needed for plotting from model objects
> ### Aliases: bayesplot-extractors log_posterior nuts_params rhat neff_ratio
> ###   log_posterior.stanfit log_posterior.stanreg nuts_params.stanfit
> ###   nuts_params.stanreg nuts_params.list rhat.stanfit rhat.stanreg
> ###   neff_ratio.stanfit neff_ratio.stanreg
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D fit <- stan_glm(mpg ~ wt, data = mtcars)
> ##D 
> ##D np <- nuts_params(fit)
> ##D head(np)
> ##D tail(np)
> ##D 
> ##D lp <- log_posterior(fit)
> ##D head(lp)
> ##D tail(lp)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-helpers")
> ### * bayesplot-helpers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-helpers
> ### Title: Convenience functions for adding or changing plot details
> ### Aliases: bayesplot-helpers vline_at hline_at vline_0 hline_0 abline_01
> ###   lbub legend_move legend_none legend_text xaxis_title xaxis_text
> ###   xaxis_ticks yaxis_title yaxis_text yaxis_ticks facet_text facet_bg
> ###   panel_bg plot_bg grid_lines overlay_function
> 
> ### ** Examples
> 
> color_scheme_set("gray")
> x <- example_mcmc_draws(chains = 1)
> dim(x)
[1] 250   4
> colnames(x)
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"
> 
> 
> ###################################
> ### vertical & horizontal lines ###
> ###################################
> (p <- mcmc_intervals(x, regex_pars = "beta"))
> 
> # vertical line at zero (with some optional styling)
> p + vline_0()
> p + vline_0(size = 0.25, color = "darkgray", linetype = 2)
> 
> # vertical line(s) at specified values
> v <- c(-0.5, 0, 0.5)
> p + vline_at(v, linetype = 3, size = 0.25)
> 
> my_lines <- vline_at(v, alpha = 0.25, size = 0.75 * c(1, 2, 1),
+                      color = c("maroon", "skyblue", "violet"))
> p + my_lines
> 
> 
> # using the lbub function to get interval lower and upper bounds (lb, ub)
> color_scheme_set("pink")
> parsed <- ggplot2::label_parsed
> p2 <- mcmc_hist(x, pars = "beta[1]", binwidth = 1/20,
+                 facet_args = list(labeller = parsed))
> (p2 <- p2 + facet_text(size = 16))
> 
> b1 <- x[, "beta[1]"]
> p2 + vline_at(b1, fun = lbub(0.8), color = "gray20",
+               size = 2 * c(1,.5,1), alpha = 0.75)
> p2 + vline_at(b1, lbub(0.8, med = FALSE), color = "gray20",
+               size = 2, alpha = 0.75)
> 
> 
> ##########################
> ### format axis titles ###
> ##########################
> color_scheme_set("green")
> y <- example_y_data()
> yrep <- example_yrep_draws()
> (p3 <- ppc_stat(y, yrep, stat = "median", binwidth = 1/4))
> 
> # turn off the legend, turn on x-axis title
> p3 +
+  legend_none() +
+  xaxis_title(size = 13, family = "sans") +
+  ggplot2::xlab(expression(italic(T(y)) == median(italic(y))))
> 
> 
> ################################
> ### format axis & facet text ###
> ################################
> color_scheme_set("gray")
> p4 <- mcmc_trace(example_mcmc_draws(), pars = c("alpha", "sigma"))
> 
> myfacets <-
+  facet_bg(fill = "gray30", color = NA) +
+  facet_text(face = "bold", color = "skyblue", size = 14)
> p4 + myfacets
> 
> 
> ##############################
> ### change plot background ###
> ##############################
> color_scheme_set("blue")
> 
> # add grid lines
> ppc_stat(y, yrep) + grid_lines()
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # panel_bg vs plot_bg
> ppc_scatter_avg(y, yrep) + panel_bg(fill = "gray90")
> ppc_scatter_avg(y, yrep) + plot_bg(fill = "gray90")
> 
> color_scheme_set("yellow")
> p5 <- ppc_scatter_avg(y, yrep, alpha = 1)
> p5 + panel_bg(fill = "gray20") + grid_lines(color = "white")
> 
> 
> ###############################################
> ### superimpose a function on existing plot ###
> ###############################################
> # compare posterior of beta[1] to Gaussian with same posterior mean
> # and sd as beta[1]
> x <- example_mcmc_draws(chains = 4)
> dim(x)
[1] 250   4   4
> purple_gaussian <-
+   overlay_function(
+     fun = dnorm,
+     args = list(mean(x[,, "beta[1]"]), sd(x[,, "beta[1]"])),
+     color = "purple",
+     size = 2
+   )
> 
> color_scheme_set("gray")
> mcmc_hist(x, pars = "beta[1]") + purple_gaussian
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot-package")
> ### * bayesplot-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot-package
> ### Title: Plots for Bayesian Models
> ### Aliases: bayesplot-package bayesplot
> 
> ### ** Examples
> 
> # A few quick examples (all of the functions have many examples
> # on their individual help pages)
> 
> # MCMC plots
> x <- example_mcmc_draws(params = 5)
> mcmc_intervals(x, prob = 0.5)
> mcmc_intervals(x, regex_pars = "beta")
> 
> color_scheme_set("purple")
> mcmc_areas(x, regex_pars = "beta", prob = 0.8)
> 
> color_scheme_set("mix-blue-red")
> mcmc_trace(x, pars = c("alpha", "sigma"),
+            facet_args = list(nrow = 2))
> 
> color_scheme_set("brightblue")
> mcmc_scatter(x, pars = c("beta[1]", "sigma"),
+              transformations = list(sigma = "log"))
> 
> 
> # Graphical PPCs
> y <- example_y_data()
> yrep <- example_yrep_draws()
> ppc_dens_overlay(y, yrep[1:50, ])
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot_grid")
> ### * bayesplot_grid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot_grid
> ### Title: Arrange plots in a grid
> ### Aliases: bayesplot_grid
> 
> ### ** Examples
> 
> y <- example_y_data()
> yrep <- example_yrep_draws()
> stats <- c("sd", "median", "max", "min")
> 
> color_scheme_set("pink")
> bayesplot_grid(
+  plots = lapply(stats, function(s) ppc_stat(y, yrep, stat = s)),
+  titles = stats,
+  legends = FALSE,
+  grid_args = list(ncol = 1)
+ )
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> ## Not run: 
> ##D library(rstanarm)
> ##D mtcars$log_mpg <- log(mtcars$mpg)
> ##D fit1 <- stan_glm(mpg ~ wt, data = mtcars)
> ##D fit2 <- stan_glm(log_mpg ~ wt, data = mtcars)
> ##D 
> ##D y <- mtcars$mpg
> ##D yrep1 <- posterior_predict(fit1, draws = 50)
> ##D yrep2 <- posterior_predict(fit2, fun = exp, draws = 50)
> ##D 
> ##D color_scheme_set("blue")
> ##D ppc1 <- ppc_dens_overlay(y, yrep1)
> ##D ppc1
> ##D ppc1 + yaxis_text()
> ##D 
> ##D color_scheme_set("red")
> ##D ppc2 <- ppc_dens_overlay(y, yrep2)
> ##D bayesplot_grid(ppc1, ppc2)
> ##D 
> ##D # make sure the plots use the same limits for the axes
> ##D bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2))
> ##D 
> ##D # remove the legends and add text
> ##D bayesplot_grid(ppc1, ppc2, xlim = c(-5, 60), ylim = c(0, 0.2),
> ##D                legends = FALSE, subtitles = rep("Predicted MPG", 2))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("bayesplot_theme_get")
> ### * bayesplot_theme_get
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bayesplot_theme_get
> ### Title: Get, set, and modify the active bayesplot theme
> ### Aliases: bayesplot_theme_get bayesplot_theme_set bayesplot_theme_update
> ###   bayesplot_theme_replace
> 
> ### ** Examples
> 
> library(ggplot2)
> 
> # plot using the current value of bayesplot_theme_get()
> # (the default is bayesplot::theme_default())
> x <- example_mcmc_draws()
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the bayesplot theme to theme_minimal and save the old theme
> old <- bayesplot_theme_set(theme_minimal())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change back to the previous theme
> bayesplot_theme_set(old)
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the default font size and family for bayesplots
> bayesplot_theme_update(text = element_text(size = 16, family = "sans"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change back to the default
> bayesplot_theme_set() # same as bayesplot_theme_set(theme_default())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # updating theme elements
> color_scheme_set("brightblue")
> bayesplot_theme_set(theme_dark())
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> bayesplot_theme_update(panel.background = element_rect(fill = "black"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # to get the same plot without updating the theme we could also have
> # used the bayeplot convenience function panel_bg()
> bayesplot_theme_set(theme_dark())
> mcmc_hist(x) + panel_bg(fill = "black")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("example-data")
> ### * example-data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: example-data
> ### Title: Example draws to use in demonstrations and tests
> ### Aliases: example-data example_mcmc_draws example_yrep_draws
> ###   example_y_data example_x_data example_group_data
> ### Keywords: internal
> 
> ### ** Examples
> 
> draws <- example_mcmc_draws()
> dim(draws)
[1] 250   4   4
> dimnames(draws)
$Iteration
NULL

$Chain
[1] "chain:1" "chain:2" "chain:3" "chain:4"

$Parameter
[1] "alpha"   "sigma"   "beta[1]" "beta[2]"

> 
> draws <- example_mcmc_draws(1, 2)
> dim(draws)
[1] 250   2
> colnames(draws)
[1] "alpha" "sigma"
> 
> draws <- example_mcmc_draws(params = 6)
> dimnames(draws)[[3]]
[1] "alpha"   "sigma"   "beta[1]" "beta[2]" "beta[3]" "beta[4]"
> 
> y <- example_y_data()
> x <- example_x_data()
> group <- example_group_data()
> length(y)
[1] 434
> length(x)
[1] 434
> length(group)
[1] 434
> tail(data.frame(y, x, group), 5)
     y        x  group
430 94 84.87741 GroupA
431 76 92.99039 GroupB
432 50 94.85971 GroupA
433 88 96.85662 GroupB
434 70 91.25334 GroupB
> 
> yrep <- example_yrep_draws()
> dim(yrep) # ncol(yrep) = length(y) = length(x) = length(group)
[1] 500 434
> 
> 
> 
> 
> cleanEx()
> nameEx("pp_check")
> ### * pp_check
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pp_check
> ### Title: Posterior predictive checks (S3 generic and default method)
> ### Aliases: pp_check pp_check.default
> 
> ### ** Examples
> 
> # default method
> y <- example_y_data()
> yrep <- example_yrep_draws()
> pp_check(y, yrep[1:50,], ppc_dens_overlay)
> 
> g <- example_group_data()
> pp_check(y, yrep, fun = "stat_grouped", group = g, stat = "median")
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # defining a method
> x <- list(y = rnorm(50), yrep = matrix(rnorm(5000), nrow = 100, ncol = 50))
> class(x) <- "foo"
> pp_check.foo <- function(object, ..., type = c("multiple", "overlaid")) {
+   y <- object[["y"]]
+   yrep <- object[["yrep"]]
+   switch(match.arg(type),
+          multiple = ppc_hist(y, yrep[1:min(8, nrow(yrep)),, drop = FALSE]),
+          overlaid = ppc_dens_overlay(y, yrep))
+ }
> pp_check(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> pp_check(x, type = "overlaid")
> 
> 
> 
> 
> cleanEx()
> nameEx("theme_default")
> ### * theme_default
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theme_default
> ### Title: Default bayesplot plotting theme
> ### Aliases: theme_default
> 
> ### ** Examples
> 
> class(theme_default())
[1] "theme" "gg"   
> 
> bayesplot_theme_set() # defaults to setting theme_default()
> x <- example_mcmc_draws()
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> 
> # change the default font size and family for bayesplots
> bayesplot_theme_set(theme_default(base_size = 8, base_family = "sans"))
> mcmc_hist(x)
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
> mcmc_areas(x, regex_pars = "beta")
> 
> # change back
> bayesplot_theme_set()
> mcmc_areas(x, regex_pars = "beta")
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  30.338 0.168 30.718 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
