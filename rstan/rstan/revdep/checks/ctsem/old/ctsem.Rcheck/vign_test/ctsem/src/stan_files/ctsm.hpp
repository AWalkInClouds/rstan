/*
    ctsem is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ctsem is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ctsem.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.18.0

#include <stan/model/model_header.hpp>

namespace model_ctsm_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ctsm");
    reader.add_event(932, 930, "end", "model_ctsm");
    return reader;
}

template <typename T0__>
std::vector<int>
checkoffdiagzero(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& M, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 4;
        validate_non_negative_index("z", "rows(M)", rows(M));
        vector<int> z(rows(M), 0);
        stan::math::fill(z, std::numeric_limits<int>::min());


        current_statement_begin__ = 5;
        for (int i = 1; i <= rows(M); ++i) {

            current_statement_begin__ = 6;
            stan::model::assign(z, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        0, 
                        "assigning variable z");
            current_statement_begin__ = 7;
            for (int j = 1; j <= cols(M); ++j) {

                current_statement_begin__ = 8;
                if (as_bool(logical_neq(i,j))) {

                    current_statement_begin__ = 9;
                    if (as_bool(logical_neq(get_base1(M,i,j,"M",1),0.0))) {

                        current_statement_begin__ = 10;
                        stan::model::assign(z, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                                    1, 
                                    "assigning variable z");
                        current_statement_begin__ = 11;
                        break;
                    }
                }
            }
            current_statement_begin__ = 15;
            if (as_bool(logical_eq(get_base1(z,i,"z",1),0))) {

                current_statement_begin__ = 16;
                for (int j = 1; j <= rows(M); ++j) {

                    current_statement_begin__ = 17;
                    if (as_bool(logical_neq(i,j))) {

                        current_statement_begin__ = 18;
                        if (as_bool(logical_neq(get_base1(M,j,i,"M",1),0.0))) {

                            current_statement_begin__ = 19;
                            stan::model::assign(z, 
                                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                                        1, 
                                        "assigning variable z");
                            current_statement_begin__ = 20;
                            break;
                        }
                    }
                }
            }
        }
        current_statement_begin__ = 26;
        return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct checkoffdiagzero_functor__ {
    template <typename T0__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& M, std::ostream* pstream__) const {
        return checkoffdiagzero(M, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
expm2(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& M, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 30;
        validate_non_negative_index("out", "rows(M)", rows(M));
        validate_non_negative_index("out", "rows(M)", rows(M));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  out(static_cast<Eigen::VectorXd::Index>(rows(M)),static_cast<Eigen::VectorXd::Index>(rows(M)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);
        current_statement_begin__ = 31;
        validate_non_negative_index("z", "rows(out)", rows(out));
        vector<int> z(rows(out), 0);
        stan::math::fill(z, std::numeric_limits<int>::min());
        stan::math::assign(z,checkoffdiagzero(M, pstream__));
        current_statement_begin__ = 32;
        validate_non_negative_index("z1", "sum(z)", sum(z));
        vector<int> z1(sum(z), 0);
        stan::math::fill(z1, std::numeric_limits<int>::min());
        current_statement_begin__ = 33;
        validate_non_negative_index("z0", "(rows(M) - sum(z))", (rows(M) - sum(z)));
        vector<int> z0((rows(M) - sum(z)), 0);
        stan::math::fill(z0, std::numeric_limits<int>::min());
        current_statement_begin__ = 34;
        int cz1(0);
        (void) cz1;  // dummy to suppress unused var warning

        stan::math::fill(cz1, std::numeric_limits<int>::min());
        stan::math::assign(cz1,1);
        current_statement_begin__ = 35;
        int cz0(0);
        (void) cz0;  // dummy to suppress unused var warning

        stan::math::fill(cz0, std::numeric_limits<int>::min());
        stan::math::assign(cz0,1);


        current_statement_begin__ = 36;
        for (int i = 1; i <= rows(M); ++i) {

            current_statement_begin__ = 37;
            if (as_bool(logical_eq(get_base1(z,i,"z",1),1))) {

                current_statement_begin__ = 38;
                stan::model::assign(z1, 
                            stan::model::cons_list(stan::model::index_uni(cz1), stan::model::nil_index_list()), 
                            i, 
                            "assigning variable z1");
                current_statement_begin__ = 39;
                stan::math::assign(cz1, (cz1 + 1));
            }
            current_statement_begin__ = 41;
            if (as_bool(logical_eq(get_base1(z,i,"z",1),0))) {

                current_statement_begin__ = 42;
                stan::model::assign(z0, 
                            stan::model::cons_list(stan::model::index_uni(cz0), stan::model::nil_index_list()), 
                            i, 
                            "assigning variable z0");
                current_statement_begin__ = 43;
                stan::math::assign(cz0, (cz0 + 1));
            }
        }
        current_statement_begin__ = 46;
        if (as_bool(logical_gt(size(z1),0))) {
            current_statement_begin__ = 46;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_multi(z1), stan::model::cons_list(stan::model::index_multi(z1), stan::model::nil_index_list())), 
                        matrix_exp(stan::model::rvalue(M, stan::model::cons_list(stan::model::index_multi(z1), stan::model::cons_list(stan::model::index_multi(z1), stan::model::nil_index_list())), "M")), 
                        "assigning variable out");
        }
        current_statement_begin__ = 47;
        stan::model::assign(out, 
                    stan::model::cons_list(stan::model::index_multi(z0), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                    rep_matrix(0,size(z0),rows(M)), 
                    "assigning variable out");
        current_statement_begin__ = 48;
        stan::model::assign(out, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(z0), stan::model::nil_index_list())), 
                    rep_matrix(0,rows(M),size(z0)), 
                    "assigning variable out");
        current_statement_begin__ = 49;
        for (int i = 1; i <= size(z0); ++i) {
            current_statement_begin__ = 49;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_uni(get_base1(z0,i,"z0",1)), stan::model::cons_list(stan::model::index_uni(get_base1(z0,i,"z0",1)), stan::model::nil_index_list())), 
                        stan::math::exp(get_base1(M,get_base1(z0,i,"z0",1),get_base1(z0,i,"z0",1),"M",1)), 
                        "assigning variable out");
        }
        current_statement_begin__ = 50;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct expm2_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& M, std::ostream* pstream__) const {
        return expm2(M, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
constraincorsqrt(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 54;
        validate_non_negative_index("o", "rows(mat)", rows(mat));
        validate_non_negative_index("o", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  o(static_cast<Eigen::VectorXd::Index>(rows(mat)),static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) o;  // dummy to suppress unused var warning

        stan::math::initialize(o, DUMMY_VAR__);
        stan::math::fill(o,DUMMY_VAR__);
        current_statement_begin__ = 55;
        validate_non_negative_index("s", "rows(mat)", rows(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(rows(mat)));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);


        current_statement_begin__ = 57;
        for (int i = 1; i <= rows(o); ++i) {

            current_statement_begin__ = 58;
            for (int j = std::min((i + 1),rows(mat)); j <= rows(mat); ++j) {

                current_statement_begin__ = 59;
                stan::model::assign(o, 
                            stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            ((inv_logit(get_base1(mat,j,i,"mat",1)) * 2) - 1), 
                            "assigning variable o");
                current_statement_begin__ = 60;
                stan::model::assign(o, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            stan::model::deep_copy(get_base1(o,j,i,"o",1)), 
                            "assigning variable o");
            }
            current_statement_begin__ = 62;
            stan::model::assign(o, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                        1, 
                        "assigning variable o");
        }
        current_statement_begin__ = 65;
        for (int i = 1; i <= rows(o); ++i) {

            current_statement_begin__ = 66;
            stan::model::assign(s, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        inv_sqrt(multiply(stan::model::rvalue(o, stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "o"),stan::model::rvalue(o, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), "o"))), 
                        "assigning variable s");
            current_statement_begin__ = 67;
            if (as_bool(is_inf(get_base1(s,i,"s",1)))) {
                current_statement_begin__ = 67;
                stan::model::assign(s, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                            0, 
                            "assigning variable s");
            }
        }
        current_statement_begin__ = 69;
        return stan::math::promote_scalar<fun_return_scalar_t__>(diag_pre_multiply(s,o));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct constraincorsqrt_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) const {
        return constraincorsqrt(mat, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
sdcovsqrt2cov(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat,
                  const int& cholbasis, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 73;
        if (as_bool(logical_eq(cholbasis,0))) {

            current_statement_begin__ = 74;
            return stan::math::promote_scalar<fun_return_scalar_t__>(tcrossprod(diag_pre_multiply(diagonal(mat),constraincorsqrt(mat, pstream__))));
        } else {
            current_statement_begin__ = 75;
            return stan::math::promote_scalar<fun_return_scalar_t__>(tcrossprod(mat));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct sdcovsqrt2cov_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat,
                  const int& cholbasis, std::ostream* pstream__) const {
        return sdcovsqrt2cov(mat, cholbasis, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
sqkron_prod(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mata,
                const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& matb, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 79;
        int d(0);
        (void) d;  // dummy to suppress unused var warning

        stan::math::fill(d, std::numeric_limits<int>::min());
        stan::math::assign(d,rows(mata));
        current_statement_begin__ = 80;
        validate_non_negative_index("out", "(rows(mata) * rows(matb))", (rows(mata) * rows(matb)));
        validate_non_negative_index("out", "(cols(mata) * cols(matb))", (cols(mata) * cols(matb)));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  out(static_cast<Eigen::VectorXd::Index>((rows(mata) * rows(matb))),static_cast<Eigen::VectorXd::Index>((cols(mata) * cols(matb))));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 81;
        for (int k = 1; k <= d; ++k) {

            current_statement_begin__ = 82;
            for (int l = 1; l <= d; ++l) {

                current_statement_begin__ = 83;
                for (int i = 1; i <= d; ++i) {

                    current_statement_begin__ = 84;
                    for (int j = 1; j <= d; ++j) {

                        current_statement_begin__ = 85;
                        stan::model::assign(out, 
                                    stan::model::cons_list(stan::model::index_uni(((d * (i - 1)) + k)), stan::model::cons_list(stan::model::index_uni(((d * (j - 1)) + l)), stan::model::nil_index_list())), 
                                    (get_base1(mata,i,j,"mata",1) * get_base1(matb,k,l,"matb",1)), 
                                    "assigning variable out");
                    }
                }
            }
        }
        current_statement_begin__ = 90;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct sqkron_prod_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mata,
                const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& matb, std::ostream* pstream__) const {
        return sqkron_prod(mata, matb, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
kronsum(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mata, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 94;
        validate_non_negative_index("II", "rows(mata)", rows(mata));
        validate_non_negative_index("II", "rows(mata)", rows(mata));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  II(static_cast<Eigen::VectorXd::Index>(rows(mata)),static_cast<Eigen::VectorXd::Index>(rows(mata)));
        (void) II;  // dummy to suppress unused var warning

        stan::math::initialize(II, DUMMY_VAR__);
        stan::math::fill(II,DUMMY_VAR__);
        stan::math::assign(II,diag_matrix(rep_vector(1,rows(mata))));


        current_statement_begin__ = 95;
        return stan::math::promote_scalar<fun_return_scalar_t__>(add(sqkron_prod(mata,II, pstream__),sqkron_prod(II,mata, pstream__)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct kronsum_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mata, std::ostream* pstream__) const {
        return kronsum(mata, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
colMeans(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 99;
        validate_non_negative_index("out", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  out(static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 100;
        for (int i = 1; i <= cols(mat); ++i) {

            current_statement_begin__ = 101;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        mean(stan::model::rvalue(mat, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), "mat")), 
                        "assigning variable out");
        }
        current_statement_begin__ = 103;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct colMeans_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) const {
        return colMeans(mat, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
cov_of_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 107;
        validate_non_negative_index("means", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  means(static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) means;  // dummy to suppress unused var warning

        stan::math::initialize(means, DUMMY_VAR__);
        stan::math::fill(means,DUMMY_VAR__);
        stan::math::assign(means,colMeans(mat, pstream__));
        current_statement_begin__ = 108;
        validate_non_negative_index("centered", "rows(mat)", rows(mat));
        validate_non_negative_index("centered", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  centered(static_cast<Eigen::VectorXd::Index>(rows(mat)),static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) centered;  // dummy to suppress unused var warning

        stan::math::initialize(centered, DUMMY_VAR__);
        stan::math::fill(centered,DUMMY_VAR__);
        current_statement_begin__ = 109;
        validate_non_negative_index("covm", "cols(mat)", cols(mat));
        validate_non_negative_index("covm", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  covm(static_cast<Eigen::VectorXd::Index>(cols(mat)),static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) covm;  // dummy to suppress unused var warning

        stan::math::initialize(covm, DUMMY_VAR__);
        stan::math::fill(covm,DUMMY_VAR__);


        current_statement_begin__ = 110;
        for (int coli = 1; coli <= cols(mat); ++coli) {

            current_statement_begin__ = 111;
            for (int ri = 1; ri <= rows(mat); ++ri) {

                current_statement_begin__ = 112;
                stan::model::assign(centered, 
                            stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                            (get_base1(mat,ri,coli,"mat",1) - get_base1(means,coli,"means",1)), 
                            "assigning variable centered");
            }
        }
        current_statement_begin__ = 115;
        stan::math::assign(covm, divide(crossprod(centered),(rows(mat) - 1)));
        current_statement_begin__ = 116;
        return stan::math::promote_scalar<fun_return_scalar_t__>(covm);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct cov_of_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat, std::ostream* pstream__) const {
        return cov_of_matrix(mat, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
crosscov(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& a,
             const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& b, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 120;
        validate_non_negative_index("da", "rows(a)", rows(a));
        validate_non_negative_index("da", "cols(a)", cols(a));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  da(static_cast<Eigen::VectorXd::Index>(rows(a)),static_cast<Eigen::VectorXd::Index>(cols(a)));
        (void) da;  // dummy to suppress unused var warning

        stan::math::initialize(da, DUMMY_VAR__);
        stan::math::fill(da,DUMMY_VAR__);
        current_statement_begin__ = 121;
        validate_non_negative_index("db", "rows(b)", rows(b));
        validate_non_negative_index("db", "cols(b)", cols(b));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  db(static_cast<Eigen::VectorXd::Index>(rows(b)),static_cast<Eigen::VectorXd::Index>(cols(b)));
        (void) db;  // dummy to suppress unused var warning

        stan::math::initialize(db, DUMMY_VAR__);
        stan::math::fill(db,DUMMY_VAR__);
        current_statement_begin__ = 122;
        validate_non_negative_index("out", "cols(a)", cols(a));
        validate_non_negative_index("out", "cols(b)", cols(b));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  out(static_cast<Eigen::VectorXd::Index>(cols(a)),static_cast<Eigen::VectorXd::Index>(cols(b)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 124;
        stan::math::assign(da, subtract(a,rep_matrix(transpose(colMeans(a, pstream__)),rows(a))));
        current_statement_begin__ = 125;
        stan::math::assign(db, subtract(b,rep_matrix(transpose(colMeans(b, pstream__)),rows(b))));
        current_statement_begin__ = 126;
        stan::math::assign(out, elt_divide(multiply(transpose(da),db),(rows(a) - 1.0)));
        current_statement_begin__ = 127;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct crosscov_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& a,
             const Eigen::Matrix<T1__, Eigen::Dynamic,Eigen::Dynamic>& b, std::ostream* pstream__) const {
        return crosscov(a, b, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
makesym(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat,
            const int& verbose,
            const int& pd, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 132;
        validate_non_negative_index("out", "rows(mat)", rows(mat));
        validate_non_negative_index("out", "cols(mat)", cols(mat));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  out(static_cast<Eigen::VectorXd::Index>(rows(mat)),static_cast<Eigen::VectorXd::Index>(cols(mat)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 133;
        for (int coli = 1; coli <= cols(mat); ++coli) {

            current_statement_begin__ = 134;
            if (as_bool(logical_eq(pd,1))) {

                current_statement_begin__ = 136;
                stan::model::assign(out, 
                            stan::model::cons_list(stan::model::index_uni(coli), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                            (get_base1(mat,coli,coli,"mat",1) + 1.0000000000000001e-05), 
                            "assigning variable out");
            } else {
                current_statement_begin__ = 137;
                stan::model::assign(out, 
                            stan::model::cons_list(stan::model::index_uni(coli), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                            get_base1(mat,coli,coli,"mat",1), 
                            "assigning variable out");
            }
            current_statement_begin__ = 138;
            for (int rowi = coli; rowi <= rows(mat); ++rowi) {

                current_statement_begin__ = 139;
                if (as_bool(logical_gt(rowi,coli))) {

                    current_statement_begin__ = 140;
                    stan::model::assign(out, 
                                stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                                get_base1(mat,rowi,coli,"mat",1), 
                                "assigning variable out");
                    current_statement_begin__ = 141;
                    stan::model::assign(out, 
                                stan::model::cons_list(stan::model::index_uni(coli), stan::model::cons_list(stan::model::index_uni(rowi), stan::model::nil_index_list())), 
                                get_base1(mat,rowi,coli,"mat",1), 
                                "assigning variable out");
                }
            }
        }
        current_statement_begin__ = 146;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct makesym_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& mat,
            const int& verbose,
            const int& pd, std::ostream* pstream__) const {
        return makesym(mat, verbose, pd, pstream__);
    }
};

template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__>::type>::type
tform(const T0__& param,
          const int& transform,
          const T2__& multiplier,
          const T3__& meanscale,
          const T4__& offset,
          const T5__& inneroffset, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 150;
        local_scalar_t__ out;
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 153;
        if (as_bool(logical_eq(transform,0))) {
            current_statement_begin__ = 153;
            stan::math::assign(out, ((((param * meanscale) * multiplier) + inneroffset) + offset));
        }
        current_statement_begin__ = 155;
        if (as_bool(logical_eq(transform,1))) {
            current_statement_begin__ = 155;
            stan::math::assign(out, ((stan::math::log((1 + stan::math::exp(((param * meanscale) + inneroffset)))) * multiplier) + offset));
        }
        current_statement_begin__ = 157;
        if (as_bool(logical_eq(transform,2))) {
            current_statement_begin__ = 157;
            stan::math::assign(out, ((stan::math::exp(((param * meanscale) + inneroffset)) * multiplier) + offset));
        }
        current_statement_begin__ = 159;
        if (as_bool(logical_eq(transform,3))) {
            current_statement_begin__ = 159;
            stan::math::assign(out, ((inv_logit(((param * meanscale) + inneroffset)) * multiplier) + offset));
        }
        current_statement_begin__ = 161;
        if (as_bool(logical_eq(transform,4))) {
            current_statement_begin__ = 161;
            stan::math::assign(out, ((pow(((param * meanscale) + inneroffset),3) * multiplier) + offset));
        }
        current_statement_begin__ = 165;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct tform_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__>::type>::type
    operator()(const T0__& param,
          const int& transform,
          const T2__& multiplier,
          const T3__& meanscale,
          const T4__& offset,
          const T5__& inneroffset, std::ostream* pstream__) const {
        return tform(param, transform, multiplier, meanscale, offset, inneroffset, pstream__);
    }
};

class model_ctsm : public prob_grad {
private:
    int ndatapoints;
    int nmanifest;
    int nlatent;
    int nsubjects;
    int ntipred;
    int ntdpred;
    vector<int> T0check;
    matrix_d tipredsdata;
    int nmissingtipreds;
    int ntipredeffects;
    double tipredsimputedscale;
    double tipredeffectscale;
    vector<vector_d> Y;
    int nopriors;
    int nldynamics;
    vector<vector_d> tdpreds;
    vector<double> dT;
    vector<double> dTsmall;
    vector<int> integrationsteps;
    vector<int> subject;
    int nparams;
    int continuoustime;
    int nindvarying;
    int nindvaryingoffdiagonals;
    vector_d sdscale;
    vector<int> indvaryingindex;
    vector<int> notindvaryingindex;
    int nt0varstationary;
    int nt0meansstationary;
    vector<vector<int> > t0varstationary;
    vector<vector<int> > t0meansstationary;
    vector<int> nobs_y;
    vector<vector<int> > whichobs_y;
    int ndiffusion;
    vector<int> derrind;
    vector<int> manifesttype;
    vector<int> nbinary_y;
    vector<vector<int> > whichbinary_y;
    vector<int> ncont_y;
    vector<vector<int> > whichcont_y;
    int intoverpop;
    double ukfspread;
    int ukffull;
    int nlmeasurement;
    int intoverstates;
    int verbose;
    vector<int> T0MEANSsubindex;
    vector<int> LAMBDAsubindex;
    vector<int> DRIFTsubindex;
    vector<int> DIFFUSIONsubindex;
    vector<int> MANIFESTVARsubindex;
    vector<int> MANIFESTMEANSsubindex;
    vector<int> CINTsubindex;
    vector<int> T0VARsubindex;
    vector<int> TDPREDEFFECTsubindex;
    vector<int> asymCINTsubindex;
    vector<int> asymDIFFUSIONsubindex;
    vector<vector<int> > TIPREDEFFECTsetup;
    int nrowpopsetup;
    int nrowmatsetup;
    vector<vector<int> > popsetup;
    vector<vector<int> > matsetup;
    vector<vector<double> > popvalues;
    vector<vector<double> > matvalues;
    vector<vector<int> > matrixdims;
    int savescores;
    int nlatentpop;
    int fixedsubpars;
    vector<vector_d> fixedindparams;
    int dokalman;
    vector<int> dokalmanrows;
    double dokalmanpriormodifier;
    matrix_d IIlatent;
    matrix_d IIlatent2;
    matrix_d IIindvar;
    double asquared;
    double sqrtukfadjust;
public:
    model_ctsm(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_ctsm(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;

        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_ctsm_namespace::model_ctsm";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 170;
            context__.validate_dims("data initialization", "ndatapoints", "int", context__.to_vec());
            ndatapoints = int(0);
            vals_i__ = context__.vals_i("ndatapoints");
            pos__ = 0;
            ndatapoints = vals_i__[pos__++];
            current_statement_begin__ = 171;
            context__.validate_dims("data initialization", "nmanifest", "int", context__.to_vec());
            nmanifest = int(0);
            vals_i__ = context__.vals_i("nmanifest");
            pos__ = 0;
            nmanifest = vals_i__[pos__++];
            current_statement_begin__ = 172;
            context__.validate_dims("data initialization", "nlatent", "int", context__.to_vec());
            nlatent = int(0);
            vals_i__ = context__.vals_i("nlatent");
            pos__ = 0;
            nlatent = vals_i__[pos__++];
            current_statement_begin__ = 173;
            context__.validate_dims("data initialization", "nsubjects", "int", context__.to_vec());
            nsubjects = int(0);
            vals_i__ = context__.vals_i("nsubjects");
            pos__ = 0;
            nsubjects = vals_i__[pos__++];
            current_statement_begin__ = 174;
            context__.validate_dims("data initialization", "ntipred", "int", context__.to_vec());
            ntipred = int(0);
            vals_i__ = context__.vals_i("ntipred");
            pos__ = 0;
            ntipred = vals_i__[pos__++];
            current_statement_begin__ = 175;
            context__.validate_dims("data initialization", "ntdpred", "int", context__.to_vec());
            ntdpred = int(0);
            vals_i__ = context__.vals_i("ntdpred");
            pos__ = 0;
            ntdpred = vals_i__[pos__++];
            current_statement_begin__ = 177;
            validate_non_negative_index("T0check", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "T0check", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("T0check", "ndatapoints", ndatapoints);
            T0check = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("T0check");
            pos__ = 0;
            size_t T0check_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < T0check_limit_0__; ++i_0__) {
                T0check[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 178;
            validate_non_negative_index("tipredsdata", "(ntipred ? nsubjects : 0 )", (ntipred ? nsubjects : 0 ));
            validate_non_negative_index("tipredsdata", "(ntipred ? ntipred : 0 )", (ntipred ? ntipred : 0 ));
            context__.validate_dims("data initialization", "tipredsdata", "matrix_d", context__.to_vec((ntipred ? nsubjects : 0 ),(ntipred ? ntipred : 0 )));
            validate_non_negative_index("tipredsdata", "(ntipred ? nsubjects : 0 )", (ntipred ? nsubjects : 0 ));
            validate_non_negative_index("tipredsdata", "(ntipred ? ntipred : 0 )", (ntipred ? ntipred : 0 ));
            tipredsdata = matrix_d(static_cast<Eigen::VectorXd::Index>((ntipred ? nsubjects : 0 )),static_cast<Eigen::VectorXd::Index>((ntipred ? ntipred : 0 )));
            vals_r__ = context__.vals_r("tipredsdata");
            pos__ = 0;
            size_t tipredsdata_m_mat_lim__ = (ntipred ? nsubjects : 0 );
            size_t tipredsdata_n_mat_lim__ = (ntipred ? ntipred : 0 );
            for (size_t n_mat__ = 0; n_mat__ < tipredsdata_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < tipredsdata_m_mat_lim__; ++m_mat__) {
                    tipredsdata(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 179;
            context__.validate_dims("data initialization", "nmissingtipreds", "int", context__.to_vec());
            nmissingtipreds = int(0);
            vals_i__ = context__.vals_i("nmissingtipreds");
            pos__ = 0;
            nmissingtipreds = vals_i__[pos__++];
            current_statement_begin__ = 180;
            context__.validate_dims("data initialization", "ntipredeffects", "int", context__.to_vec());
            ntipredeffects = int(0);
            vals_i__ = context__.vals_i("ntipredeffects");
            pos__ = 0;
            ntipredeffects = vals_i__[pos__++];
            current_statement_begin__ = 181;
            context__.validate_dims("data initialization", "tipredsimputedscale", "double", context__.to_vec());
            tipredsimputedscale = double(0);
            vals_r__ = context__.vals_r("tipredsimputedscale");
            pos__ = 0;
            tipredsimputedscale = vals_r__[pos__++];
            current_statement_begin__ = 182;
            context__.validate_dims("data initialization", "tipredeffectscale", "double", context__.to_vec());
            tipredeffectscale = double(0);
            vals_r__ = context__.vals_r("tipredeffectscale");
            pos__ = 0;
            tipredeffectscale = vals_r__[pos__++];
            current_statement_begin__ = 184;
            validate_non_negative_index("Y", "ndatapoints", ndatapoints);
            validate_non_negative_index("Y", "nmanifest", nmanifest);
            context__.validate_dims("data initialization", "Y", "vector_d", context__.to_vec(ndatapoints,nmanifest));
            validate_non_negative_index("Y", "ndatapoints", ndatapoints);
            validate_non_negative_index("Y", "nmanifest", nmanifest);
            Y = std::vector<vector_d>(ndatapoints,vector_d(static_cast<Eigen::VectorXd::Index>(nmanifest)));
            vals_r__ = context__.vals_r("Y");
            pos__ = 0;
            size_t Y_i_vec_lim__ = nmanifest;
            for (size_t i_vec__ = 0; i_vec__ < Y_i_vec_lim__; ++i_vec__) {
                size_t Y_limit_0__ = ndatapoints;
                for (size_t i_0__ = 0; i_0__ < Y_limit_0__; ++i_0__) {
                    Y[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 185;
            context__.validate_dims("data initialization", "nopriors", "int", context__.to_vec());
            nopriors = int(0);
            vals_i__ = context__.vals_i("nopriors");
            pos__ = 0;
            nopriors = vals_i__[pos__++];
            current_statement_begin__ = 186;
            context__.validate_dims("data initialization", "nldynamics", "int", context__.to_vec());
            nldynamics = int(0);
            vals_i__ = context__.vals_i("nldynamics");
            pos__ = 0;
            nldynamics = vals_i__[pos__++];
            current_statement_begin__ = 187;
            validate_non_negative_index("tdpreds", "(ntdpred ? ndatapoints : 0 )", (ntdpred ? ndatapoints : 0 ));
            validate_non_negative_index("tdpreds", "ntdpred", ntdpred);
            context__.validate_dims("data initialization", "tdpreds", "vector_d", context__.to_vec((ntdpred ? ndatapoints : 0 ),ntdpred));
            validate_non_negative_index("tdpreds", "(ntdpred ? ndatapoints : 0 )", (ntdpred ? ndatapoints : 0 ));
            validate_non_negative_index("tdpreds", "ntdpred", ntdpred);
            tdpreds = std::vector<vector_d>((ntdpred ? ndatapoints : 0 ),vector_d(static_cast<Eigen::VectorXd::Index>(ntdpred)));
            vals_r__ = context__.vals_r("tdpreds");
            pos__ = 0;
            size_t tdpreds_i_vec_lim__ = ntdpred;
            for (size_t i_vec__ = 0; i_vec__ < tdpreds_i_vec_lim__; ++i_vec__) {
                size_t tdpreds_limit_0__ = (ntdpred ? ndatapoints : 0 );
                for (size_t i_0__ = 0; i_0__ < tdpreds_limit_0__; ++i_0__) {
                    tdpreds[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 189;
            validate_non_negative_index("dT", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "dT", "double", context__.to_vec(ndatapoints));
            validate_non_negative_index("dT", "ndatapoints", ndatapoints);
            dT = std::vector<double>(ndatapoints,double(0));
            vals_r__ = context__.vals_r("dT");
            pos__ = 0;
            size_t dT_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < dT_limit_0__; ++i_0__) {
                dT[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 190;
            validate_non_negative_index("dTsmall", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "dTsmall", "double", context__.to_vec(ndatapoints));
            validate_non_negative_index("dTsmall", "ndatapoints", ndatapoints);
            dTsmall = std::vector<double>(ndatapoints,double(0));
            vals_r__ = context__.vals_r("dTsmall");
            pos__ = 0;
            size_t dTsmall_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < dTsmall_limit_0__; ++i_0__) {
                dTsmall[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 191;
            validate_non_negative_index("integrationsteps", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "integrationsteps", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("integrationsteps", "ndatapoints", ndatapoints);
            integrationsteps = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("integrationsteps");
            pos__ = 0;
            size_t integrationsteps_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < integrationsteps_limit_0__; ++i_0__) {
                integrationsteps[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 192;
            validate_non_negative_index("subject", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "subject", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("subject", "ndatapoints", ndatapoints);
            subject = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("subject");
            pos__ = 0;
            size_t subject_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < subject_limit_0__; ++i_0__) {
                subject[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 193;
            context__.validate_dims("data initialization", "nparams", "int", context__.to_vec());
            nparams = int(0);
            vals_i__ = context__.vals_i("nparams");
            pos__ = 0;
            nparams = vals_i__[pos__++];
            current_statement_begin__ = 194;
            context__.validate_dims("data initialization", "continuoustime", "int", context__.to_vec());
            continuoustime = int(0);
            vals_i__ = context__.vals_i("continuoustime");
            pos__ = 0;
            continuoustime = vals_i__[pos__++];
            current_statement_begin__ = 195;
            context__.validate_dims("data initialization", "nindvarying", "int", context__.to_vec());
            nindvarying = int(0);
            vals_i__ = context__.vals_i("nindvarying");
            pos__ = 0;
            nindvarying = vals_i__[pos__++];
            current_statement_begin__ = 196;
            context__.validate_dims("data initialization", "nindvaryingoffdiagonals", "int", context__.to_vec());
            nindvaryingoffdiagonals = int(0);
            vals_i__ = context__.vals_i("nindvaryingoffdiagonals");
            pos__ = 0;
            nindvaryingoffdiagonals = vals_i__[pos__++];
            current_statement_begin__ = 197;
            validate_non_negative_index("sdscale", "nindvarying", nindvarying);
            context__.validate_dims("data initialization", "sdscale", "vector_d", context__.to_vec(nindvarying));
            validate_non_negative_index("sdscale", "nindvarying", nindvarying);
            sdscale = vector_d(static_cast<Eigen::VectorXd::Index>(nindvarying));
            vals_r__ = context__.vals_r("sdscale");
            pos__ = 0;
            size_t sdscale_i_vec_lim__ = nindvarying;
            for (size_t i_vec__ = 0; i_vec__ < sdscale_i_vec_lim__; ++i_vec__) {
                sdscale[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 198;
            validate_non_negative_index("indvaryingindex", "nindvarying", nindvarying);
            context__.validate_dims("data initialization", "indvaryingindex", "int", context__.to_vec(nindvarying));
            validate_non_negative_index("indvaryingindex", "nindvarying", nindvarying);
            indvaryingindex = std::vector<int>(nindvarying,int(0));
            vals_i__ = context__.vals_i("indvaryingindex");
            pos__ = 0;
            size_t indvaryingindex_limit_0__ = nindvarying;
            for (size_t i_0__ = 0; i_0__ < indvaryingindex_limit_0__; ++i_0__) {
                indvaryingindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 199;
            validate_non_negative_index("notindvaryingindex", "(nparams - nindvarying)", (nparams - nindvarying));
            context__.validate_dims("data initialization", "notindvaryingindex", "int", context__.to_vec((nparams - nindvarying)));
            validate_non_negative_index("notindvaryingindex", "(nparams - nindvarying)", (nparams - nindvarying));
            notindvaryingindex = std::vector<int>((nparams - nindvarying),int(0));
            vals_i__ = context__.vals_i("notindvaryingindex");
            pos__ = 0;
            size_t notindvaryingindex_limit_0__ = (nparams - nindvarying);
            for (size_t i_0__ = 0; i_0__ < notindvaryingindex_limit_0__; ++i_0__) {
                notindvaryingindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 201;
            context__.validate_dims("data initialization", "nt0varstationary", "int", context__.to_vec());
            nt0varstationary = int(0);
            vals_i__ = context__.vals_i("nt0varstationary");
            pos__ = 0;
            nt0varstationary = vals_i__[pos__++];
            current_statement_begin__ = 202;
            context__.validate_dims("data initialization", "nt0meansstationary", "int", context__.to_vec());
            nt0meansstationary = int(0);
            vals_i__ = context__.vals_i("nt0meansstationary");
            pos__ = 0;
            nt0meansstationary = vals_i__[pos__++];
            current_statement_begin__ = 203;
            validate_non_negative_index("t0varstationary", "nt0varstationary", nt0varstationary);
            validate_non_negative_index("t0varstationary", "2", 2);
            context__.validate_dims("data initialization", "t0varstationary", "int", context__.to_vec(nt0varstationary,2));
            validate_non_negative_index("t0varstationary", "nt0varstationary", nt0varstationary);
            validate_non_negative_index("t0varstationary", "2", 2);
            t0varstationary = std::vector<std::vector<int> >(nt0varstationary,std::vector<int>(2,int(0)));
            vals_i__ = context__.vals_i("t0varstationary");
            pos__ = 0;
            size_t t0varstationary_limit_1__ = 2;
            for (size_t i_1__ = 0; i_1__ < t0varstationary_limit_1__; ++i_1__) {
                size_t t0varstationary_limit_0__ = nt0varstationary;
                for (size_t i_0__ = 0; i_0__ < t0varstationary_limit_0__; ++i_0__) {
                    t0varstationary[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 204;
            validate_non_negative_index("t0meansstationary", "nt0meansstationary", nt0meansstationary);
            validate_non_negative_index("t0meansstationary", "2", 2);
            context__.validate_dims("data initialization", "t0meansstationary", "int", context__.to_vec(nt0meansstationary,2));
            validate_non_negative_index("t0meansstationary", "nt0meansstationary", nt0meansstationary);
            validate_non_negative_index("t0meansstationary", "2", 2);
            t0meansstationary = std::vector<std::vector<int> >(nt0meansstationary,std::vector<int>(2,int(0)));
            vals_i__ = context__.vals_i("t0meansstationary");
            pos__ = 0;
            size_t t0meansstationary_limit_1__ = 2;
            for (size_t i_1__ = 0; i_1__ < t0meansstationary_limit_1__; ++i_1__) {
                size_t t0meansstationary_limit_0__ = nt0meansstationary;
                for (size_t i_0__ = 0; i_0__ < t0meansstationary_limit_0__; ++i_0__) {
                    t0meansstationary[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 206;
            validate_non_negative_index("nobs_y", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "nobs_y", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("nobs_y", "ndatapoints", ndatapoints);
            nobs_y = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("nobs_y");
            pos__ = 0;
            size_t nobs_y_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < nobs_y_limit_0__; ++i_0__) {
                nobs_y[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 207;
            validate_non_negative_index("whichobs_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichobs_y", "nmanifest", nmanifest);
            context__.validate_dims("data initialization", "whichobs_y", "int", context__.to_vec(ndatapoints,nmanifest));
            validate_non_negative_index("whichobs_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichobs_y", "nmanifest", nmanifest);
            whichobs_y = std::vector<std::vector<int> >(ndatapoints,std::vector<int>(nmanifest,int(0)));
            vals_i__ = context__.vals_i("whichobs_y");
            pos__ = 0;
            size_t whichobs_y_limit_1__ = nmanifest;
            for (size_t i_1__ = 0; i_1__ < whichobs_y_limit_1__; ++i_1__) {
                size_t whichobs_y_limit_0__ = ndatapoints;
                for (size_t i_0__ = 0; i_0__ < whichobs_y_limit_0__; ++i_0__) {
                    whichobs_y[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 208;
            context__.validate_dims("data initialization", "ndiffusion", "int", context__.to_vec());
            ndiffusion = int(0);
            vals_i__ = context__.vals_i("ndiffusion");
            pos__ = 0;
            ndiffusion = vals_i__[pos__++];
            current_statement_begin__ = 209;
            validate_non_negative_index("derrind", "ndiffusion", ndiffusion);
            context__.validate_dims("data initialization", "derrind", "int", context__.to_vec(ndiffusion));
            validate_non_negative_index("derrind", "ndiffusion", ndiffusion);
            derrind = std::vector<int>(ndiffusion,int(0));
            vals_i__ = context__.vals_i("derrind");
            pos__ = 0;
            size_t derrind_limit_0__ = ndiffusion;
            for (size_t i_0__ = 0; i_0__ < derrind_limit_0__; ++i_0__) {
                derrind[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 211;
            validate_non_negative_index("manifesttype", "nmanifest", nmanifest);
            context__.validate_dims("data initialization", "manifesttype", "int", context__.to_vec(nmanifest));
            validate_non_negative_index("manifesttype", "nmanifest", nmanifest);
            manifesttype = std::vector<int>(nmanifest,int(0));
            vals_i__ = context__.vals_i("manifesttype");
            pos__ = 0;
            size_t manifesttype_limit_0__ = nmanifest;
            for (size_t i_0__ = 0; i_0__ < manifesttype_limit_0__; ++i_0__) {
                manifesttype[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 212;
            validate_non_negative_index("nbinary_y", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "nbinary_y", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("nbinary_y", "ndatapoints", ndatapoints);
            nbinary_y = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("nbinary_y");
            pos__ = 0;
            size_t nbinary_y_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < nbinary_y_limit_0__; ++i_0__) {
                nbinary_y[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 213;
            validate_non_negative_index("whichbinary_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichbinary_y", "nmanifest", nmanifest);
            context__.validate_dims("data initialization", "whichbinary_y", "int", context__.to_vec(ndatapoints,nmanifest));
            validate_non_negative_index("whichbinary_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichbinary_y", "nmanifest", nmanifest);
            whichbinary_y = std::vector<std::vector<int> >(ndatapoints,std::vector<int>(nmanifest,int(0)));
            vals_i__ = context__.vals_i("whichbinary_y");
            pos__ = 0;
            size_t whichbinary_y_limit_1__ = nmanifest;
            for (size_t i_1__ = 0; i_1__ < whichbinary_y_limit_1__; ++i_1__) {
                size_t whichbinary_y_limit_0__ = ndatapoints;
                for (size_t i_0__ = 0; i_0__ < whichbinary_y_limit_0__; ++i_0__) {
                    whichbinary_y[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 214;
            validate_non_negative_index("ncont_y", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "ncont_y", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("ncont_y", "ndatapoints", ndatapoints);
            ncont_y = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("ncont_y");
            pos__ = 0;
            size_t ncont_y_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < ncont_y_limit_0__; ++i_0__) {
                ncont_y[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 215;
            validate_non_negative_index("whichcont_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichcont_y", "nmanifest", nmanifest);
            context__.validate_dims("data initialization", "whichcont_y", "int", context__.to_vec(ndatapoints,nmanifest));
            validate_non_negative_index("whichcont_y", "ndatapoints", ndatapoints);
            validate_non_negative_index("whichcont_y", "nmanifest", nmanifest);
            whichcont_y = std::vector<std::vector<int> >(ndatapoints,std::vector<int>(nmanifest,int(0)));
            vals_i__ = context__.vals_i("whichcont_y");
            pos__ = 0;
            size_t whichcont_y_limit_1__ = nmanifest;
            for (size_t i_1__ = 0; i_1__ < whichcont_y_limit_1__; ++i_1__) {
                size_t whichcont_y_limit_0__ = ndatapoints;
                for (size_t i_0__ = 0; i_0__ < whichcont_y_limit_0__; ++i_0__) {
                    whichcont_y[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 217;
            context__.validate_dims("data initialization", "intoverpop", "int", context__.to_vec());
            intoverpop = int(0);
            vals_i__ = context__.vals_i("intoverpop");
            pos__ = 0;
            intoverpop = vals_i__[pos__++];
            current_statement_begin__ = 218;
            context__.validate_dims("data initialization", "ukfspread", "double", context__.to_vec());
            ukfspread = double(0);
            vals_r__ = context__.vals_r("ukfspread");
            pos__ = 0;
            ukfspread = vals_r__[pos__++];
            current_statement_begin__ = 219;
            context__.validate_dims("data initialization", "ukffull", "int", context__.to_vec());
            ukffull = int(0);
            vals_i__ = context__.vals_i("ukffull");
            pos__ = 0;
            ukffull = vals_i__[pos__++];
            current_statement_begin__ = 220;
            context__.validate_dims("data initialization", "nlmeasurement", "int", context__.to_vec());
            nlmeasurement = int(0);
            vals_i__ = context__.vals_i("nlmeasurement");
            pos__ = 0;
            nlmeasurement = vals_i__[pos__++];
            current_statement_begin__ = 221;
            context__.validate_dims("data initialization", "intoverstates", "int", context__.to_vec());
            intoverstates = int(0);
            vals_i__ = context__.vals_i("intoverstates");
            pos__ = 0;
            intoverstates = vals_i__[pos__++];
            current_statement_begin__ = 222;
            context__.validate_dims("data initialization", "verbose", "int", context__.to_vec());
            verbose = int(0);
            vals_i__ = context__.vals_i("verbose");
            pos__ = 0;
            verbose = vals_i__[pos__++];
            current_statement_begin__ = 224;
            validate_non_negative_index("T0MEANSsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "T0MEANSsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("T0MEANSsubindex", "nsubjects", nsubjects);
            T0MEANSsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("T0MEANSsubindex");
            pos__ = 0;
            size_t T0MEANSsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < T0MEANSsubindex_limit_0__; ++i_0__) {
                T0MEANSsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 225;
            validate_non_negative_index("LAMBDAsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "LAMBDAsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("LAMBDAsubindex", "nsubjects", nsubjects);
            LAMBDAsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("LAMBDAsubindex");
            pos__ = 0;
            size_t LAMBDAsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < LAMBDAsubindex_limit_0__; ++i_0__) {
                LAMBDAsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 226;
            validate_non_negative_index("DRIFTsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "DRIFTsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("DRIFTsubindex", "nsubjects", nsubjects);
            DRIFTsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("DRIFTsubindex");
            pos__ = 0;
            size_t DRIFTsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < DRIFTsubindex_limit_0__; ++i_0__) {
                DRIFTsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 227;
            validate_non_negative_index("DIFFUSIONsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "DIFFUSIONsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("DIFFUSIONsubindex", "nsubjects", nsubjects);
            DIFFUSIONsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("DIFFUSIONsubindex");
            pos__ = 0;
            size_t DIFFUSIONsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < DIFFUSIONsubindex_limit_0__; ++i_0__) {
                DIFFUSIONsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 228;
            validate_non_negative_index("MANIFESTVARsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "MANIFESTVARsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("MANIFESTVARsubindex", "nsubjects", nsubjects);
            MANIFESTVARsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("MANIFESTVARsubindex");
            pos__ = 0;
            size_t MANIFESTVARsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < MANIFESTVARsubindex_limit_0__; ++i_0__) {
                MANIFESTVARsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 229;
            validate_non_negative_index("MANIFESTMEANSsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "MANIFESTMEANSsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("MANIFESTMEANSsubindex", "nsubjects", nsubjects);
            MANIFESTMEANSsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("MANIFESTMEANSsubindex");
            pos__ = 0;
            size_t MANIFESTMEANSsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < MANIFESTMEANSsubindex_limit_0__; ++i_0__) {
                MANIFESTMEANSsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 230;
            validate_non_negative_index("CINTsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "CINTsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("CINTsubindex", "nsubjects", nsubjects);
            CINTsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("CINTsubindex");
            pos__ = 0;
            size_t CINTsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < CINTsubindex_limit_0__; ++i_0__) {
                CINTsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 231;
            validate_non_negative_index("T0VARsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "T0VARsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("T0VARsubindex", "nsubjects", nsubjects);
            T0VARsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("T0VARsubindex");
            pos__ = 0;
            size_t T0VARsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < T0VARsubindex_limit_0__; ++i_0__) {
                T0VARsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 232;
            validate_non_negative_index("TDPREDEFFECTsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "TDPREDEFFECTsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("TDPREDEFFECTsubindex", "nsubjects", nsubjects);
            TDPREDEFFECTsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("TDPREDEFFECTsubindex");
            pos__ = 0;
            size_t TDPREDEFFECTsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < TDPREDEFFECTsubindex_limit_0__; ++i_0__) {
                TDPREDEFFECTsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 233;
            validate_non_negative_index("asymCINTsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "asymCINTsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("asymCINTsubindex", "nsubjects", nsubjects);
            asymCINTsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("asymCINTsubindex");
            pos__ = 0;
            size_t asymCINTsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < asymCINTsubindex_limit_0__; ++i_0__) {
                asymCINTsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 234;
            validate_non_negative_index("asymDIFFUSIONsubindex", "nsubjects", nsubjects);
            context__.validate_dims("data initialization", "asymDIFFUSIONsubindex", "int", context__.to_vec(nsubjects));
            validate_non_negative_index("asymDIFFUSIONsubindex", "nsubjects", nsubjects);
            asymDIFFUSIONsubindex = std::vector<int>(nsubjects,int(0));
            vals_i__ = context__.vals_i("asymDIFFUSIONsubindex");
            pos__ = 0;
            size_t asymDIFFUSIONsubindex_limit_0__ = nsubjects;
            for (size_t i_0__ = 0; i_0__ < asymDIFFUSIONsubindex_limit_0__; ++i_0__) {
                asymDIFFUSIONsubindex[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 235;
            validate_non_negative_index("TIPREDEFFECTsetup", "nparams", nparams);
            validate_non_negative_index("TIPREDEFFECTsetup", "ntipred", ntipred);
            context__.validate_dims("data initialization", "TIPREDEFFECTsetup", "int", context__.to_vec(nparams,ntipred));
            validate_non_negative_index("TIPREDEFFECTsetup", "nparams", nparams);
            validate_non_negative_index("TIPREDEFFECTsetup", "ntipred", ntipred);
            TIPREDEFFECTsetup = std::vector<std::vector<int> >(nparams,std::vector<int>(ntipred,int(0)));
            vals_i__ = context__.vals_i("TIPREDEFFECTsetup");
            pos__ = 0;
            size_t TIPREDEFFECTsetup_limit_1__ = ntipred;
            for (size_t i_1__ = 0; i_1__ < TIPREDEFFECTsetup_limit_1__; ++i_1__) {
                size_t TIPREDEFFECTsetup_limit_0__ = nparams;
                for (size_t i_0__ = 0; i_0__ < TIPREDEFFECTsetup_limit_0__; ++i_0__) {
                    TIPREDEFFECTsetup[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 236;
            context__.validate_dims("data initialization", "nrowpopsetup", "int", context__.to_vec());
            nrowpopsetup = int(0);
            vals_i__ = context__.vals_i("nrowpopsetup");
            pos__ = 0;
            nrowpopsetup = vals_i__[pos__++];
            current_statement_begin__ = 237;
            context__.validate_dims("data initialization", "nrowmatsetup", "int", context__.to_vec());
            nrowmatsetup = int(0);
            vals_i__ = context__.vals_i("nrowmatsetup");
            pos__ = 0;
            nrowmatsetup = vals_i__[pos__++];
            current_statement_begin__ = 238;
            validate_non_negative_index("popsetup", "nrowpopsetup", nrowpopsetup);
            validate_non_negative_index("popsetup", "7", 7);
            context__.validate_dims("data initialization", "popsetup", "int", context__.to_vec(nrowpopsetup,7));
            validate_non_negative_index("popsetup", "nrowpopsetup", nrowpopsetup);
            validate_non_negative_index("popsetup", "7", 7);
            popsetup = std::vector<std::vector<int> >(nrowpopsetup,std::vector<int>(7,int(0)));
            vals_i__ = context__.vals_i("popsetup");
            pos__ = 0;
            size_t popsetup_limit_1__ = 7;
            for (size_t i_1__ = 0; i_1__ < popsetup_limit_1__; ++i_1__) {
                size_t popsetup_limit_0__ = nrowpopsetup;
                for (size_t i_0__ = 0; i_0__ < popsetup_limit_0__; ++i_0__) {
                    popsetup[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 239;
            validate_non_negative_index("matsetup", "nrowmatsetup", nrowmatsetup);
            validate_non_negative_index("matsetup", "7", 7);
            context__.validate_dims("data initialization", "matsetup", "int", context__.to_vec(nrowmatsetup,7));
            validate_non_negative_index("matsetup", "nrowmatsetup", nrowmatsetup);
            validate_non_negative_index("matsetup", "7", 7);
            matsetup = std::vector<std::vector<int> >(nrowmatsetup,std::vector<int>(7,int(0)));
            vals_i__ = context__.vals_i("matsetup");
            pos__ = 0;
            size_t matsetup_limit_1__ = 7;
            for (size_t i_1__ = 0; i_1__ < matsetup_limit_1__; ++i_1__) {
                size_t matsetup_limit_0__ = nrowmatsetup;
                for (size_t i_0__ = 0; i_0__ < matsetup_limit_0__; ++i_0__) {
                    matsetup[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 240;
            validate_non_negative_index("popvalues", "nrowpopsetup", nrowpopsetup);
            validate_non_negative_index("popvalues", "6", 6);
            context__.validate_dims("data initialization", "popvalues", "double", context__.to_vec(nrowpopsetup,6));
            validate_non_negative_index("popvalues", "nrowpopsetup", nrowpopsetup);
            validate_non_negative_index("popvalues", "6", 6);
            popvalues = std::vector<std::vector<double> >(nrowpopsetup,std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("popvalues");
            pos__ = 0;
            size_t popvalues_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < popvalues_limit_1__; ++i_1__) {
                size_t popvalues_limit_0__ = nrowpopsetup;
                for (size_t i_0__ = 0; i_0__ < popvalues_limit_0__; ++i_0__) {
                    popvalues[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 241;
            validate_non_negative_index("matvalues", "nrowmatsetup", nrowmatsetup);
            validate_non_negative_index("matvalues", "6", 6);
            context__.validate_dims("data initialization", "matvalues", "double", context__.to_vec(nrowmatsetup,6));
            validate_non_negative_index("matvalues", "nrowmatsetup", nrowmatsetup);
            validate_non_negative_index("matvalues", "6", 6);
            matvalues = std::vector<std::vector<double> >(nrowmatsetup,std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("matvalues");
            pos__ = 0;
            size_t matvalues_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < matvalues_limit_1__; ++i_1__) {
                size_t matvalues_limit_0__ = nrowmatsetup;
                for (size_t i_0__ = 0; i_0__ < matvalues_limit_0__; ++i_0__) {
                    matvalues[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 242;
            validate_non_negative_index("matrixdims", "9", 9);
            validate_non_negative_index("matrixdims", "2", 2);
            context__.validate_dims("data initialization", "matrixdims", "int", context__.to_vec(9,2));
            validate_non_negative_index("matrixdims", "9", 9);
            validate_non_negative_index("matrixdims", "2", 2);
            matrixdims = std::vector<std::vector<int> >(9,std::vector<int>(2,int(0)));
            vals_i__ = context__.vals_i("matrixdims");
            pos__ = 0;
            size_t matrixdims_limit_1__ = 2;
            for (size_t i_1__ = 0; i_1__ < matrixdims_limit_1__; ++i_1__) {
                size_t matrixdims_limit_0__ = 9;
                for (size_t i_0__ = 0; i_0__ < matrixdims_limit_0__; ++i_0__) {
                    matrixdims[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 243;
            context__.validate_dims("data initialization", "savescores", "int", context__.to_vec());
            savescores = int(0);
            vals_i__ = context__.vals_i("savescores");
            pos__ = 0;
            savescores = vals_i__[pos__++];
            current_statement_begin__ = 244;
            context__.validate_dims("data initialization", "nlatentpop", "int", context__.to_vec());
            nlatentpop = int(0);
            vals_i__ = context__.vals_i("nlatentpop");
            pos__ = 0;
            nlatentpop = vals_i__[pos__++];
            current_statement_begin__ = 245;
            context__.validate_dims("data initialization", "fixedsubpars", "int", context__.to_vec());
            fixedsubpars = int(0);
            vals_i__ = context__.vals_i("fixedsubpars");
            pos__ = 0;
            fixedsubpars = vals_i__[pos__++];
            current_statement_begin__ = 246;
            validate_non_negative_index("fixedindparams", "(fixedsubpars ? nsubjects : 0 )", (fixedsubpars ? nsubjects : 0 ));
            validate_non_negative_index("fixedindparams", "(fixedsubpars ? nindvarying : 0 )", (fixedsubpars ? nindvarying : 0 ));
            context__.validate_dims("data initialization", "fixedindparams", "vector_d", context__.to_vec((fixedsubpars ? nsubjects : 0 ),(fixedsubpars ? nindvarying : 0 )));
            validate_non_negative_index("fixedindparams", "(fixedsubpars ? nsubjects : 0 )", (fixedsubpars ? nsubjects : 0 ));
            validate_non_negative_index("fixedindparams", "(fixedsubpars ? nindvarying : 0 )", (fixedsubpars ? nindvarying : 0 ));
            fixedindparams = std::vector<vector_d>((fixedsubpars ? nsubjects : 0 ),vector_d(static_cast<Eigen::VectorXd::Index>((fixedsubpars ? nindvarying : 0 ))));
            vals_r__ = context__.vals_r("fixedindparams");
            pos__ = 0;
            size_t fixedindparams_i_vec_lim__ = (fixedsubpars ? nindvarying : 0 );
            for (size_t i_vec__ = 0; i_vec__ < fixedindparams_i_vec_lim__; ++i_vec__) {
                size_t fixedindparams_limit_0__ = (fixedsubpars ? nsubjects : 0 );
                for (size_t i_0__ = 0; i_0__ < fixedindparams_limit_0__; ++i_0__) {
                    fixedindparams[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 247;
            context__.validate_dims("data initialization", "dokalman", "int", context__.to_vec());
            dokalman = int(0);
            vals_i__ = context__.vals_i("dokalman");
            pos__ = 0;
            dokalman = vals_i__[pos__++];
            current_statement_begin__ = 248;
            validate_non_negative_index("dokalmanrows", "ndatapoints", ndatapoints);
            context__.validate_dims("data initialization", "dokalmanrows", "int", context__.to_vec(ndatapoints));
            validate_non_negative_index("dokalmanrows", "ndatapoints", ndatapoints);
            dokalmanrows = std::vector<int>(ndatapoints,int(0));
            vals_i__ = context__.vals_i("dokalmanrows");
            pos__ = 0;
            size_t dokalmanrows_limit_0__ = ndatapoints;
            for (size_t i_0__ = 0; i_0__ < dokalmanrows_limit_0__; ++i_0__) {
                dokalmanrows[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 249;
            context__.validate_dims("data initialization", "dokalmanpriormodifier", "double", context__.to_vec());
            dokalmanpriormodifier = double(0);
            vals_r__ = context__.vals_r("dokalmanpriormodifier");
            pos__ = 0;
            dokalmanpriormodifier = vals_r__[pos__++];

            // validate, data variables
            current_statement_begin__ = 170;
            check_greater_or_equal(function__,"ndatapoints",ndatapoints,0);
            current_statement_begin__ = 171;
            check_greater_or_equal(function__,"nmanifest",nmanifest,1);
            current_statement_begin__ = 172;
            check_greater_or_equal(function__,"nlatent",nlatent,1);
            current_statement_begin__ = 173;
            check_greater_or_equal(function__,"nsubjects",nsubjects,1);
            current_statement_begin__ = 174;
            check_greater_or_equal(function__,"ntipred",ntipred,0);
            current_statement_begin__ = 175;
            check_greater_or_equal(function__,"ntdpred",ntdpred,0);
            current_statement_begin__ = 177;
            current_statement_begin__ = 178;
            current_statement_begin__ = 179;
            current_statement_begin__ = 180;
            current_statement_begin__ = 181;
            check_greater_or_equal(function__,"tipredsimputedscale",tipredsimputedscale,0);
            current_statement_begin__ = 182;
            check_greater_or_equal(function__,"tipredeffectscale",tipredeffectscale,0);
            current_statement_begin__ = 184;
            current_statement_begin__ = 185;
            current_statement_begin__ = 186;
            current_statement_begin__ = 187;
            current_statement_begin__ = 189;
            current_statement_begin__ = 190;
            current_statement_begin__ = 191;
            current_statement_begin__ = 192;
            current_statement_begin__ = 193;
            check_greater_or_equal(function__,"nparams",nparams,0);
            current_statement_begin__ = 194;
            current_statement_begin__ = 195;
            current_statement_begin__ = 196;
            current_statement_begin__ = 197;
            current_statement_begin__ = 198;
            current_statement_begin__ = 199;
            current_statement_begin__ = 201;
            current_statement_begin__ = 202;
            current_statement_begin__ = 203;
            current_statement_begin__ = 204;
            current_statement_begin__ = 206;
            current_statement_begin__ = 207;
            current_statement_begin__ = 208;
            current_statement_begin__ = 209;
            current_statement_begin__ = 211;
            current_statement_begin__ = 212;
            current_statement_begin__ = 213;
            current_statement_begin__ = 214;
            current_statement_begin__ = 215;
            current_statement_begin__ = 217;
            current_statement_begin__ = 218;
            current_statement_begin__ = 219;
            current_statement_begin__ = 220;
            current_statement_begin__ = 221;
            current_statement_begin__ = 222;
            current_statement_begin__ = 224;
            current_statement_begin__ = 225;
            current_statement_begin__ = 226;
            current_statement_begin__ = 227;
            current_statement_begin__ = 228;
            current_statement_begin__ = 229;
            current_statement_begin__ = 230;
            current_statement_begin__ = 231;
            current_statement_begin__ = 232;
            current_statement_begin__ = 233;
            current_statement_begin__ = 234;
            current_statement_begin__ = 235;
            current_statement_begin__ = 236;
            current_statement_begin__ = 237;
            current_statement_begin__ = 238;
            current_statement_begin__ = 239;
            current_statement_begin__ = 240;
            current_statement_begin__ = 241;
            current_statement_begin__ = 242;
            current_statement_begin__ = 243;
            current_statement_begin__ = 244;
            current_statement_begin__ = 245;
            current_statement_begin__ = 246;
            current_statement_begin__ = 247;
            current_statement_begin__ = 248;
            current_statement_begin__ = 249;
            // initialize data variables
            current_statement_begin__ = 253;
            validate_non_negative_index("IIlatent", "nlatent", nlatent);
            validate_non_negative_index("IIlatent", "nlatent", nlatent);
            IIlatent = matrix_d(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            stan::math::fill(IIlatent,DUMMY_VAR__);
            stan::math::assign(IIlatent,diag_matrix(rep_vector(1,nlatent)));
            current_statement_begin__ = 254;
            validate_non_negative_index("IIlatent2", "(nlatent * nlatent)", (nlatent * nlatent));
            validate_non_negative_index("IIlatent2", "(nlatent * nlatent)", (nlatent * nlatent));
            IIlatent2 = matrix_d(static_cast<Eigen::VectorXd::Index>((nlatent * nlatent)),static_cast<Eigen::VectorXd::Index>((nlatent * nlatent)));
            stan::math::fill(IIlatent2,DUMMY_VAR__);
            stan::math::assign(IIlatent2,diag_matrix(rep_vector(1,(nlatent * nlatent))));
            current_statement_begin__ = 255;
            validate_non_negative_index("IIindvar", "nindvarying", nindvarying);
            validate_non_negative_index("IIindvar", "nindvarying", nindvarying);
            IIindvar = matrix_d(static_cast<Eigen::VectorXd::Index>(nindvarying),static_cast<Eigen::VectorXd::Index>(nindvarying));
            stan::math::fill(IIindvar,DUMMY_VAR__);
            stan::math::assign(IIindvar,diag_matrix(rep_vector(1,nindvarying)));
            current_statement_begin__ = 256;
            asquared = double(0);
            stan::math::fill(asquared,DUMMY_VAR__);
            stan::math::assign(asquared,square(((2.0 / stan::math::sqrt((0.0 + nlatentpop))) * ukfspread)));
            current_statement_begin__ = 257;
            sqrtukfadjust = double(0);
            stan::math::fill(sqrtukfadjust,DUMMY_VAR__);
            stan::math::assign(sqrtukfadjust,stan::math::sqrt(((0.0 + nlatentpop) + ((asquared * (nlatentpop + 0.5)) - nlatentpop))));


            // validate transformed data
            current_statement_begin__ = 253;
            current_statement_begin__ = 254;
            current_statement_begin__ = 255;
            current_statement_begin__ = 256;
            current_statement_begin__ = 257;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 261;
            validate_non_negative_index("rawpopmeans", "nparams", nparams);
            num_params_r__ += nparams;
            current_statement_begin__ = 263;
            validate_non_negative_index("rawpopsdbase", "nindvarying", nindvarying);
            num_params_r__ += nindvarying;
            current_statement_begin__ = 264;
            validate_non_negative_index("sqrtpcov", "nindvaryingoffdiagonals", nindvaryingoffdiagonals);
            num_params_r__ += nindvaryingoffdiagonals;
            current_statement_begin__ = 265;
            validate_non_negative_index("baseindparams", "(fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) )", (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ));
            validate_non_negative_index("baseindparams", "(fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) )", (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ));
            num_params_r__ += (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ) * (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) );
            current_statement_begin__ = 267;
            validate_non_negative_index("tipredeffectparams", "ntipredeffects", ntipredeffects);
            num_params_r__ += ntipredeffects;
            current_statement_begin__ = 268;
            validate_non_negative_index("tipredsimputed", "nmissingtipreds", nmissingtipreds);
            num_params_r__ += nmissingtipreds;
            current_statement_begin__ = 270;
            validate_non_negative_index("etaupdbasestates", "(intoverstates ? 0 : (nlatent * ndatapoints) )", (intoverstates ? 0 : (nlatent * ndatapoints) ));
            num_params_r__ += (intoverstates ? 0 : (nlatent * ndatapoints) );
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_ctsm() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("rawpopmeans")))
            throw std::runtime_error("variable rawpopmeans missing");
        vals_r__ = context__.vals_r("rawpopmeans");
        pos__ = 0U;
        validate_non_negative_index("rawpopmeans", "nparams", nparams);
        context__.validate_dims("initialization", "rawpopmeans", "vector_d", context__.to_vec(nparams));
        vector_d rawpopmeans(static_cast<Eigen::VectorXd::Index>(nparams));
        for (int j1__ = 0U; j1__ < nparams; ++j1__)
            rawpopmeans(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rawpopmeans);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rawpopmeans: ") + e.what());
        }

        if (!(context__.contains_r("rawpopsdbase")))
            throw std::runtime_error("variable rawpopsdbase missing");
        vals_r__ = context__.vals_r("rawpopsdbase");
        pos__ = 0U;
        validate_non_negative_index("rawpopsdbase", "nindvarying", nindvarying);
        context__.validate_dims("initialization", "rawpopsdbase", "vector_d", context__.to_vec(nindvarying));
        vector_d rawpopsdbase(static_cast<Eigen::VectorXd::Index>(nindvarying));
        for (int j1__ = 0U; j1__ < nindvarying; ++j1__)
            rawpopsdbase(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(rawpopsdbase);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable rawpopsdbase: ") + e.what());
        }

        if (!(context__.contains_r("sqrtpcov")))
            throw std::runtime_error("variable sqrtpcov missing");
        vals_r__ = context__.vals_r("sqrtpcov");
        pos__ = 0U;
        validate_non_negative_index("sqrtpcov", "nindvaryingoffdiagonals", nindvaryingoffdiagonals);
        context__.validate_dims("initialization", "sqrtpcov", "vector_d", context__.to_vec(nindvaryingoffdiagonals));
        vector_d sqrtpcov(static_cast<Eigen::VectorXd::Index>(nindvaryingoffdiagonals));
        for (int j1__ = 0U; j1__ < nindvaryingoffdiagonals; ++j1__)
            sqrtpcov(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(sqrtpcov);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sqrtpcov: ") + e.what());
        }

        if (!(context__.contains_r("baseindparams")))
            throw std::runtime_error("variable baseindparams missing");
        vals_r__ = context__.vals_r("baseindparams");
        pos__ = 0U;
        validate_non_negative_index("baseindparams", "(fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) )", (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ));
        validate_non_negative_index("baseindparams", "(fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) )", (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ));
        context__.validate_dims("initialization", "baseindparams", "vector_d", context__.to_vec((fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ),(fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) )));
        std::vector<vector_d> baseindparams((fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ),vector_d(static_cast<Eigen::VectorXd::Index>((fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ))));
        for (int j1__ = 0U; j1__ < (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ); ++j1__)
            for (int i0__ = 0U; i0__ < (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ); ++i0__)
                baseindparams[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ); ++i0__)
            try {
            writer__.vector_unconstrain(baseindparams[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable baseindparams: ") + e.what());
        }

        if (!(context__.contains_r("tipredeffectparams")))
            throw std::runtime_error("variable tipredeffectparams missing");
        vals_r__ = context__.vals_r("tipredeffectparams");
        pos__ = 0U;
        validate_non_negative_index("tipredeffectparams", "ntipredeffects", ntipredeffects);
        context__.validate_dims("initialization", "tipredeffectparams", "vector_d", context__.to_vec(ntipredeffects));
        vector_d tipredeffectparams(static_cast<Eigen::VectorXd::Index>(ntipredeffects));
        for (int j1__ = 0U; j1__ < ntipredeffects; ++j1__)
            tipredeffectparams(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tipredeffectparams);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tipredeffectparams: ") + e.what());
        }

        if (!(context__.contains_r("tipredsimputed")))
            throw std::runtime_error("variable tipredsimputed missing");
        vals_r__ = context__.vals_r("tipredsimputed");
        pos__ = 0U;
        validate_non_negative_index("tipredsimputed", "nmissingtipreds", nmissingtipreds);
        context__.validate_dims("initialization", "tipredsimputed", "vector_d", context__.to_vec(nmissingtipreds));
        vector_d tipredsimputed(static_cast<Eigen::VectorXd::Index>(nmissingtipreds));
        for (int j1__ = 0U; j1__ < nmissingtipreds; ++j1__)
            tipredsimputed(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(tipredsimputed);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tipredsimputed: ") + e.what());
        }

        if (!(context__.contains_r("etaupdbasestates")))
            throw std::runtime_error("variable etaupdbasestates missing");
        vals_r__ = context__.vals_r("etaupdbasestates");
        pos__ = 0U;
        validate_non_negative_index("etaupdbasestates", "(intoverstates ? 0 : (nlatent * ndatapoints) )", (intoverstates ? 0 : (nlatent * ndatapoints) ));
        context__.validate_dims("initialization", "etaupdbasestates", "vector_d", context__.to_vec((intoverstates ? 0 : (nlatent * ndatapoints) )));
        vector_d etaupdbasestates(static_cast<Eigen::VectorXd::Index>((intoverstates ? 0 : (nlatent * ndatapoints) )));
        for (int j1__ = 0U; j1__ < (intoverstates ? 0 : (nlatent * ndatapoints) ); ++j1__)
            etaupdbasestates(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(etaupdbasestates);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable etaupdbasestates: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        typedef T__ local_scalar_t__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawpopmeans;
            (void) rawpopmeans;  // dummy to suppress unused var warning
            if (jacobian__)
                rawpopmeans = in__.vector_constrain(nparams,lp__);
            else
                rawpopmeans = in__.vector_constrain(nparams);

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawpopsdbase;
            (void) rawpopsdbase;  // dummy to suppress unused var warning
            if (jacobian__)
                rawpopsdbase = in__.vector_constrain(nindvarying,lp__);
            else
                rawpopsdbase = in__.vector_constrain(nindvarying);

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  sqrtpcov;
            (void) sqrtpcov;  // dummy to suppress unused var warning
            if (jacobian__)
                sqrtpcov = in__.vector_constrain(nindvaryingoffdiagonals,lp__);
            else
                sqrtpcov = in__.vector_constrain(nindvaryingoffdiagonals);

            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > baseindparams;
            size_t dim_baseindparams_0__ = (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) );
            baseindparams.reserve(dim_baseindparams_0__);
            for (size_t k_0__ = 0; k_0__ < dim_baseindparams_0__; ++k_0__) {
                if (jacobian__)
                    baseindparams.push_back(in__.vector_constrain((fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ),lp__));
                else
                    baseindparams.push_back(in__.vector_constrain((fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) )));
            }

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  tipredeffectparams;
            (void) tipredeffectparams;  // dummy to suppress unused var warning
            if (jacobian__)
                tipredeffectparams = in__.vector_constrain(ntipredeffects,lp__);
            else
                tipredeffectparams = in__.vector_constrain(ntipredeffects);

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  tipredsimputed;
            (void) tipredsimputed;  // dummy to suppress unused var warning
            if (jacobian__)
                tipredsimputed = in__.vector_constrain(nmissingtipreds,lp__);
            else
                tipredsimputed = in__.vector_constrain(nmissingtipreds);

            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  etaupdbasestates;
            (void) etaupdbasestates;  // dummy to suppress unused var warning
            if (jacobian__)
                etaupdbasestates = in__.vector_constrain((intoverstates ? 0 : (nlatent * ndatapoints) ),lp__);
            else
                etaupdbasestates = in__.vector_constrain((intoverstates ? 0 : (nlatent * ndatapoints) ));


            // transformed parameters
            current_statement_begin__ = 274;
            validate_non_negative_index("rawpopsd", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawpopsd(static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopsd;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopsd, DUMMY_VAR__);
            stan::math::fill(rawpopsd,DUMMY_VAR__);
            current_statement_begin__ = 275;
            validate_non_negative_index("rawpopcovsqrt", "nindvarying", nindvarying);
            validate_non_negative_index("rawpopcovsqrt", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  rawpopcovsqrt(static_cast<Eigen::VectorXd::Index>(nindvarying),static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopcovsqrt;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopcovsqrt, DUMMY_VAR__);
            stan::math::fill(rawpopcovsqrt,DUMMY_VAR__);
            current_statement_begin__ = 276;
            local_scalar_t__ ll;
            (void) ll;  // dummy to suppress unused var warning

            stan::math::initialize(ll, DUMMY_VAR__);
            stan::math::fill(ll,DUMMY_VAR__);
            current_statement_begin__ = 277;
            validate_non_negative_index("kalman", "((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))", ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )));
            validate_non_negative_index("kalman", "(savescores ? ndatapoints : 0 )", (savescores ? ndatapoints : 0 ));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > kalman((savescores ? ndatapoints : 0 ), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))))));
            stan::math::initialize(kalman, DUMMY_VAR__);
            stan::math::fill(kalman,DUMMY_VAR__);
            current_statement_begin__ = 278;
            validate_non_negative_index("T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("T0MEANS", "get_base1(T0MEANSsubindex,nsubjects,\"T0MEANSsubindex\",1)", get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > T0MEANS(get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(T0MEANS, DUMMY_VAR__);
            stan::math::fill(T0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 279;
            validate_non_negative_index("LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("LAMBDA", "get_base1(LAMBDAsubindex,nsubjects,\"LAMBDAsubindex\",1)", get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > LAMBDA(get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(LAMBDA, DUMMY_VAR__);
            stan::math::fill(LAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 280;
            validate_non_negative_index("DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("DRIFT", "get_base1(DRIFTsubindex,nsubjects,\"DRIFTsubindex\",1)", get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > DRIFT(get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(DRIFT, DUMMY_VAR__);
            stan::math::fill(DRIFT,DUMMY_VAR__);
            current_statement_begin__ = 281;
            validate_non_negative_index("DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("DIFFUSION", "get_base1(DIFFUSIONsubindex,nsubjects,\"DIFFUSIONsubindex\",1)", get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > DIFFUSION(get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(DIFFUSION, DUMMY_VAR__);
            stan::math::fill(DIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 282;
            validate_non_negative_index("MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("MANIFESTVAR", "get_base1(MANIFESTVARsubindex,nsubjects,\"MANIFESTVARsubindex\",1)", get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > MANIFESTVAR(get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(MANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(MANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 283;
            validate_non_negative_index("MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("MANIFESTMEANS", "get_base1(MANIFESTMEANSsubindex,nsubjects,\"MANIFESTMEANSsubindex\",1)", get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > MANIFESTMEANS(get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(MANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(MANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 284;
            validate_non_negative_index("CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("CINT", "get_base1(CINTsubindex,nsubjects,\"CINTsubindex\",1)", get_base1(CINTsubindex,nsubjects,"CINTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > CINT(get_base1(CINTsubindex,nsubjects,"CINTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(CINT, DUMMY_VAR__);
            stan::math::fill(CINT,DUMMY_VAR__);
            current_statement_begin__ = 285;
            validate_non_negative_index("T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("T0VAR", "get_base1(T0VARsubindex,nsubjects,\"T0VARsubindex\",1)", get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > T0VAR(get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(T0VAR, DUMMY_VAR__);
            stan::math::fill(T0VAR,DUMMY_VAR__);
            current_statement_begin__ = 286;
            validate_non_negative_index("TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("TDPREDEFFECT", "get_base1(TDPREDEFFECTsubindex,nsubjects,\"TDPREDEFFECTsubindex\",1)", get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > TDPREDEFFECT(get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(TDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(TDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 288;
            validate_non_negative_index("asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("asymDIFFUSION", "get_base1(asymDIFFUSIONsubindex,nsubjects,\"asymDIFFUSIONsubindex\",1)", get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > asymDIFFUSION(get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent))));
            stan::math::initialize(asymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(asymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 289;
            validate_non_negative_index("asymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            validate_non_negative_index("asymCINT", "get_base1(asymCINTsubindex,nsubjects,\"asymCINTsubindex\",1)", get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > asymCINT(get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )))));
            stan::math::initialize(asymCINT, DUMMY_VAR__);
            stan::math::fill(asymCINT,DUMMY_VAR__);
            current_statement_begin__ = 292;
            validate_non_negative_index("pop_T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_T0MEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_T0MEANS;  // dummy to suppress unused var warning

            stan::math::initialize(pop_T0MEANS, DUMMY_VAR__);
            stan::math::fill(pop_T0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 293;
            validate_non_negative_index("pop_LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_LAMBDA(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_LAMBDA;  // dummy to suppress unused var warning

            stan::math::initialize(pop_LAMBDA, DUMMY_VAR__);
            stan::math::fill(pop_LAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 294;
            validate_non_negative_index("pop_DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_DRIFT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_DRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_DRIFT, DUMMY_VAR__);
            stan::math::fill(pop_DRIFT,DUMMY_VAR__);
            current_statement_begin__ = 295;
            validate_non_negative_index("pop_DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_DIFFUSION(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_DIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(pop_DIFFUSION, DUMMY_VAR__);
            stan::math::fill(pop_DIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 296;
            validate_non_negative_index("pop_MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_MANIFESTVAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_MANIFESTVAR;  // dummy to suppress unused var warning

            stan::math::initialize(pop_MANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(pop_MANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 297;
            validate_non_negative_index("pop_MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_MANIFESTMEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_MANIFESTMEANS;  // dummy to suppress unused var warning

            stan::math::initialize(pop_MANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(pop_MANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 298;
            validate_non_negative_index("pop_CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_CINT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_CINT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_CINT, DUMMY_VAR__);
            stan::math::fill(pop_CINT,DUMMY_VAR__);
            current_statement_begin__ = 299;
            validate_non_negative_index("pop_T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_T0VAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_T0VAR;  // dummy to suppress unused var warning

            stan::math::initialize(pop_T0VAR, DUMMY_VAR__);
            stan::math::fill(pop_T0VAR,DUMMY_VAR__);
            current_statement_begin__ = 300;
            validate_non_negative_index("pop_TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_TDPREDEFFECT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_TDPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_TDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(pop_TDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 302;
            validate_non_negative_index("pop_asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("pop_asymDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_asymDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) pop_asymDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(pop_asymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(pop_asymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 303;
            validate_non_negative_index("pop_asymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  pop_asymCINT(static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )));
            (void) pop_asymCINT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_asymCINT, DUMMY_VAR__);
            stan::math::fill(pop_asymCINT,DUMMY_VAR__);
            current_statement_begin__ = 307;
            validate_non_negative_index("tipreds", "(ntipred ? nsubjects : 0 )", (ntipred ? nsubjects : 0 ));
            validate_non_negative_index("tipreds", "(ntipred ? ntipred : 0 )", (ntipred ? ntipred : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  tipreds(static_cast<Eigen::VectorXd::Index>((ntipred ? nsubjects : 0 )),static_cast<Eigen::VectorXd::Index>((ntipred ? ntipred : 0 )));
            (void) tipreds;  // dummy to suppress unused var warning

            stan::math::initialize(tipreds, DUMMY_VAR__);
            stan::math::fill(tipreds,DUMMY_VAR__);
            current_statement_begin__ = 308;
            validate_non_negative_index("TIPREDEFFECT", "nparams", nparams);
            validate_non_negative_index("TIPREDEFFECT", "ntipred", ntipred);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  TIPREDEFFECT(static_cast<Eigen::VectorXd::Index>(nparams),static_cast<Eigen::VectorXd::Index>(ntipred));
            (void) TIPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(TIPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(TIPREDEFFECT,DUMMY_VAR__);


            current_statement_begin__ = 310;
            if (as_bool(logical_gt(ntipred,0))) {
                {
                current_statement_begin__ = 311;
                int counter(0);
                (void) counter;  // dummy to suppress unused var warning

                stan::math::fill(counter, std::numeric_limits<int>::min());
                stan::math::assign(counter,0);


                current_statement_begin__ = 312;
                for (int coli = 1; coli <= cols(tipreds); ++coli) {

                    current_statement_begin__ = 313;
                    for (int rowi = 1; rowi <= rows(tipreds); ++rowi) {

                        current_statement_begin__ = 314;
                        if (as_bool(logical_eq(get_base1(tipredsdata,rowi,coli,"tipredsdata",1),99999))) {

                            current_statement_begin__ = 315;
                            stan::math::assign(counter, (counter + 1));
                            current_statement_begin__ = 316;
                            stan::model::assign(tipreds, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                                        get_base1(tipredsimputed,counter,"tipredsimputed",1), 
                                        "assigning variable tipreds");
                        } else {
                            current_statement_begin__ = 317;
                            stan::model::assign(tipreds, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                                        get_base1(tipredsdata,rowi,coli,"tipredsdata",1), 
                                        "assigning variable tipreds");
                        }
                    }
                }
                current_statement_begin__ = 320;
                for (int ci = 1; ci <= ntipred; ++ci) {

                    current_statement_begin__ = 321;
                    for (int ri = 1; ri <= nparams; ++ri) {

                        current_statement_begin__ = 322;
                        if (as_bool(logical_gt(get_base1(get_base1(TIPREDEFFECTsetup,ri,"TIPREDEFFECTsetup",1),ci,"TIPREDEFFECTsetup",2),0))) {

                            current_statement_begin__ = 323;
                            stan::model::assign(TIPREDEFFECT, 
                                        stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                        get_base1(tipredeffectparams,get_base1(get_base1(TIPREDEFFECTsetup,ri,"TIPREDEFFECTsetup",1),ci,"TIPREDEFFECTsetup",2),"tipredeffectparams",1), 
                                        "assigning variable TIPREDEFFECT");
                        } else {

                            current_statement_begin__ = 325;
                            stan::model::assign(TIPREDEFFECT, 
                                        stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                        0, 
                                        "assigning variable TIPREDEFFECT");
                        }
                    }
                }
                }
            }
            current_statement_begin__ = 331;
            if (as_bool(logical_gt(nindvarying,0))) {
                {
                current_statement_begin__ = 332;
                int counter(0);
                (void) counter;  // dummy to suppress unused var warning

                stan::math::fill(counter, std::numeric_limits<int>::min());
                stan::math::assign(counter,0);


                current_statement_begin__ = 333;
                stan::math::assign(rawpopsd, elt_multiply(stan::math::exp(subtract(multiply(2,rawpopsdbase),1)),sdscale));
                current_statement_begin__ = 334;
                for (int j = 1; j <= nindvarying; ++j) {

                    current_statement_begin__ = 335;
                    stan::model::assign(rawpopcovsqrt, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                1, 
                                "assigning variable rawpopcovsqrt");
                    current_statement_begin__ = 336;
                    for (int i = 1; i <= nindvarying; ++i) {

                        current_statement_begin__ = 337;
                        if (as_bool(logical_gt(i,j))) {

                            current_statement_begin__ = 338;
                            stan::math::assign(counter, (counter + 1));
                            current_statement_begin__ = 339;
                            stan::model::assign(rawpopcovsqrt, 
                                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                        get_base1(sqrtpcov,counter,"sqrtpcov",1), 
                                        "assigning variable rawpopcovsqrt");
                            current_statement_begin__ = 340;
                            stan::model::assign(rawpopcovsqrt, 
                                        stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                        get_base1(sqrtpcov,counter,"sqrtpcov",1), 
                                        "assigning variable rawpopcovsqrt");
                        }
                    }
                }
                current_statement_begin__ = 344;
                stan::math::assign(rawpopcovsqrt, stan::model::deep_copy(cholesky_decompose(makesym(tcrossprod(diag_pre_multiply(rawpopsd,constraincorsqrt(rawpopcovsqrt, pstream__))),verbose,1, pstream__))));
                }
            }
            current_statement_begin__ = 348;
            stan::math::assign(ll, 0);
            {
            current_statement_begin__ = 350;
            int si(0);
            (void) si;  // dummy to suppress unused var warning

            stan::math::fill(si, std::numeric_limits<int>::min());
            current_statement_begin__ = 351;
            int firstsubject(0);
            (void) firstsubject;  // dummy to suppress unused var warning

            stan::math::fill(firstsubject, std::numeric_limits<int>::min());
            stan::math::assign(firstsubject,1);
            current_statement_begin__ = 352;
            int counter(0);
            (void) counter;  // dummy to suppress unused var warning

            stan::math::fill(counter, std::numeric_limits<int>::min());
            stan::math::assign(counter,0);
            current_statement_begin__ = 353;
            validate_non_negative_index("eta", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 354;
            validate_non_negative_index("etacov", "nlatentpop", nlatentpop);
            validate_non_negative_index("etacov", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  etacov(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) etacov;  // dummy to suppress unused var warning

            stan::math::initialize(etacov, DUMMY_VAR__);
            stan::math::fill(etacov,DUMMY_VAR__);
            current_statement_begin__ = 357;
            validate_non_negative_index("err", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  err(static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) err;  // dummy to suppress unused var warning

            stan::math::initialize(err, DUMMY_VAR__);
            stan::math::fill(err,DUMMY_VAR__);
            current_statement_begin__ = 358;
            validate_non_negative_index("ypred", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  ypred(static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypred;  // dummy to suppress unused var warning

            stan::math::initialize(ypred, DUMMY_VAR__);
            stan::math::fill(ypred,DUMMY_VAR__);
            current_statement_begin__ = 359;
            validate_non_negative_index("ystate", "(nldynamics ? nmanifest : 0 )", (nldynamics ? nmanifest : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  ystate(static_cast<Eigen::VectorXd::Index>((nldynamics ? nmanifest : 0 )));
            (void) ystate;  // dummy to suppress unused var warning

            stan::math::initialize(ystate, DUMMY_VAR__);
            stan::math::fill(ystate,DUMMY_VAR__);
            current_statement_begin__ = 360;
            validate_non_negative_index("ypredcov", "nmanifest", nmanifest);
            validate_non_negative_index("ypredcov", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ypredcov(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypredcov;  // dummy to suppress unused var warning

            stan::math::initialize(ypredcov, DUMMY_VAR__);
            stan::math::fill(ypredcov,DUMMY_VAR__);
            current_statement_begin__ = 361;
            validate_non_negative_index("K", "nlatentpop", nlatentpop);
            validate_non_negative_index("K", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            current_statement_begin__ = 362;
            validate_non_negative_index("ypredcov_sqrt", "nmanifest", nmanifest);
            validate_non_negative_index("ypredcov_sqrt", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ypredcov_sqrt(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypredcov_sqrt;  // dummy to suppress unused var warning

            stan::math::initialize(ypredcov_sqrt, DUMMY_VAR__);
            stan::math::fill(ypredcov_sqrt,DUMMY_VAR__);
            current_statement_begin__ = 364;
            validate_non_negative_index("kout", "((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))", ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )));
            validate_non_negative_index("kout", "ndatapoints", ndatapoints);
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > kout(ndatapoints, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))))));
            stan::math::initialize(kout, DUMMY_VAR__);
            stan::math::fill(kout,DUMMY_VAR__);
            current_statement_begin__ = 366;
            validate_non_negative_index("sigpoints", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
            validate_non_negative_index("sigpoints", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sigpoints(static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )),static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )));
            (void) sigpoints;  // dummy to suppress unused var warning

            stan::math::initialize(sigpoints, DUMMY_VAR__);
            stan::math::fill(sigpoints,DUMMY_VAR__);
            current_statement_begin__ = 367;
            validate_non_negative_index("state", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  state(static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) state;  // dummy to suppress unused var warning

            stan::math::initialize(state, DUMMY_VAR__);
            stan::math::fill(state,DUMMY_VAR__);
            current_statement_begin__ = 370;
            validate_non_negative_index("discreteDRIFT", "(nlatent + 1)", (nlatent + 1));
            validate_non_negative_index("discreteDRIFT", "(nlatent + 1)", (nlatent + 1));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  discreteDRIFT(static_cast<Eigen::VectorXd::Index>((nlatent + 1)),static_cast<Eigen::VectorXd::Index>((nlatent + 1)));
            (void) discreteDRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(discreteDRIFT, DUMMY_VAR__);
            stan::math::fill(discreteDRIFT,DUMMY_VAR__);
            current_statement_begin__ = 371;
            validate_non_negative_index("discreteDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("discreteDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  discreteDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) discreteDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(discreteDIFFUSION, DUMMY_VAR__);
            stan::math::fill(discreteDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 374;
            validate_non_negative_index("sT0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sT0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sT0MEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)));
            (void) sT0MEANS;  // dummy to suppress unused var warning

            stan::math::initialize(sT0MEANS, DUMMY_VAR__);
            stan::math::fill(sT0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 375;
            validate_non_negative_index("sLAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sLAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sLAMBDA(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)));
            (void) sLAMBDA;  // dummy to suppress unused var warning

            stan::math::initialize(sLAMBDA, DUMMY_VAR__);
            stan::math::fill(sLAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 376;
            validate_non_negative_index("sDRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sDRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDRIFT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)));
            (void) sDRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(sDRIFT, DUMMY_VAR__);
            stan::math::fill(sDRIFT,DUMMY_VAR__);
            current_statement_begin__ = 377;
            validate_non_negative_index("sDIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sDIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDIFFUSION(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)));
            (void) sDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(sDIFFUSION, DUMMY_VAR__);
            stan::math::fill(sDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 378;
            validate_non_negative_index("sMANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sMANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sMANIFESTVAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)));
            (void) sMANIFESTVAR;  // dummy to suppress unused var warning

            stan::math::initialize(sMANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(sMANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 379;
            validate_non_negative_index("sMANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sMANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sMANIFESTMEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)));
            (void) sMANIFESTMEANS;  // dummy to suppress unused var warning

            stan::math::initialize(sMANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(sMANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 380;
            validate_non_negative_index("sCINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sCINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sCINT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)));
            (void) sCINT;  // dummy to suppress unused var warning

            stan::math::initialize(sCINT, DUMMY_VAR__);
            stan::math::fill(sCINT,DUMMY_VAR__);
            current_statement_begin__ = 381;
            validate_non_negative_index("sT0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sT0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sT0VAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)));
            (void) sT0VAR;  // dummy to suppress unused var warning

            stan::math::initialize(sT0VAR, DUMMY_VAR__);
            stan::math::fill(sT0VAR,DUMMY_VAR__);
            current_statement_begin__ = 382;
            validate_non_negative_index("sTDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sTDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sTDPREDEFFECT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)));
            (void) sTDPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(sTDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(sTDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 384;
            validate_non_negative_index("sasymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("sasymDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sasymDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) sasymDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(sasymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(sasymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 385;
            validate_non_negative_index("sasymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  sasymCINT(static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )));
            (void) sasymCINT;  // dummy to suppress unused var warning

            stan::math::initialize(sasymCINT, DUMMY_VAR__);
            stan::math::fill(sasymCINT,DUMMY_VAR__);
            current_statement_begin__ = 386;
            validate_non_negative_index("sDIFFUSIONsqrt", "nlatent", nlatent);
            validate_non_negative_index("sDIFFUSIONsqrt", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDIFFUSIONsqrt(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) sDIFFUSIONsqrt;  // dummy to suppress unused var warning

            stan::math::initialize(sDIFFUSIONsqrt, DUMMY_VAR__);
            stan::math::fill(sDIFFUSIONsqrt,DUMMY_VAR__);


            current_statement_begin__ = 389;
            if (as_bool(logical_eq(nldynamics,0))) {
                current_statement_begin__ = 389;
                stan::math::assign(discreteDIFFUSION, rep_matrix(0,nlatent,nlatent));
            }
            current_statement_begin__ = 391;
            if (as_bool(savescores)) {
                current_statement_begin__ = 391;
                stan::math::assign(kout, stan::model::deep_copy(rep_array(rep_vector(99999,rows(get_base1(kout,1,"kout",1))),ndatapoints)));
            }
            current_statement_begin__ = 393;
            for (int rowi = 1; rowi <= (dokalman ? ndatapoints : 1 ); ++rowi) {

                current_statement_begin__ = 394;
                if (as_bool(logical_eq(get_base1(dokalmanrows,rowi,"dokalmanrows",1),1))) {
                    {
                    current_statement_begin__ = 395;
                    validate_non_negative_index("ukfstates", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
                    validate_non_negative_index("ukfstates", "(ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )", (ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) ));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ukfstates(static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )),static_cast<Eigen::VectorXd::Index>((ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )));
                    (void) ukfstates;  // dummy to suppress unused var warning

                    stan::math::initialize(ukfstates, DUMMY_VAR__);
                    stan::math::fill(ukfstates,DUMMY_VAR__);
                    current_statement_begin__ = 396;
                    validate_non_negative_index("ukfmeasures", "(nldynamics ? nmanifest : 0 )", (nldynamics ? nmanifest : 0 ));
                    validate_non_negative_index("ukfmeasures", "(ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )", (ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) ));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ukfmeasures(static_cast<Eigen::VectorXd::Index>((nldynamics ? nmanifest : 0 )),static_cast<Eigen::VectorXd::Index>((ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )));
                    (void) ukfmeasures;  // dummy to suppress unused var warning

                    stan::math::initialize(ukfmeasures, DUMMY_VAR__);
                    stan::math::fill(ukfmeasures,DUMMY_VAR__);


                    current_statement_begin__ = 397;
                    stan::math::assign(si, get_base1(subject,rowi,"subject",1));
                    current_statement_begin__ = 400;
                    if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {
                        {
                        current_statement_begin__ = 403;
                        validate_non_negative_index("subjectvec", "(firstsubject ? 2 : 1 )", (firstsubject ? 2 : 1 ));
                        vector<int> subjectvec((firstsubject ? 2 : 1 ), 0);
                        stan::math::fill(subjectvec, std::numeric_limits<int>::min());


                        current_statement_begin__ = 404;
                        stan::model::assign(subjectvec, 
                                    stan::model::cons_list(stan::model::index_uni(size(subjectvec)), stan::model::nil_index_list()), 
                                    si, 
                                    "assigning variable subjectvec");
                        current_statement_begin__ = 405;
                        if (as_bool(logical_eq(firstsubject,1))) {

                            current_statement_begin__ = 406;
                            stan::math::assign(firstsubject, 0);
                            current_statement_begin__ = 407;
                            stan::model::assign(subjectvec, 
                                        stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                                        0, 
                                        "assigning variable subjectvec");
                        }
                        current_statement_begin__ = 409;
                        for (int subjectveci = 1; subjectveci <= size(subjectvec); ++subjectveci) {
                            {
                            current_statement_begin__ = 410;
                            int subi(0);
                            (void) subi;  // dummy to suppress unused var warning

                            stan::math::fill(subi, std::numeric_limits<int>::min());
                            stan::math::assign(subi,get_base1(subjectvec,subjectveci,"subjectvec",1));
                            current_statement_begin__ = 411;
                            validate_non_negative_index("rawindparams", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawindparams(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) rawindparams;  // dummy to suppress unused var warning

                            stan::math::initialize(rawindparams, DUMMY_VAR__);
                            stan::math::fill(rawindparams,DUMMY_VAR__);
                            current_statement_begin__ = 412;
                            validate_non_negative_index("tipredaddition", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  tipredaddition(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) tipredaddition;  // dummy to suppress unused var warning

                            stan::math::initialize(tipredaddition, DUMMY_VAR__);
                            stan::math::fill(tipredaddition,DUMMY_VAR__);
                            stan::math::assign(tipredaddition,rep_vector(0,nparams));
                            current_statement_begin__ = 413;
                            validate_non_negative_index("indvaraddition", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  indvaraddition(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) indvaraddition;  // dummy to suppress unused var warning

                            stan::math::initialize(indvaraddition, DUMMY_VAR__);
                            stan::math::fill(indvaraddition,DUMMY_VAR__);
                            stan::math::assign(indvaraddition,rep_vector(0,nparams));


                            current_statement_begin__ = 415;
                            if (as_bool((primitive_value((primitive_value(logical_gt(subi,0)) && primitive_value(logical_gt(nindvarying,0)))) && primitive_value(logical_eq(intoverpop,0))))) {

                                current_statement_begin__ = 416;
                                if (as_bool(logical_eq(fixedsubpars,0))) {
                                    current_statement_begin__ = 416;
                                    stan::model::assign(indvaraddition, 
                                                stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), 
                                                multiply(rawpopcovsqrt,get_base1(baseindparams,subi,"baseindparams",1)), 
                                                "assigning variable indvaraddition");
                                }
                                current_statement_begin__ = 417;
                                if (as_bool(logical_eq(fixedsubpars,1))) {
                                    current_statement_begin__ = 417;
                                    stan::model::assign(indvaraddition, 
                                                stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), 
                                                multiply(rawpopcovsqrt,get_base1(fixedindparams,subi,"fixedindparams",1)), 
                                                "assigning variable indvaraddition");
                                }
                            }
                            current_statement_begin__ = 420;
                            if (as_bool((primitive_value(logical_gt(subi,0)) && primitive_value(logical_gt(ntipred,0))))) {
                                current_statement_begin__ = 420;
                                stan::math::assign(tipredaddition, multiply(TIPREDEFFECT,transpose(get_base1(tipreds,subi,"tipreds",1))));
                            }
                            current_statement_begin__ = 422;
                            stan::math::assign(rawindparams, add(add(rawpopmeans,tipredaddition),indvaraddition));
                            current_statement_begin__ = 424;
                            for (int ri = 1; ri <= size(matsetup); ++ri) {

                                current_statement_begin__ = 425;
                                if (as_bool((primitive_value(logical_lt(subi,2)) || primitive_value((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),0)) && primitive_value((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) || primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),6,"matsetup",2),0))))))))) {
                                    {
                                    current_statement_begin__ = 426;
                                    local_scalar_t__ newval;
                                    (void) newval;  // dummy to suppress unused var warning

                                    stan::math::initialize(newval, DUMMY_VAR__);
                                    stan::math::fill(newval,DUMMY_VAR__);


                                    current_statement_begin__ = 427;
                                    if (as_bool(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),0))) {
                                        current_statement_begin__ = 427;
                                        stan::math::assign(newval, tform(get_base1(rawindparams,get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),"rawindparams",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                    }
                                    current_statement_begin__ = 429;
                                    if (as_bool(logical_lt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),1))) {
                                        current_statement_begin__ = 429;
                                        stan::math::assign(newval, get_base1(get_base1(matvalues,ri,"matvalues",1),1,"matvalues",2));
                                    }
                                    current_statement_begin__ = 430;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1))) {
                                        current_statement_begin__ = 430;
                                        stan::model::assign(sT0MEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sT0MEANS");
                                    }
                                    current_statement_begin__ = 431;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2))) {
                                        current_statement_begin__ = 431;
                                        stan::model::assign(sLAMBDA, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sLAMBDA");
                                    }
                                    current_statement_begin__ = 432;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3))) {
                                        current_statement_begin__ = 432;
                                        stan::model::assign(sDRIFT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sDRIFT");
                                    }
                                    current_statement_begin__ = 433;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4))) {
                                        current_statement_begin__ = 433;
                                        stan::model::assign(sDIFFUSION, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sDIFFUSION");
                                    }
                                    current_statement_begin__ = 434;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5))) {
                                        current_statement_begin__ = 434;
                                        stan::model::assign(sMANIFESTVAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sMANIFESTVAR");
                                    }
                                    current_statement_begin__ = 435;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))) {
                                        current_statement_begin__ = 435;
                                        stan::model::assign(sMANIFESTMEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sMANIFESTMEANS");
                                    }
                                    current_statement_begin__ = 436;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))) {
                                        current_statement_begin__ = 436;
                                        stan::model::assign(sCINT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sCINT");
                                    }
                                    current_statement_begin__ = 437;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))) {
                                        current_statement_begin__ = 437;
                                        stan::model::assign(sT0VAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sT0VAR");
                                    }
                                    current_statement_begin__ = 438;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                        current_statement_begin__ = 438;
                                        stan::model::assign(sTDPREDEFFECT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sTDPREDEFFECT");
                                    }
                                    }
                                }
                            }
                            current_statement_begin__ = 443;
                            stan::model::assign(state, 
                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                        stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"), 
                                        "assigning variable state");
                            current_statement_begin__ = 447;
                            if (as_bool(logical_lte(subi,get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1)))) {

                                current_statement_begin__ = 448;
                                if (as_bool(logical_eq(nldynamics,1))) {
                                    current_statement_begin__ = 448;
                                    stan::math::assign(sDIFFUSIONsqrt, sDIFFUSION);
                                }
                                current_statement_begin__ = 449;
                                stan::math::assign(sDIFFUSION, stan::model::deep_copy(sdcovsqrt2cov(sDIFFUSION,nldynamics, pstream__)));
                            }
                            current_statement_begin__ = 451;
                            if (as_bool(logical_lte(subi,get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1)))) {

                                current_statement_begin__ = 452;
                                if (as_bool(logical_lt(ndiffusion,nlatent))) {
                                    current_statement_begin__ = 452;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(rep_vector(0,(nlatent * nlatent)),nlatent,nlatent));
                                }
                                current_statement_begin__ = 454;
                                if (as_bool(logical_eq(continuoustime,1))) {
                                    current_statement_begin__ = 454;
                                    stan::model::assign(sasymDIFFUSION, 
                                                stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), 
                                                to_matrix(mdivide_left(minus(kronsum(stan::model::rvalue(sDRIFT, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDRIFT"), pstream__)),to_vector(stan::model::rvalue(sDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDIFFUSION"))),ndiffusion,ndiffusion), 
                                                "assigning variable sasymDIFFUSION");
                                }
                                current_statement_begin__ = 458;
                                if (as_bool(logical_eq(continuoustime,0))) {
                                    current_statement_begin__ = 458;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(multiply(subtract(IIlatent2,sqkron_prod(sDRIFT,sDRIFT, pstream__)),to_vector(stan::model::rvalue(sDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDIFFUSION"))),ndiffusion,ndiffusion));
                                }
                            }
                            current_statement_begin__ = 462;
                            if (as_bool(logical_lte(subi,get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1)))) {

                                current_statement_begin__ = 463;
                                for (int ri = 1; ri <= nmanifest; ++ri) {
                                    current_statement_begin__ = 463;
                                    stan::model::assign(sMANIFESTVAR, 
                                                stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ri), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(square(get_base1(sMANIFESTVAR,ri,ri,"sMANIFESTVAR",1))), 
                                                "assigning variable sMANIFESTVAR");
                                }
                            }
                            current_statement_begin__ = 466;
                            if (as_bool(logical_lte(subi,get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1)))) {

                                current_statement_begin__ = 467;
                                stan::math::assign(sT0VAR, stan::model::deep_copy(makesym(sdcovsqrt2cov(sT0VAR,nldynamics, pstream__),verbose,1, pstream__)));
                                current_statement_begin__ = 468;
                                if (as_bool(logical_gt(nt0varstationary,0))) {

                                    current_statement_begin__ = 469;
                                    for (int ri = 1; ri <= nt0varstationary; ++ri) {

                                        current_statement_begin__ = 470;
                                        stan::model::assign(sT0VAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),1,"t0varstationary",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),2,"t0varstationary",2)), stan::model::nil_index_list())), 
                                                    get_base1(sasymDIFFUSION,get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),1,"t0varstationary",2),get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),2,"t0varstationary",2),"sasymDIFFUSION",1), 
                                                    "assigning variable sT0VAR");
                                    }
                                }
                            }
                            current_statement_begin__ = 475;
                            if (as_bool(logical_gt(nt0meansstationary,0))) {

                                current_statement_begin__ = 476;
                                if (as_bool(logical_lte(subi,get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1)))) {

                                    current_statement_begin__ = 477;
                                    if (as_bool(logical_eq(continuoustime,1))) {
                                        current_statement_begin__ = 477;
                                        stan::math::assign(sasymCINT, mdivide_left(minus(sDRIFT),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                    }
                                    current_statement_begin__ = 478;
                                    if (as_bool(logical_eq(continuoustime,0))) {
                                        current_statement_begin__ = 478;
                                        stan::math::assign(sasymCINT, mdivide_left(subtract(IIlatent,sDRIFT),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                    }
                                }
                                current_statement_begin__ = 480;
                                if (as_bool(logical_lte(subi,get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1)))) {

                                    current_statement_begin__ = 481;
                                    for (int ri = 1; ri <= nt0meansstationary; ++ri) {

                                        current_statement_begin__ = 482;
                                        stan::model::assign(sT0MEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0meansstationary,ri,"t0meansstationary",1),1,"t0meansstationary",2)), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                    get_base1(sasymCINT,get_base1(get_base1(t0meansstationary,ri,"t0meansstationary",1),1,"t0meansstationary",2),"sasymCINT",1), 
                                                    "assigning variable sT0MEANS");
                                    }
                                }
                            }
                            current_statement_begin__ = 488;
                            if (as_bool(logical_gt(subi,0))) {

                                current_statement_begin__ = 489;
                                stan::model::assign(T0MEANS, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(T0MEANSsubindex,subi,"T0MEANSsubindex",1)), stan::model::nil_index_list()), 
                                            sT0MEANS, 
                                            "assigning variable T0MEANS");
                                current_statement_begin__ = 490;
                                stan::model::assign(LAMBDA, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(LAMBDAsubindex,subi,"LAMBDAsubindex",1)), stan::model::nil_index_list()), 
                                            sLAMBDA, 
                                            "assigning variable LAMBDA");
                                current_statement_begin__ = 491;
                                stan::model::assign(DRIFT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(DRIFTsubindex,subi,"DRIFTsubindex",1)), stan::model::nil_index_list()), 
                                            sDRIFT, 
                                            "assigning variable DRIFT");
                                current_statement_begin__ = 492;
                                stan::model::assign(DIFFUSION, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(DIFFUSIONsubindex,subi,"DIFFUSIONsubindex",1)), stan::model::nil_index_list()), 
                                            sDIFFUSION, 
                                            "assigning variable DIFFUSION");
                                current_statement_begin__ = 493;
                                stan::model::assign(MANIFESTVAR, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(MANIFESTVARsubindex,subi,"MANIFESTVARsubindex",1)), stan::model::nil_index_list()), 
                                            sMANIFESTVAR, 
                                            "assigning variable MANIFESTVAR");
                                current_statement_begin__ = 494;
                                stan::model::assign(MANIFESTMEANS, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(MANIFESTMEANSsubindex,subi,"MANIFESTMEANSsubindex",1)), stan::model::nil_index_list()), 
                                            sMANIFESTMEANS, 
                                            "assigning variable MANIFESTMEANS");
                                current_statement_begin__ = 495;
                                stan::model::assign(CINT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(CINTsubindex,subi,"CINTsubindex",1)), stan::model::nil_index_list()), 
                                            sCINT, 
                                            "assigning variable CINT");
                                current_statement_begin__ = 496;
                                stan::model::assign(T0VAR, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(T0VARsubindex,subi,"T0VARsubindex",1)), stan::model::nil_index_list()), 
                                            sT0VAR, 
                                            "assigning variable T0VAR");
                                current_statement_begin__ = 497;
                                stan::model::assign(TDPREDEFFECT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(TDPREDEFFECTsubindex,subi,"TDPREDEFFECTsubindex",1)), stan::model::nil_index_list()), 
                                            sTDPREDEFFECT, 
                                            "assigning variable TDPREDEFFECT");
                                current_statement_begin__ = 498;
                                stan::model::assign(asymDIFFUSION, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(asymDIFFUSIONsubindex,subi,"asymDIFFUSIONsubindex",1)), stan::model::nil_index_list()), 
                                            sasymDIFFUSION, 
                                            "assigning variable asymDIFFUSION");
                                current_statement_begin__ = 499;
                                stan::model::assign(asymCINT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(asymCINTsubindex,subi,"asymCINTsubindex",1)), stan::model::nil_index_list()), 
                                            sasymCINT, 
                                            "assigning variable asymCINT");
                            }
                            current_statement_begin__ = 503;
                            if (as_bool(logical_eq(subi,0))) {

                                current_statement_begin__ = 504;
                                stan::math::assign(pop_T0MEANS, sT0MEANS);
                                current_statement_begin__ = 505;
                                stan::math::assign(pop_LAMBDA, sLAMBDA);
                                current_statement_begin__ = 506;
                                stan::math::assign(pop_DRIFT, sDRIFT);
                                current_statement_begin__ = 507;
                                stan::math::assign(pop_DIFFUSION, sDIFFUSION);
                                current_statement_begin__ = 508;
                                stan::math::assign(pop_MANIFESTVAR, sMANIFESTVAR);
                                current_statement_begin__ = 509;
                                stan::math::assign(pop_MANIFESTMEANS, sMANIFESTMEANS);
                                current_statement_begin__ = 510;
                                stan::math::assign(pop_CINT, sCINT);
                                current_statement_begin__ = 511;
                                stan::math::assign(pop_T0VAR, sT0VAR);
                                current_statement_begin__ = 512;
                                stan::math::assign(pop_TDPREDEFFECT, sTDPREDEFFECT);
                                current_statement_begin__ = 513;
                                stan::math::assign(pop_asymDIFFUSION, sasymDIFFUSION);
                                current_statement_begin__ = 514;
                                stan::math::assign(pop_asymCINT, sasymCINT);
                            }
                            }
                        }
                        current_statement_begin__ = 521;
                        if (as_bool(logical_eq(nldynamics,1))) {

                            current_statement_begin__ = 522;
                            stan::math::assign(eta, rep_vector(0,nlatentpop));
                            current_statement_begin__ = 523;
                            stan::math::assign(sigpoints, rep_matrix(0,nlatentpop,nlatentpop));
                            current_statement_begin__ = 524;
                            if (as_bool(logical_eq(intoverpop,1))) {

                                current_statement_begin__ = 525;
                                if (as_bool(logical_eq(ntipred,0))) {
                                    current_statement_begin__ = 525;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list()), 
                                                stan::model::rvalue(rawpopmeans, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "rawpopmeans"), 
                                                "assigning variable eta");
                                }
                                current_statement_begin__ = 526;
                                if (as_bool(logical_gt(ntipred,0))) {
                                    current_statement_begin__ = 526;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(rawpopmeans, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "rawpopmeans"),multiply(stan::model::rvalue(TIPREDEFFECT, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "TIPREDEFFECT"),transpose(get_base1(tipreds,si,"tipreds",1)))), 
                                                "assigning variable eta");
                                }
                            }
                        }
                        current_statement_begin__ = 530;
                        if (as_bool(logical_eq(nldynamics,0))) {

                            current_statement_begin__ = 531;
                            stan::model::assign(state, 
                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                        stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"), 
                                        "assigning variable state");
                            current_statement_begin__ = 533;
                            stan::math::assign(eta, stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"));
                            current_statement_begin__ = 534;
                            if (as_bool(logical_gt(ntdpred,0))) {
                                current_statement_begin__ = 534;
                                stan::math::assign(eta, add(eta, multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))));
                            }
                            current_statement_begin__ = 535;
                            stan::math::assign(etacov, sT0VAR);
                        }
                        }
                    }
                    current_statement_begin__ = 540;
                    if (as_bool((primitive_value(logical_eq(nldynamics,0)) && primitive_value(logical_eq(get_base1(T0check,rowi,"T0check",1),0))))) {

                        current_statement_begin__ = 541;
                        stan::model::assign(state, 
                                    stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                    stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"), 
                                    "assigning variable state");
                        current_statement_begin__ = 543;
                        if (as_bool(logical_eq(continuoustime,1))) {
                            {
                            current_statement_begin__ = 544;
                            int dtchange(0);
                            (void) dtchange;  // dummy to suppress unused var warning

                            stan::math::fill(dtchange, std::numeric_limits<int>::min());
                            stan::math::assign(dtchange,0);


                            current_statement_begin__ = 545;
                            if (as_bool((primitive_value(logical_eq(si,1)) && primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1))))) {

                                current_statement_begin__ = 546;
                                stan::math::assign(dtchange, 1);
                            } else if (as_bool((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value(logical_neq(get_base1(dT,(rowi - 2),"dT",1),get_base1(dT,rowi,"dT",1)))))) {

                                current_statement_begin__ = 548;
                                stan::math::assign(dtchange, 1);
                            } else if (as_bool((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),0)) && primitive_value(logical_neq(get_base1(dT,(rowi - 1),"dT",1),get_base1(dT,rowi,"dT",1)))))) {
                                current_statement_begin__ = 549;
                                stan::math::assign(dtchange, 1);
                            }
                            current_statement_begin__ = 552;
                            if (as_bool((primitive_value(logical_eq(dtchange,1)) || primitive_value((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value((primitive_value(logical_lte(si,get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1))) || primitive_value(logical_lte(si,get_base1(CINTsubindex,nsubjects,"CINTsubindex",1)))))))))) {

                                current_statement_begin__ = 553;
                                stan::math::assign(discreteDRIFT, expm2(multiply(append_row(append_col(sDRIFT,sCINT),rep_matrix(0,1,(nlatent + 1))),get_base1(dT,rowi,"dT",1)), pstream__));
                            }
                            current_statement_begin__ = 556;
                            if (as_bool((primitive_value(logical_eq(dtchange,1)) || primitive_value((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value((primitive_value(logical_lte(si,get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1))) || primitive_value(logical_lte(si,get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1)))))))))) {

                                current_statement_begin__ = 557;
                                stan::model::assign(discreteDIFFUSION, 
                                            stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), 
                                            subtract(stan::model::rvalue(sasymDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sasymDIFFUSION"),quad_form(stan::model::rvalue(sasymDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sasymDIFFUSION"),transpose(stan::model::rvalue(discreteDRIFT, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "discreteDRIFT")))), 
                                            "assigning variable discreteDIFFUSION");
                                current_statement_begin__ = 559;
                                if (as_bool(logical_eq(intoverstates,0))) {
                                    current_statement_begin__ = 559;
                                    stan::math::assign(discreteDIFFUSION, stan::model::deep_copy(cholesky_decompose(makesym(discreteDIFFUSION,verbose,1, pstream__))));
                                }
                            }
                            }
                        }
                        current_statement_begin__ = 563;
                        if (as_bool((primitive_value(logical_eq(continuoustime,0)) && primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1))))) {

                            current_statement_begin__ = 564;
                            stan::math::assign(discreteDRIFT, append_row(append_col(sDRIFT,sCINT),rep_matrix(0,1,(nlatent + 1))));
                            current_statement_begin__ = 565;
                            stan::model::assign(discreteDRIFT, 
                                        stan::model::cons_list(stan::model::index_uni((nlatent + 1)), stan::model::cons_list(stan::model::index_uni((nlatent + 1)), stan::model::nil_index_list())), 
                                        1, 
                                        "assigning variable discreteDRIFT");
                            current_statement_begin__ = 566;
                            stan::math::assign(discreteDIFFUSION, sDIFFUSION);
                            current_statement_begin__ = 567;
                            if (as_bool(logical_eq(intoverstates,0))) {
                                current_statement_begin__ = 567;
                                stan::math::assign(discreteDIFFUSION, stan::model::deep_copy(cholesky_decompose(makesym(discreteDIFFUSION,verbose,1, pstream__))));
                            }
                        }
                        current_statement_begin__ = 570;
                        stan::math::assign(eta, stan::model::deep_copy(stan::model::rvalue(multiply(discreteDRIFT,append_row(eta,1.0)), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "multiply(discreteDRIFT,append_row(eta,1.0))")));
                        current_statement_begin__ = 571;
                        stan::model::assign(state, 
                                    stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                    stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"), 
                                    "assigning variable state");
                        current_statement_begin__ = 573;
                        if (as_bool(logical_gt(ntdpred,0))) {
                            current_statement_begin__ = 573;
                            stan::math::assign(eta, add(eta, multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))));
                        }
                        current_statement_begin__ = 574;
                        if (as_bool(logical_eq(intoverstates,1))) {

                            current_statement_begin__ = 575;
                            stan::math::assign(etacov, stan::model::deep_copy(quad_form(etacov,transpose(stan::model::rvalue(discreteDRIFT, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "discreteDRIFT")))));
                            current_statement_begin__ = 576;
                            if (as_bool(logical_gt(ndiffusion,0))) {
                                current_statement_begin__ = 576;
                                stan::math::assign(etacov, add(etacov, discreteDIFFUSION));
                            }
                        }
                    }
                    current_statement_begin__ = 581;
                    if (as_bool(logical_eq(nldynamics,1))) {

                        current_statement_begin__ = 582;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                            {
                            current_statement_begin__ = 583;
                            validate_non_negative_index("J", "nlatentpop", nlatentpop);
                            validate_non_negative_index("J", "nlatentpop", nlatentpop);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  J(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
                            (void) J;  // dummy to suppress unused var warning

                            stan::math::initialize(J, DUMMY_VAR__);
                            stan::math::fill(J,DUMMY_VAR__);
                            current_statement_begin__ = 584;
                            validate_non_negative_index("base", "nlatent", nlatent);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  base(static_cast<Eigen::VectorXd::Index>(nlatent));
                            (void) base;  // dummy to suppress unused var warning

                            stan::math::initialize(base, DUMMY_VAR__);
                            stan::math::fill(base,DUMMY_VAR__);


                            current_statement_begin__ = 585;
                            stan::math::assign(J, rep_matrix(0,nlatentpop,nlatentpop));
                            current_statement_begin__ = 586;
                            if (as_bool(logical_eq(continuoustime,1))) {
                                {
                                current_statement_begin__ = 587;
                                validate_non_negative_index("Je", "nlatentpop", nlatentpop);
                                validate_non_negative_index("Je", "nlatentpop", nlatentpop);
                                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Je(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
                                (void) Je;  // dummy to suppress unused var warning

                                stan::math::initialize(Je, DUMMY_VAR__);
                                stan::math::fill(Je,DUMMY_VAR__);
                                current_statement_begin__ = 588;
                                validate_non_negative_index("dQi", "(nlatent * 2)", (nlatent * 2));
                                validate_non_negative_index("dQi", "(nlatent * 2)", (nlatent * 2));
                                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  dQi(static_cast<Eigen::VectorXd::Index>((nlatent * 2)),static_cast<Eigen::VectorXd::Index>((nlatent * 2)));
                                (void) dQi;  // dummy to suppress unused var warning

                                stan::math::initialize(dQi, DUMMY_VAR__);
                                stan::math::fill(dQi,DUMMY_VAR__);


                                current_statement_begin__ = 589;
                                for (int stepi = 1; stepi <= get_base1(integrationsteps,rowi,"integrationsteps",1); ++stepi) {

                                    current_statement_begin__ = 590;
                                    for (int statei = 0; statei <= nlatentpop; ++statei) {

                                        current_statement_begin__ = 591;
                                        if (as_bool(logical_gt(statei,0))) {

                                            current_statement_begin__ = 592;
                                            stan::model::assign(J, 
                                                        stan::model::cons_list(stan::model::index_uni(statei), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                        9.9999999999999995e-07, 
                                                        "assigning variable J");
                                            current_statement_begin__ = 593;
                                            stan::math::assign(state, add(eta,stan::model::rvalue(J, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "J")));
                                        } else {

                                            current_statement_begin__ = 595;
                                            stan::math::assign(state, eta);
                                        }
                                        current_statement_begin__ = 600;
                                        if (as_bool(logical_eq(intoverpop,1))) {

                                            current_statement_begin__ = 601;
                                            for (int ri = 1; ri <= size(matsetup); ++ri) {

                                                current_statement_begin__ = 602;
                                                if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                                    current_statement_begin__ = 603;
                                                    if (as_bool((primitive_value((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4)))) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))))) {
                                                        {
                                                        current_statement_begin__ = 604;
                                                        local_scalar_t__ newval;
                                                        (void) newval;  // dummy to suppress unused var warning

                                                        stan::math::initialize(newval, DUMMY_VAR__);
                                                        stan::math::fill(newval,DUMMY_VAR__);


                                                        current_statement_begin__ = 605;
                                                        stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                        current_statement_begin__ = 606;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3))) {
                                                            current_statement_begin__ = 606;
                                                            stan::model::assign(sDRIFT, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sDRIFT");
                                                        }
                                                        current_statement_begin__ = 607;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4))) {
                                                            current_statement_begin__ = 607;
                                                            stan::model::assign(sDIFFUSIONsqrt, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sDIFFUSIONsqrt");
                                                        }
                                                        current_statement_begin__ = 608;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))) {
                                                            current_statement_begin__ = 608;
                                                            stan::model::assign(sCINT, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sCINT");
                                                        }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        current_statement_begin__ = 613;
                                        if (as_bool(logical_eq(statei,0))) {

                                            current_statement_begin__ = 614;
                                            stan::math::assign(base, add(multiply(sDRIFT,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state")),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                        }
                                        current_statement_begin__ = 616;
                                        if (as_bool(logical_gt(statei,0))) {

                                            current_statement_begin__ = 617;
                                            stan::model::assign(J, 
                                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                        divide(subtract(add(multiply(sDRIFT,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state")),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")),base),9.9999999999999995e-07), 
                                                        "assigning variable J");
                                        }
                                    }
                                    current_statement_begin__ = 622;
                                    stan::math::assign(Je, expm2(multiply(J,get_base1(dTsmall,rowi,"dTsmall",1)), pstream__));
                                    current_statement_begin__ = 625;
                                    stan::math::assign(discreteDRIFT, expm2(multiply(append_row(append_col(sDRIFT,sCINT),transpose(rep_vector(0,(nlatent + 1)))),get_base1(dTsmall,rowi,"dTsmall",1)), pstream__));
                                    current_statement_begin__ = 626;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(mdivide_left(minus(kronsum(stan::model::rvalue(J, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "J"), pstream__)),to_vector(tcrossprod(sDIFFUSIONsqrt))),nlatent,nlatent));
                                    current_statement_begin__ = 627;
                                    stan::math::assign(discreteDIFFUSION, subtract(sasymDIFFUSION,quad_form(sasymDIFFUSION,transpose(stan::model::rvalue(Je, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "Je")))));
                                    current_statement_begin__ = 628;
                                    stan::math::assign(etacov, stan::model::deep_copy(quad_form(etacov,transpose(Je))));
                                    current_statement_begin__ = 629;
                                    stan::model::assign(etacov, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(etacov, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "etacov"), discreteDIFFUSION), 
                                                "assigning variable etacov");
                                    current_statement_begin__ = 630;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                stan::model::deep_copy(stan::model::rvalue(multiply(discreteDRIFT,append_row(stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"),1.0)), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "multiply(discreteDRIFT,append_row(eta[1:nlatent],1.0))")), 
                                                "assigning variable eta");
                                }
                                }
                            }
                            current_statement_begin__ = 634;
                            if (as_bool(logical_eq(continuoustime,0))) {

                            }
                            }
                        }
                        current_statement_begin__ = 639;
                        if (as_bool((primitive_value((primitive_value(logical_eq(nlmeasurement,1)) || primitive_value(logical_gt(ntdpred,0)))) || primitive_value(logical_eq(get_base1(T0check,rowi,"T0check",1),1))))) {

                            current_statement_begin__ = 641;
                            if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {

                                current_statement_begin__ = 642;
                                if (as_bool(logical_eq(intoverpop,1))) {
                                    current_statement_begin__ = 642;
                                    stan::model::assign(sigpoints, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list())), 
                                                multiply(rawpopcovsqrt,sqrtukfadjust), 
                                                "assigning variable sigpoints");
                                }
                                current_statement_begin__ = 643;
                                stan::model::assign(sigpoints, 
                                            stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), 
                                            multiply(cholesky_decompose(sT0VAR),sqrtukfadjust), 
                                            "assigning variable sigpoints");
                            }
                            current_statement_begin__ = 646;
                            if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                                current_statement_begin__ = 646;
                                stan::math::assign(sigpoints, multiply(cholesky_decompose(makesym(etacov,verbose,1, pstream__)),sqrtukfadjust));
                            }
                            current_statement_begin__ = 649;
                            for (int statei = 2; statei <= cols(ukfstates); ++statei) {

                                current_statement_begin__ = 651;
                                stan::math::assign(state, eta);
                                current_statement_begin__ = 652;
                                if (as_bool(logical_gt(statei,(2 + nlatentpop)))) {

                                    current_statement_begin__ = 653;
                                    stan::math::assign(state, add(state, minus(stan::model::rvalue(sigpoints, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni((statei - (2 + nlatentpop))), stan::model::nil_index_list())), "sigpoints"))));
                                } else if (as_bool(logical_gt(statei,2))) {
                                    current_statement_begin__ = 655;
                                    stan::math::assign(state, add(state, stan::model::rvalue(sigpoints, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni((statei - 2)), stan::model::nil_index_list())), "sigpoints")));
                                }
                                current_statement_begin__ = 657;
                                if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {

                                    current_statement_begin__ = 659;
                                    if (as_bool(logical_eq(intoverpop,1))) {

                                        current_statement_begin__ = 660;
                                        for (int ri = 1; ri <= size(matsetup); ++ri) {

                                            current_statement_begin__ = 661;
                                            if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                                current_statement_begin__ = 662;
                                                if (as_bool((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))))) {
                                                    {
                                                    current_statement_begin__ = 663;
                                                    local_scalar_t__ newval;
                                                    (void) newval;  // dummy to suppress unused var warning

                                                    stan::math::initialize(newval, DUMMY_VAR__);
                                                    stan::math::fill(newval,DUMMY_VAR__);


                                                    current_statement_begin__ = 664;
                                                    stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                    current_statement_begin__ = 665;
                                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1))) {
                                                        current_statement_begin__ = 665;
                                                        stan::model::assign(sT0MEANS, 
                                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                    newval, 
                                                                    "assigning variable sT0MEANS");
                                                    }
                                                    current_statement_begin__ = 666;
                                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))) {
                                                        current_statement_begin__ = 666;
                                                        stan::model::assign(sT0VAR, 
                                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                    newval, 
                                                                    "assigning variable sT0VAR");
                                                    }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    current_statement_begin__ = 671;
                                    stan::model::assign(state, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"), stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS")), 
                                                "assigning variable state");
                                }
                                current_statement_begin__ = 674;
                                if (as_bool(logical_eq(intoverpop,1))) {

                                    current_statement_begin__ = 675;
                                    for (int ri = 1; ri <= size(matsetup); ++ri) {

                                        current_statement_begin__ = 676;
                                        if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                            current_statement_begin__ = 677;
                                            if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                                {
                                                current_statement_begin__ = 678;
                                                local_scalar_t__ newval;
                                                (void) newval;  // dummy to suppress unused var warning

                                                stan::math::initialize(newval, DUMMY_VAR__);
                                                stan::math::fill(newval,DUMMY_VAR__);


                                                current_statement_begin__ = 679;
                                                stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                current_statement_begin__ = 680;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                                    current_statement_begin__ = 680;
                                                    stan::model::assign(sTDPREDEFFECT, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sTDPREDEFFECT");
                                                }
                                                }
                                            }
                                        }
                                    }
                                }
                                current_statement_begin__ = 685;
                                if (as_bool(logical_gt(ntdpred,0))) {
                                    current_statement_begin__ = 685;
                                    stan::model::assign(state, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"), multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))), 
                                                "assigning variable state");
                                }
                                current_statement_begin__ = 686;
                                stan::model::assign(ukfstates, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            state, 
                                            "assigning variable ukfstates");
                                current_statement_begin__ = 687;
                                if (as_bool((primitive_value(logical_eq(statei,2)) && primitive_value(logical_eq(ukffull,1))))) {
                                    current_statement_begin__ = 687;
                                    stan::model::assign(ukfstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                state, 
                                                "assigning variable ukfstates");
                                }
                            }
                            current_statement_begin__ = 690;
                            if (as_bool(logical_eq(ukffull,1))) {

                                current_statement_begin__ = 691;
                                stan::math::assign(eta, colMeans(transpose(ukfstates), pstream__));
                                current_statement_begin__ = 692;
                                stan::math::assign(etacov, divide(cov_of_matrix(transpose(ukfstates), pstream__),asquared));
                            }
                            current_statement_begin__ = 694;
                            if (as_bool(logical_eq(ukffull,0))) {

                                current_statement_begin__ = 695;
                                stan::math::assign(eta, stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"));
                                current_statement_begin__ = 696;
                                stan::math::assign(etacov, divide(divide(tcrossprod(subtract(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(3, (nlatentpop + 2)), stan::model::nil_index_list())), "ukfstates"),rep_matrix(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"),nlatentpop))),asquared),(nlatentpop + 0.5)));
                            }
                        }
                    }
                    current_statement_begin__ = 702;
                    if (as_bool(logical_eq(savescores,1))) {
                        current_statement_begin__ = 702;
                        stan::model::assign(kout, 
                                    stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(((nmanifest * 4) + 1), ((nmanifest * 4) + nlatentpop)), stan::model::nil_index_list())), 
                                    eta, 
                                    "assigning variable kout");
                    }
                    current_statement_begin__ = 703;
                    if (as_bool(logical_gt(verbose,1))) {
                        current_statement_begin__ = 703;
                        if (pstream__) {
                            stan_print(pstream__,"etaprior = ");
                            stan_print(pstream__,eta);
                            stan_print(pstream__," etapriorcov = ");
                            stan_print(pstream__,etacov);
                            *pstream__ << std::endl;
                        }
                    }
                    current_statement_begin__ = 705;
                    if (as_bool((primitive_value(logical_eq(intoverstates,0)) && primitive_value(logical_eq(nldynamics,0))))) {

                        current_statement_begin__ = 706;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {
                            current_statement_begin__ = 706;
                            stan::math::assign(eta, add(eta, multiply(cholesky_decompose(sT0VAR),stan::model::rvalue(etaupdbasestates, stan::model::cons_list(stan::model::index_min_max((1 + ((rowi - 1) * nlatent)), (rowi * nlatent)), stan::model::nil_index_list()), "etaupdbasestates"))));
                        }
                        current_statement_begin__ = 707;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                            current_statement_begin__ = 707;
                            stan::math::assign(eta, add(eta, multiply(discreteDIFFUSION,stan::model::rvalue(etaupdbasestates, stan::model::cons_list(stan::model::index_min_max((1 + ((rowi - 1) * nlatent)), (rowi * nlatent)), stan::model::nil_index_list()), "etaupdbasestates"))));
                        }
                    }
                    current_statement_begin__ = 710;
                    if (as_bool(logical_gt(get_base1(nobs_y,rowi,"nobs_y",1),0))) {
                        {
                        current_statement_begin__ = 712;
                        validate_non_negative_index("o", "get_base1(nobs_y,rowi,\"nobs_y\",1)", get_base1(nobs_y,rowi,"nobs_y",1));
                        vector<int> o(get_base1(nobs_y,rowi,"nobs_y",1), 0);
                        stan::math::fill(o, std::numeric_limits<int>::min());
                        stan::math::assign(o,stan::model::rvalue(whichobs_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nobs_y,rowi,"nobs_y",1)), stan::model::nil_index_list())), "whichobs_y"));
                        current_statement_begin__ = 713;
                        validate_non_negative_index("o1", "get_base1(nbinary_y,rowi,\"nbinary_y\",1)", get_base1(nbinary_y,rowi,"nbinary_y",1));
                        vector<int> o1(get_base1(nbinary_y,rowi,"nbinary_y",1), 0);
                        stan::math::fill(o1, std::numeric_limits<int>::min());
                        stan::math::assign(o1,stan::model::rvalue(whichbinary_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nbinary_y,rowi,"nbinary_y",1)), stan::model::nil_index_list())), "whichbinary_y"));
                        current_statement_begin__ = 714;
                        validate_non_negative_index("o0", "get_base1(ncont_y,rowi,\"ncont_y\",1)", get_base1(ncont_y,rowi,"ncont_y",1));
                        vector<int> o0(get_base1(ncont_y,rowi,"ncont_y",1), 0);
                        stan::math::fill(o0, std::numeric_limits<int>::min());
                        stan::math::assign(o0,stan::model::rvalue(whichcont_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(ncont_y,rowi,"ncont_y",1)), stan::model::nil_index_list())), "whichcont_y"));


                        current_statement_begin__ = 716;
                        if (as_bool(logical_eq(nlmeasurement,0))) {

                            current_statement_begin__ = 719;
                            if (as_bool(logical_eq(intoverstates,1))) {

                                current_statement_begin__ = 720;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"))), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 721;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                                    current_statement_begin__ = 721;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), 
                                                to_vector(inv_logit(to_array_1d(add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta")))))), 
                                                "assigning variable ypred");
                                }
                                current_statement_begin__ = 722;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(quad_form(stan::model::rvalue(etacov, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "etacov"),transpose(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"))),stan::model::rvalue(sMANIFESTVAR, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "sMANIFESTVAR")), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 723;
                                for (int wi = 1; wi <= nmanifest; ++wi) {

                                    current_statement_begin__ = 724;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),1)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 724;
                                        stan::model::assign(ypredcov, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), "ypredcov") + stan::math::fabs(((get_base1(ypred,wi,"ypred",1) - 1) * get_base1(ypred,wi,"ypred",1)))), 
                                                    "assigning variable ypredcov");
                                    }
                                    current_statement_begin__ = 725;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),2)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 725;
                                        stan::model::assign(ypredcov, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), "ypredcov") + square(stan::math::fabs((get_base1(ypred,wi,"ypred",1) - stan::math::round(get_base1(ypred,wi,"ypred",1)))))), 
                                                    "assigning variable ypredcov");
                                    }
                                }
                                current_statement_begin__ = 727;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(multiply(etacov,append_row(transpose(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA")),stan::model::rvalue(rep_matrix(0,(nlatentpop - nlatent),nmanifest), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "rep_matrix(0,(nlatentpop - nlatent),nmanifest)"))),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                                current_statement_begin__ = 728;
                                stan::math::assign(etacov, add(etacov, multiply(multiply(minus(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K")),append_col(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(rep_matrix(0,nmanifest,(nlatentpop - nlatent)), stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "rep_matrix(0,nmanifest,(nlatentpop - nlatent))"))),etacov)));
                            }
                            current_statement_begin__ = 730;
                            if (as_bool(logical_eq(intoverstates,0))) {

                                current_statement_begin__ = 731;
                                if (as_bool(logical_gt(get_base1(ncont_y,rowi,"ncont_y",1),0))) {

                                    current_statement_begin__ = 732;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"))), 
                                                "assigning variable ypred");
                                    current_statement_begin__ = 733;
                                    stan::model::assign(ypredcov_sqrt, 
                                                stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                                stan::math::sqrt(stan::model::rvalue(sMANIFESTVAR, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "sMANIFESTVAR")), 
                                                "assigning variable ypredcov_sqrt");
                                }
                                current_statement_begin__ = 735;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                                    current_statement_begin__ = 735;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), 
                                                to_vector(inv_logit(to_array_1d(add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta")))))), 
                                                "assigning variable ypred");
                                }
                            }
                        }
                        current_statement_begin__ = 740;
                        if (as_bool(logical_eq(nlmeasurement,1))) {
                            {
                            current_statement_begin__ = 741;
                            validate_non_negative_index("merrorstates", "nmanifest", nmanifest);
                            validate_non_negative_index("merrorstates", "cols(ukfmeasures)", cols(ukfmeasures));
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  merrorstates(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(cols(ukfmeasures)));
                            (void) merrorstates;  // dummy to suppress unused var warning

                            stan::math::initialize(merrorstates, DUMMY_VAR__);
                            stan::math::fill(merrorstates,DUMMY_VAR__);


                            current_statement_begin__ = 743;
                            for (int statei = 2; statei <= cols(ukfmeasures); ++statei) {

                                current_statement_begin__ = 744;
                                stan::math::assign(state, stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "ukfstates"));
                                current_statement_begin__ = 746;
                                if (as_bool(logical_eq(intoverpop,1))) {

                                    current_statement_begin__ = 747;
                                    for (int ri = 1; ri <= size(matsetup); ++ri) {

                                        current_statement_begin__ = 748;
                                        if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                            current_statement_begin__ = 749;
                                            if (as_bool((primitive_value((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5)))) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))))) {
                                                {
                                                current_statement_begin__ = 750;
                                                local_scalar_t__ newval;
                                                (void) newval;  // dummy to suppress unused var warning

                                                stan::math::initialize(newval, DUMMY_VAR__);
                                                stan::math::fill(newval,DUMMY_VAR__);


                                                current_statement_begin__ = 751;
                                                stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                current_statement_begin__ = 752;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2))) {
                                                    current_statement_begin__ = 752;
                                                    stan::model::assign(sLAMBDA, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sLAMBDA");
                                                }
                                                current_statement_begin__ = 753;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5))) {
                                                    current_statement_begin__ = 753;
                                                    stan::model::assign(sMANIFESTVAR, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sMANIFESTVAR");
                                                }
                                                current_statement_begin__ = 754;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))) {
                                                    current_statement_begin__ = 754;
                                                    stan::model::assign(sMANIFESTMEANS, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sMANIFESTMEANS");
                                                }
                                                }
                                            }
                                        }
                                    }
                                }
                                current_statement_begin__ = 761;
                                stan::model::assign(ukfmeasures, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(sLAMBDA,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"))), 
                                            "assigning variable ukfmeasures");
                                current_statement_begin__ = 762;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {

                                    current_statement_begin__ = 763;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(to_vector(inv_logit(to_array_1d(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "ukfmeasures"))))), 
                                                "assigning variable ukfmeasures");
                                }
                                current_statement_begin__ = 766;
                                stan::model::assign(merrorstates, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            stan::math::sqrt(diagonal(sMANIFESTVAR)), 
                                            "assigning variable merrorstates");
                                current_statement_begin__ = 767;
                                for (int wi = 1; wi <= nmanifest; ++wi) {

                                    current_statement_begin__ = 768;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),1)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 768;
                                        stan::model::assign(merrorstates, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "merrorstates") + stan::math::fabs(((get_base1(ukfmeasures,wi,statei,"ukfmeasures",1) - 1) * get_base1(ukfmeasures,wi,statei,"ukfmeasures",1)))), 
                                                    "assigning variable merrorstates");
                                    }
                                    current_statement_begin__ = 769;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),2)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 769;
                                        stan::model::assign(merrorstates, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "merrorstates") + square(stan::math::fabs((get_base1(ukfmeasures,wi,statei,"ukfmeasures",1) - stan::math::round(get_base1(ukfmeasures,wi,statei,"ukfmeasures",1)))))), 
                                                    "assigning variable merrorstates");
                                    }
                                }
                                current_statement_begin__ = 772;
                                if (as_bool((primitive_value(logical_eq(statei,2)) && primitive_value(logical_eq(ukffull,1))))) {

                                    current_statement_begin__ = 773;
                                    stan::model::assign(merrorstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "merrorstates")), 
                                                "assigning variable merrorstates");
                                    current_statement_begin__ = 774;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures")), 
                                                "assigning variable ukfmeasures");
                                }
                            }
                            current_statement_begin__ = 777;
                            if (as_bool(logical_eq(ukffull,1))) {

                                current_statement_begin__ = 778;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            colMeans(transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 779;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(divide(cov_of_matrix(transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__),asquared),diag_matrix(colMeans(transpose(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "merrorstates")), pstream__))), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 780;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(divide(crosscov(transpose(ukfstates),transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__),asquared),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                            }
                            current_statement_begin__ = 782;
                            if (as_bool(logical_eq(ukffull,0))) {

                                current_statement_begin__ = 783;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures"), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 784;
                                for (int ci = 3; ci <= cols(ukfmeasures); ++ci) {
                                    current_statement_begin__ = 784;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), "ukfmeasures"), minus(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures"))), 
                                                "assigning variable ukfmeasures");
                                }
                                current_statement_begin__ = 785;
                                for (int ci = 3; ci <= cols(ukfstates); ++ci) {
                                    current_statement_begin__ = 785;
                                    stan::model::assign(ukfstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), "ukfstates"), minus(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"))), 
                                                "assigning variable ukfstates");
                                }
                                current_statement_begin__ = 786;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(divide(divide(tcrossprod(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_min_max(3, (nlatentpop + 2)), stan::model::nil_index_list())), "ukfmeasures")),asquared),(nlatentpop + 0.5)),diag_matrix(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "merrorstates"))), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 787;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(divide(divide(multiply(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(3, cols(ukfstates)), stan::model::nil_index_list())), "ukfstates"),transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_min_max(3, cols(ukfmeasures)), stan::model::nil_index_list())), "ukfmeasures"))),asquared),(nlatentpop + 0.5)),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                            }
                            current_statement_begin__ = 789;
                            stan::math::assign(etacov, add(etacov, minus(quad_form(stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov"),transpose(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K"))))));
                            }
                        }
                        current_statement_begin__ = 793;
                        stan::model::assign(err, 
                                    stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                    subtract(stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "Y"),stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "ypred")), 
                                    "assigning variable err");
                        current_statement_begin__ = 795;
                        if (as_bool(logical_eq(savescores,1))) {
                            {
                            current_statement_begin__ = 796;
                            validate_non_negative_index("tmpindex", "get_base1(nobs_y,rowi,\"nobs_y\",1)", get_base1(nobs_y,rowi,"nobs_y",1));
                            vector<int> tmpindex(get_base1(nobs_y,rowi,"nobs_y",1), 0);
                            stan::math::fill(tmpindex, std::numeric_limits<int>::min());
                            stan::math::assign(tmpindex,o);


                            current_statement_begin__ = 797;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 797;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + (nmanifest * 2)), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 798;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "err"), 
                                        "assigning variable kout");
                            current_statement_begin__ = 799;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 799;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + nmanifest), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 800;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "ypred"), 
                                        "assigning variable kout");
                            }
                        }
                        current_statement_begin__ = 802;
                        if (as_bool(logical_eq(intoverstates,1))) {
                            current_statement_begin__ = 802;
                            stan::math::assign(eta, add(eta, multiply(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K"),stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "err"))));
                        }
                        current_statement_begin__ = 804;
                        if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                            current_statement_begin__ = 804;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), 
                                        add(elt_multiply(stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "Y"),stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), "ypred")),elt_multiply(subtract(1,stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "Y")),subtract(1,stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), "ypred")))), 
                                        "assigning variable kout");
                        }
                        current_statement_begin__ = 806;
                        if (as_bool(logical_gt(verbose,1))) {

                            current_statement_begin__ = 807;
                            if (pstream__) {
                                stan_print(pstream__,"rowi ");
                                stan_print(pstream__,rowi);
                                stan_print(pstream__,"  si ");
                                stan_print(pstream__,si);
                                stan_print(pstream__,"  eta ");
                                stan_print(pstream__,eta);
                                stan_print(pstream__,"  etacov ");
                                stan_print(pstream__,etacov);
                                stan_print(pstream__,"  ypred ");
                                stan_print(pstream__,ypred);
                                stan_print(pstream__,"  ypredcov ");
                                stan_print(pstream__,ypredcov);
                                stan_print(pstream__,"  K ");
                                stan_print(pstream__,K);
                                stan_print(pstream__,"  sDRIFT ");
                                stan_print(pstream__,sDRIFT);
                                stan_print(pstream__," sDIFFUSION ");
                                stan_print(pstream__,sDIFFUSION);
                                stan_print(pstream__," sCINT ");
                                stan_print(pstream__,sCINT);
                                stan_print(pstream__,"  sMANIFESTVAR ");
                                stan_print(pstream__,diagonal(sMANIFESTVAR));
                                stan_print(pstream__,"  sMANIFESTMEANS ");
                                stan_print(pstream__,sMANIFESTMEANS);
                                stan_print(pstream__,"  sT0VAR");
                                stan_print(pstream__,sT0VAR);
                                stan_print(pstream__," sT0MEANS ");
                                stan_print(pstream__,sT0MEANS);
                                stan_print(pstream__,"discreteDRIFT ");
                                stan_print(pstream__,discreteDRIFT);
                                stan_print(pstream__,"  discreteDIFFUSION ");
                                stan_print(pstream__,discreteDIFFUSION);
                                stan_print(pstream__,"  sasymDIFFUSION ");
                                stan_print(pstream__,sasymDIFFUSION);
                                stan_print(pstream__,"  rawpopsd ");
                                stan_print(pstream__,rawpopsd);
                                stan_print(pstream__,"  rawpopsdbase ");
                                stan_print(pstream__,rawpopsdbase);
                                stan_print(pstream__,"  rawpopmeans ");
                                stan_print(pstream__,rawpopmeans);
                                *pstream__ << std::endl;
                            }
                        }
                        current_statement_begin__ = 814;
                        if (as_bool(logical_gt(verbose,2))) {
                            current_statement_begin__ = 814;
                            if (pstream__) {
                                stan_print(pstream__,"ukfstates ");
                                stan_print(pstream__,ukfstates);
                                stan_print(pstream__,"  ukfmeasures ");
                                stan_print(pstream__,ukfmeasures);
                                *pstream__ << std::endl;
                            }
                        }
                        current_statement_begin__ = 816;
                        if (as_bool(logical_gt(size(o0),0))) {
                            {
                            current_statement_begin__ = 817;
                            validate_non_negative_index("tmpindex", "get_base1(ncont_y,rowi,\"ncont_y\",1)", get_base1(ncont_y,rowi,"ncont_y",1));
                            vector<int> tmpindex(get_base1(ncont_y,rowi,"ncont_y",1), 0);
                            stan::math::fill(tmpindex, std::numeric_limits<int>::min());
                            stan::math::assign(tmpindex,o0);


                            current_statement_begin__ = 818;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 818;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + nmanifest), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 819;
                            if (as_bool(logical_eq(intoverstates,1))) {
                                current_statement_begin__ = 819;
                                stan::model::assign(ypredcov_sqrt, 
                                            stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                            cholesky_decompose(makesym(stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov"),verbose,1, pstream__)), 
                                            "assigning variable ypredcov_sqrt");
                            }
                            current_statement_begin__ = 820;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                        mdivide_left_tri_low(stan::model::rvalue(ypredcov_sqrt, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov_sqrt"),stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list()), "err")), 
                                        "assigning variable kout");
                            current_statement_begin__ = 821;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::math::log(diagonal(stan::model::rvalue(ypredcov_sqrt, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov_sqrt"))), 
                                        "assigning variable kout");
                            }
                        }
                        }
                    }
                    current_statement_begin__ = 825;
                    if (as_bool(logical_eq(savescores,1))) {
                        current_statement_begin__ = 825;
                        stan::model::assign(kout, 
                                    stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max((((nmanifest * 4) + nlatentpop) + 1), (((nmanifest * 4) + nlatentpop) + nlatentpop)), stan::model::nil_index_list())), 
                                    eta, 
                                    "assigning variable kout");
                    }
                    }
                }
            }
            current_statement_begin__ = 828;
            if (as_bool(logical_eq(dokalman,1))) {

                current_statement_begin__ = 829;
                if (as_bool(logical_gt(sum(nbinary_y),0))) {
                    {
                    current_statement_begin__ = 830;
                    validate_non_negative_index("binaryll", "sum(nbinary_y)", sum(nbinary_y));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  binaryll(static_cast<Eigen::VectorXd::Index>(sum(nbinary_y)));
                    (void) binaryll;  // dummy to suppress unused var warning

                    stan::math::initialize(binaryll, DUMMY_VAR__);
                    stan::math::fill(binaryll,DUMMY_VAR__);


                    current_statement_begin__ = 831;
                    stan::math::assign(counter, 1);
                    current_statement_begin__ = 832;
                    for (int ri = 1; ri <= ndatapoints; ++ri) {

                        current_statement_begin__ = 833;
                        if (as_bool(logical_eq(get_base1(dokalmanrows,ri,"dokalmanrows",1),1))) {
                            {
                            current_statement_begin__ = 834;
                            validate_non_negative_index("o1", "get_base1(nbinary_y,ri,\"nbinary_y\",1)", get_base1(nbinary_y,ri,"nbinary_y",1));
                            vector<int> o1(get_base1(nbinary_y,ri,"nbinary_y",1), 0);
                            stan::math::fill(o1, std::numeric_limits<int>::min());
                            stan::math::assign(o1,stan::model::rvalue(whichbinary_y, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nbinary_y,ri,"nbinary_y",1)), stan::model::nil_index_list())), "whichbinary_y"));


                            current_statement_begin__ = 835;
                            stan::model::assign(binaryll, 
                                        stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(nbinary_y,ri,"nbinary_y",1)) - 1)), stan::model::nil_index_list()), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable binaryll");
                            current_statement_begin__ = 836;
                            stan::math::assign(counter, (counter + get_base1(nbinary_y,ri,"nbinary_y",1)));
                            }
                        }
                    }
                    current_statement_begin__ = 839;
                    stan::math::assign(ll, (ll + sum(stan::math::log(stan::model::rvalue(binaryll, stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list()), "binaryll")))));
                    }
                }
                current_statement_begin__ = 842;
                if (as_bool(logical_gt(sum(ncont_y),0))) {
                    {
                    current_statement_begin__ = 843;
                    validate_non_negative_index("errtrans", "sum(ncont_y)", sum(ncont_y));
                    validate_non_negative_index("errtrans", "2", 2);
                    vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > errtrans(2, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(sum(ncont_y)))));
                    stan::math::initialize(errtrans, DUMMY_VAR__);
                    stan::math::fill(errtrans,DUMMY_VAR__);


                    current_statement_begin__ = 844;
                    stan::math::assign(counter, 1);
                    current_statement_begin__ = 845;
                    for (int ri = 1; ri <= ndatapoints; ++ri) {

                        current_statement_begin__ = 846;
                        if (as_bool(logical_eq(get_base1(dokalmanrows,ri,"dokalmanrows",1),1))) {
                            {
                            current_statement_begin__ = 847;
                            validate_non_negative_index("o0", "get_base1(ncont_y,ri,\"ncont_y\",1)", get_base1(ncont_y,ri,"ncont_y",1));
                            vector<int> o0(get_base1(ncont_y,ri,"ncont_y",1), 0);
                            stan::math::fill(o0, std::numeric_limits<int>::min());
                            stan::math::assign(o0,stan::model::rvalue(whichcont_y, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_min_max(1, get_base1(ncont_y,ri,"ncont_y",1)), stan::model::nil_index_list())), "whichcont_y"));


                            current_statement_begin__ = 848;
                            stan::model::assign(errtrans, 
                                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(ncont_y,ri,"ncont_y",1)) - 1)), stan::model::nil_index_list())), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable errtrans");
                            current_statement_begin__ = 849;
                            for (int oi = 1; oi <= get_base1(ncont_y,ri,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 849;
                                stan::model::assign(o0, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(o0, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "o0") + nmanifest), 
                                            "assigning variable o0");
                            }
                            current_statement_begin__ = 850;
                            stan::model::assign(errtrans, 
                                        stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(ncont_y,ri,"ncont_y",1)) - 1)), stan::model::nil_index_list())), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable errtrans");
                            current_statement_begin__ = 851;
                            stan::math::assign(counter, (counter + get_base1(ncont_y,ri,"ncont_y",1)));
                            }
                        }
                    }
                    current_statement_begin__ = 854;
                    stan::math::assign(ll, (ll + (normal_log(stan::model::rvalue(errtrans, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list())), "errtrans"),0,1) - sum(stan::model::rvalue(errtrans, stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list())), "errtrans")))));
                    }
                }
                current_statement_begin__ = 856;
                if (as_bool(savescores)) {
                    current_statement_begin__ = 856;
                    stan::math::assign(kalman, kout);
                }
            }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < nindvarying; ++i0__) {
                if (stan::math::is_uninitialized(rawpopsd(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: rawpopsd" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < nindvarying; ++i0__) {
                for (int i1__ = 0; i1__ < nindvarying; ++i1__) {
                    if (stan::math::is_uninitialized(rawpopcovsqrt(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: rawpopcovsqrt" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            if (stan::math::is_uninitialized(ll)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: ll";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < (savescores ? ndatapoints : 0 ); ++i0__) {
                for (int i1__ = 0; i1__ < ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )); ++i1__) {
                    if (stan::math::is_uninitialized(kalman[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: kalman" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(T0MEANS[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: T0MEANS" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(LAMBDA[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: LAMBDA" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(DRIFT[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: DRIFT" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(DIFFUSION[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: DIFFUSION" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(MANIFESTVAR[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: MANIFESTVAR" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(MANIFESTMEANS[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: MANIFESTMEANS" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(CINTsubindex,nsubjects,"CINTsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(CINT[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: CINT" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(T0VAR[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: T0VAR" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++i1__) {
                    for (int i2__ = 0; i2__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++i2__) {
                        if (stan::math::is_uninitialized(TDPREDEFFECT[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: TDPREDEFFECT" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < nlatent; ++i1__) {
                    for (int i2__ = 0; i2__ < nlatent; ++i2__) {
                        if (stan::math::is_uninitialized(asymDIFFUSION[i0__](i1__,i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: asymDIFFUSION" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1); ++i0__) {
                for (int i1__ = 0; i1__ < (nt0meansstationary ? nlatent : 0 ); ++i1__) {
                    if (stan::math::is_uninitialized(asymCINT[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: asymCINT" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_T0MEANS(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_T0MEANS" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_LAMBDA(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_LAMBDA" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_DRIFT(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_DRIFT" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_DIFFUSION(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_DIFFUSION" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_MANIFESTVAR(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_MANIFESTVAR" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_MANIFESTMEANS(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_MANIFESTMEANS" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_CINT(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_CINT" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_T0VAR(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_T0VAR" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++i0__) {
                for (int i1__ = 0; i1__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++i1__) {
                    if (stan::math::is_uninitialized(pop_TDPREDEFFECT(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_TDPREDEFFECT" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < nlatent; ++i0__) {
                for (int i1__ = 0; i1__ < nlatent; ++i1__) {
                    if (stan::math::is_uninitialized(pop_asymDIFFUSION(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: pop_asymDIFFUSION" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < (nt0meansstationary ? nlatent : 0 ); ++i0__) {
                if (stan::math::is_uninitialized(pop_asymCINT(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: pop_asymCINT" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < (ntipred ? nsubjects : 0 ); ++i0__) {
                for (int i1__ = 0; i1__ < (ntipred ? ntipred : 0 ); ++i1__) {
                    if (stan::math::is_uninitialized(tipreds(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: tipreds" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < nparams; ++i0__) {
                for (int i1__ = 0; i1__ < ntipred; ++i1__) {
                    if (stan::math::is_uninitialized(TIPREDEFFECT(i0__,i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: TIPREDEFFECT" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 274;
            current_statement_begin__ = 275;
            current_statement_begin__ = 276;
            current_statement_begin__ = 277;
            current_statement_begin__ = 278;
            current_statement_begin__ = 279;
            current_statement_begin__ = 280;
            current_statement_begin__ = 281;
            current_statement_begin__ = 282;
            current_statement_begin__ = 283;
            current_statement_begin__ = 284;
            current_statement_begin__ = 285;
            current_statement_begin__ = 286;
            current_statement_begin__ = 288;
            current_statement_begin__ = 289;
            current_statement_begin__ = 292;
            current_statement_begin__ = 293;
            current_statement_begin__ = 294;
            current_statement_begin__ = 295;
            current_statement_begin__ = 296;
            current_statement_begin__ = 297;
            current_statement_begin__ = 298;
            current_statement_begin__ = 299;
            current_statement_begin__ = 300;
            current_statement_begin__ = 302;
            current_statement_begin__ = 303;
            current_statement_begin__ = 307;
            current_statement_begin__ = 308;

            // model body

            current_statement_begin__ = 864;
            if (as_bool((primitive_value(logical_eq(intoverpop,0)) && primitive_value(logical_eq(fixedsubpars,1))))) {
                current_statement_begin__ = 864;
                lp_accum__.add(multi_normal_cholesky_log<propto__>(fixedindparams, rep_vector(0,nindvarying), IIindvar));
            }
            current_statement_begin__ = 866;
            if (as_bool(logical_eq(nopriors,0))) {
                {
                current_statement_begin__ = 867;
                local_scalar_t__ temptarget;
                (void) temptarget;  // dummy to suppress unused var warning

                stan::math::initialize(temptarget, DUMMY_VAR__);
                stan::math::fill(temptarget,DUMMY_VAR__);
                stan::math::assign(temptarget,0.0);


                current_statement_begin__ = 868;
                stan::math::assign(temptarget, (temptarget + normal_log(rawpopmeans,0,1)));
                current_statement_begin__ = 870;
                if (as_bool(logical_gt(ntipred,0))) {

                    current_statement_begin__ = 871;
                    stan::math::assign(temptarget, (temptarget + normal_log(tipredeffectparams,0,tipredeffectscale)));
                    current_statement_begin__ = 872;
                    stan::math::assign(temptarget, (temptarget + normal_log(tipredsimputed,0,tipredsimputedscale)));
                }
                current_statement_begin__ = 875;
                if (as_bool(logical_gt(nindvarying,0))) {

                    current_statement_begin__ = 876;
                    if (as_bool(logical_gt(nindvarying,1))) {
                        current_statement_begin__ = 876;
                        stan::math::assign(temptarget, (temptarget + normal_log(sqrtpcov,0,1)));
                    }
                    current_statement_begin__ = 877;
                    if (as_bool((primitive_value(logical_eq(intoverpop,0)) && primitive_value(logical_eq(fixedsubpars,0))))) {
                        current_statement_begin__ = 877;
                        stan::math::assign(temptarget, (temptarget + multi_normal_cholesky_log(baseindparams,rep_vector(0,nindvarying),IIindvar)));
                    }
                    current_statement_begin__ = 878;
                    stan::math::assign(temptarget, (temptarget + normal_log(rawpopsdbase,0,1)));
                }
                current_statement_begin__ = 880;
                lp_accum__.add((temptarget * dokalmanpriormodifier));
                }
            }
            current_statement_begin__ = 883;
            if (as_bool(logical_eq(intoverstates,0))) {
                current_statement_begin__ = 883;
                lp_accum__.add(normal_log<propto__>(etaupdbasestates, 0, 1));
            }
            current_statement_begin__ = 885;
            lp_accum__.add(ll);
            current_statement_begin__ = 886;
            if (as_bool(logical_gt(verbose,0))) {
                current_statement_begin__ = 886;
                if (pstream__) {
                    stan_print(pstream__,"lp = ");
                    stan_print(pstream__,get_lp(lp__, lp_accum__));
                    *pstream__ << std::endl;
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("rawpopmeans");
        names__.push_back("rawpopsdbase");
        names__.push_back("sqrtpcov");
        names__.push_back("baseindparams");
        names__.push_back("tipredeffectparams");
        names__.push_back("tipredsimputed");
        names__.push_back("etaupdbasestates");
        names__.push_back("rawpopsd");
        names__.push_back("rawpopcovsqrt");
        names__.push_back("ll");
        names__.push_back("kalman");
        names__.push_back("T0MEANS");
        names__.push_back("LAMBDA");
        names__.push_back("DRIFT");
        names__.push_back("DIFFUSION");
        names__.push_back("MANIFESTVAR");
        names__.push_back("MANIFESTMEANS");
        names__.push_back("CINT");
        names__.push_back("T0VAR");
        names__.push_back("TDPREDEFFECT");
        names__.push_back("asymDIFFUSION");
        names__.push_back("asymCINT");
        names__.push_back("pop_T0MEANS");
        names__.push_back("pop_LAMBDA");
        names__.push_back("pop_DRIFT");
        names__.push_back("pop_DIFFUSION");
        names__.push_back("pop_MANIFESTVAR");
        names__.push_back("pop_MANIFESTMEANS");
        names__.push_back("pop_CINT");
        names__.push_back("pop_T0VAR");
        names__.push_back("pop_TDPREDEFFECT");
        names__.push_back("pop_asymDIFFUSION");
        names__.push_back("pop_asymCINT");
        names__.push_back("tipreds");
        names__.push_back("TIPREDEFFECT");
        names__.push_back("popmeans");
        names__.push_back("popsd");
        names__.push_back("rawpopcov");
        names__.push_back("rawpopcorr");
        names__.push_back("linearTIPREDEFFECT");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(nparams);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvarying);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvaryingoffdiagonals);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ));
        dims__.push_back((fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(ntipredeffects);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nmissingtipreds);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((intoverstates ? 0 : (nlatent * ndatapoints) ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvarying);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvarying);
        dims__.push_back(nindvarying);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((savescores ? ndatapoints : 0 ));
        dims__.push_back(((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(CINTsubindex,nsubjects,"CINTsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1));
        dims__.push_back(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1));
        dims__.push_back(nlatent);
        dims__.push_back(nlatent);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1));
        dims__.push_back((nt0meansstationary ? nlatent : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
        dims__.push_back(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nlatent);
        dims__.push_back(nlatent);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((nt0meansstationary ? nlatent : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((ntipred ? nsubjects : 0 ));
        dims__.push_back((ntipred ? ntipred : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nparams);
        dims__.push_back(ntipred);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nparams);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nparams);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvarying);
        dims__.push_back(nindvarying);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nindvarying);
        dims__.push_back(nindvarying);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(nparams);
        dims__.push_back(ntipred);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;

        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);
        static const char* function__ = "model_ctsm_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d rawpopmeans = in__.vector_constrain(nparams);
        vector_d rawpopsdbase = in__.vector_constrain(nindvarying);
        vector_d sqrtpcov = in__.vector_constrain(nindvaryingoffdiagonals);
        vector<vector_d> baseindparams;
        size_t dim_baseindparams_0__ = (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) );
        for (size_t k_0__ = 0; k_0__ < dim_baseindparams_0__; ++k_0__) {
            baseindparams.push_back(in__.vector_constrain((fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) )));
        }
        vector_d tipredeffectparams = in__.vector_constrain(ntipredeffects);
        vector_d tipredsimputed = in__.vector_constrain(nmissingtipreds);
        vector_d etaupdbasestates = in__.vector_constrain((intoverstates ? 0 : (nlatent * ndatapoints) ));
            for (int k_0__ = 0; k_0__ < nparams; ++k_0__) {
            vars__.push_back(rawpopmeans[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < nindvarying; ++k_0__) {
            vars__.push_back(rawpopsdbase[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < nindvaryingoffdiagonals; ++k_0__) {
            vars__.push_back(sqrtpcov[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ); ++k_1__) {
                for (int k_0__ = 0; k_0__ < (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ); ++k_0__) {
                vars__.push_back(baseindparams[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < ntipredeffects; ++k_0__) {
            vars__.push_back(tipredeffectparams[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < nmissingtipreds; ++k_0__) {
            vars__.push_back(tipredsimputed[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < (intoverstates ? 0 : (nlatent * ndatapoints) ); ++k_0__) {
            vars__.push_back(etaupdbasestates[k_0__]);
            }

        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 274;
            validate_non_negative_index("rawpopsd", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawpopsd(static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopsd;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopsd, DUMMY_VAR__);
            stan::math::fill(rawpopsd,DUMMY_VAR__);
            current_statement_begin__ = 275;
            validate_non_negative_index("rawpopcovsqrt", "nindvarying", nindvarying);
            validate_non_negative_index("rawpopcovsqrt", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  rawpopcovsqrt(static_cast<Eigen::VectorXd::Index>(nindvarying),static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopcovsqrt;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopcovsqrt, DUMMY_VAR__);
            stan::math::fill(rawpopcovsqrt,DUMMY_VAR__);
            current_statement_begin__ = 276;
            local_scalar_t__ ll;
            (void) ll;  // dummy to suppress unused var warning

            stan::math::initialize(ll, DUMMY_VAR__);
            stan::math::fill(ll,DUMMY_VAR__);
            current_statement_begin__ = 277;
            validate_non_negative_index("kalman", "((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))", ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )));
            validate_non_negative_index("kalman", "(savescores ? ndatapoints : 0 )", (savescores ? ndatapoints : 0 ));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > kalman((savescores ? ndatapoints : 0 ), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))))));
            stan::math::initialize(kalman, DUMMY_VAR__);
            stan::math::fill(kalman,DUMMY_VAR__);
            current_statement_begin__ = 278;
            validate_non_negative_index("T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("T0MEANS", "get_base1(T0MEANSsubindex,nsubjects,\"T0MEANSsubindex\",1)", get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > T0MEANS(get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(T0MEANS, DUMMY_VAR__);
            stan::math::fill(T0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 279;
            validate_non_negative_index("LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("LAMBDA", "get_base1(LAMBDAsubindex,nsubjects,\"LAMBDAsubindex\",1)", get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > LAMBDA(get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(LAMBDA, DUMMY_VAR__);
            stan::math::fill(LAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 280;
            validate_non_negative_index("DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("DRIFT", "get_base1(DRIFTsubindex,nsubjects,\"DRIFTsubindex\",1)", get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > DRIFT(get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(DRIFT, DUMMY_VAR__);
            stan::math::fill(DRIFT,DUMMY_VAR__);
            current_statement_begin__ = 281;
            validate_non_negative_index("DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("DIFFUSION", "get_base1(DIFFUSIONsubindex,nsubjects,\"DIFFUSIONsubindex\",1)", get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > DIFFUSION(get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(DIFFUSION, DUMMY_VAR__);
            stan::math::fill(DIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 282;
            validate_non_negative_index("MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("MANIFESTVAR", "get_base1(MANIFESTVARsubindex,nsubjects,\"MANIFESTVARsubindex\",1)", get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > MANIFESTVAR(get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(MANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(MANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 283;
            validate_non_negative_index("MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("MANIFESTMEANS", "get_base1(MANIFESTMEANSsubindex,nsubjects,\"MANIFESTMEANSsubindex\",1)", get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > MANIFESTMEANS(get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(MANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(MANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 284;
            validate_non_negative_index("CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("CINT", "get_base1(CINTsubindex,nsubjects,\"CINTsubindex\",1)", get_base1(CINTsubindex,nsubjects,"CINTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > CINT(get_base1(CINTsubindex,nsubjects,"CINTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(CINT, DUMMY_VAR__);
            stan::math::fill(CINT,DUMMY_VAR__);
            current_statement_begin__ = 285;
            validate_non_negative_index("T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("T0VAR", "get_base1(T0VARsubindex,nsubjects,\"T0VARsubindex\",1)", get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > T0VAR(get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(T0VAR, DUMMY_VAR__);
            stan::math::fill(T0VAR,DUMMY_VAR__);
            current_statement_begin__ = 286;
            validate_non_negative_index("TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            validate_non_negative_index("TDPREDEFFECT", "get_base1(TDPREDEFFECTsubindex,nsubjects,\"TDPREDEFFECTsubindex\",1)", get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > TDPREDEFFECT(get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)))));
            stan::math::initialize(TDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(TDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 288;
            validate_non_negative_index("asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("asymDIFFUSION", "get_base1(asymDIFFUSIONsubindex,nsubjects,\"asymDIFFUSIONsubindex\",1)", get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > asymDIFFUSION(get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent))));
            stan::math::initialize(asymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(asymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 289;
            validate_non_negative_index("asymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            validate_non_negative_index("asymCINT", "get_base1(asymCINTsubindex,nsubjects,\"asymCINTsubindex\",1)", get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > asymCINT(get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )))));
            stan::math::initialize(asymCINT, DUMMY_VAR__);
            stan::math::fill(asymCINT,DUMMY_VAR__);
            current_statement_begin__ = 292;
            validate_non_negative_index("pop_T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_T0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_T0MEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_T0MEANS;  // dummy to suppress unused var warning

            stan::math::initialize(pop_T0MEANS, DUMMY_VAR__);
            stan::math::fill(pop_T0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 293;
            validate_non_negative_index("pop_LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_LAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_LAMBDA(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_LAMBDA;  // dummy to suppress unused var warning

            stan::math::initialize(pop_LAMBDA, DUMMY_VAR__);
            stan::math::fill(pop_LAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 294;
            validate_non_negative_index("pop_DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_DRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_DRIFT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_DRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_DRIFT, DUMMY_VAR__);
            stan::math::fill(pop_DRIFT,DUMMY_VAR__);
            current_statement_begin__ = 295;
            validate_non_negative_index("pop_DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_DIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_DIFFUSION(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_DIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(pop_DIFFUSION, DUMMY_VAR__);
            stan::math::fill(pop_DIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 296;
            validate_non_negative_index("pop_MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_MANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_MANIFESTVAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_MANIFESTVAR;  // dummy to suppress unused var warning

            stan::math::initialize(pop_MANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(pop_MANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 297;
            validate_non_negative_index("pop_MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_MANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_MANIFESTMEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_MANIFESTMEANS;  // dummy to suppress unused var warning

            stan::math::initialize(pop_MANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(pop_MANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 298;
            validate_non_negative_index("pop_CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_CINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_CINT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_CINT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_CINT, DUMMY_VAR__);
            stan::math::fill(pop_CINT,DUMMY_VAR__);
            current_statement_begin__ = 299;
            validate_non_negative_index("pop_T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_T0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_T0VAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_T0VAR;  // dummy to suppress unused var warning

            stan::math::initialize(pop_T0VAR, DUMMY_VAR__);
            stan::math::fill(pop_T0VAR,DUMMY_VAR__);
            current_statement_begin__ = 300;
            validate_non_negative_index("pop_TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("pop_TDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_TDPREDEFFECT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)));
            (void) pop_TDPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_TDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(pop_TDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 302;
            validate_non_negative_index("pop_asymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("pop_asymDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  pop_asymDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) pop_asymDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(pop_asymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(pop_asymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 303;
            validate_non_negative_index("pop_asymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  pop_asymCINT(static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )));
            (void) pop_asymCINT;  // dummy to suppress unused var warning

            stan::math::initialize(pop_asymCINT, DUMMY_VAR__);
            stan::math::fill(pop_asymCINT,DUMMY_VAR__);
            current_statement_begin__ = 307;
            validate_non_negative_index("tipreds", "(ntipred ? nsubjects : 0 )", (ntipred ? nsubjects : 0 ));
            validate_non_negative_index("tipreds", "(ntipred ? ntipred : 0 )", (ntipred ? ntipred : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  tipreds(static_cast<Eigen::VectorXd::Index>((ntipred ? nsubjects : 0 )),static_cast<Eigen::VectorXd::Index>((ntipred ? ntipred : 0 )));
            (void) tipreds;  // dummy to suppress unused var warning

            stan::math::initialize(tipreds, DUMMY_VAR__);
            stan::math::fill(tipreds,DUMMY_VAR__);
            current_statement_begin__ = 308;
            validate_non_negative_index("TIPREDEFFECT", "nparams", nparams);
            validate_non_negative_index("TIPREDEFFECT", "ntipred", ntipred);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  TIPREDEFFECT(static_cast<Eigen::VectorXd::Index>(nparams),static_cast<Eigen::VectorXd::Index>(ntipred));
            (void) TIPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(TIPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(TIPREDEFFECT,DUMMY_VAR__);


            current_statement_begin__ = 310;
            if (as_bool(logical_gt(ntipred,0))) {
                {
                current_statement_begin__ = 311;
                int counter(0);
                (void) counter;  // dummy to suppress unused var warning

                stan::math::fill(counter, std::numeric_limits<int>::min());
                stan::math::assign(counter,0);


                current_statement_begin__ = 312;
                for (int coli = 1; coli <= cols(tipreds); ++coli) {

                    current_statement_begin__ = 313;
                    for (int rowi = 1; rowi <= rows(tipreds); ++rowi) {

                        current_statement_begin__ = 314;
                        if (as_bool(logical_eq(get_base1(tipredsdata,rowi,coli,"tipredsdata",1),99999))) {

                            current_statement_begin__ = 315;
                            stan::math::assign(counter, (counter + 1));
                            current_statement_begin__ = 316;
                            stan::model::assign(tipreds, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                                        get_base1(tipredsimputed,counter,"tipredsimputed",1), 
                                        "assigning variable tipreds");
                        } else {
                            current_statement_begin__ = 317;
                            stan::model::assign(tipreds, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_uni(coli), stan::model::nil_index_list())), 
                                        get_base1(tipredsdata,rowi,coli,"tipredsdata",1), 
                                        "assigning variable tipreds");
                        }
                    }
                }
                current_statement_begin__ = 320;
                for (int ci = 1; ci <= ntipred; ++ci) {

                    current_statement_begin__ = 321;
                    for (int ri = 1; ri <= nparams; ++ri) {

                        current_statement_begin__ = 322;
                        if (as_bool(logical_gt(get_base1(get_base1(TIPREDEFFECTsetup,ri,"TIPREDEFFECTsetup",1),ci,"TIPREDEFFECTsetup",2),0))) {

                            current_statement_begin__ = 323;
                            stan::model::assign(TIPREDEFFECT, 
                                        stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                        get_base1(tipredeffectparams,get_base1(get_base1(TIPREDEFFECTsetup,ri,"TIPREDEFFECTsetup",1),ci,"TIPREDEFFECTsetup",2),"tipredeffectparams",1), 
                                        "assigning variable TIPREDEFFECT");
                        } else {

                            current_statement_begin__ = 325;
                            stan::model::assign(TIPREDEFFECT, 
                                        stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                        0, 
                                        "assigning variable TIPREDEFFECT");
                        }
                    }
                }
                }
            }
            current_statement_begin__ = 331;
            if (as_bool(logical_gt(nindvarying,0))) {
                {
                current_statement_begin__ = 332;
                int counter(0);
                (void) counter;  // dummy to suppress unused var warning

                stan::math::fill(counter, std::numeric_limits<int>::min());
                stan::math::assign(counter,0);


                current_statement_begin__ = 333;
                stan::math::assign(rawpopsd, elt_multiply(stan::math::exp(subtract(multiply(2,rawpopsdbase),1)),sdscale));
                current_statement_begin__ = 334;
                for (int j = 1; j <= nindvarying; ++j) {

                    current_statement_begin__ = 335;
                    stan::model::assign(rawpopcovsqrt, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                1, 
                                "assigning variable rawpopcovsqrt");
                    current_statement_begin__ = 336;
                    for (int i = 1; i <= nindvarying; ++i) {

                        current_statement_begin__ = 337;
                        if (as_bool(logical_gt(i,j))) {

                            current_statement_begin__ = 338;
                            stan::math::assign(counter, (counter + 1));
                            current_statement_begin__ = 339;
                            stan::model::assign(rawpopcovsqrt, 
                                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                        get_base1(sqrtpcov,counter,"sqrtpcov",1), 
                                        "assigning variable rawpopcovsqrt");
                            current_statement_begin__ = 340;
                            stan::model::assign(rawpopcovsqrt, 
                                        stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                        get_base1(sqrtpcov,counter,"sqrtpcov",1), 
                                        "assigning variable rawpopcovsqrt");
                        }
                    }
                }
                current_statement_begin__ = 344;
                stan::math::assign(rawpopcovsqrt, stan::model::deep_copy(cholesky_decompose(makesym(tcrossprod(diag_pre_multiply(rawpopsd,constraincorsqrt(rawpopcovsqrt, pstream__))),verbose,1, pstream__))));
                }
            }
            current_statement_begin__ = 348;
            stan::math::assign(ll, 0);
            {
            current_statement_begin__ = 350;
            int si(0);
            (void) si;  // dummy to suppress unused var warning

            stan::math::fill(si, std::numeric_limits<int>::min());
            current_statement_begin__ = 351;
            int firstsubject(0);
            (void) firstsubject;  // dummy to suppress unused var warning

            stan::math::fill(firstsubject, std::numeric_limits<int>::min());
            stan::math::assign(firstsubject,1);
            current_statement_begin__ = 352;
            int counter(0);
            (void) counter;  // dummy to suppress unused var warning

            stan::math::fill(counter, std::numeric_limits<int>::min());
            stan::math::assign(counter,0);
            current_statement_begin__ = 353;
            validate_non_negative_index("eta", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 354;
            validate_non_negative_index("etacov", "nlatentpop", nlatentpop);
            validate_non_negative_index("etacov", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  etacov(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) etacov;  // dummy to suppress unused var warning

            stan::math::initialize(etacov, DUMMY_VAR__);
            stan::math::fill(etacov,DUMMY_VAR__);
            current_statement_begin__ = 357;
            validate_non_negative_index("err", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  err(static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) err;  // dummy to suppress unused var warning

            stan::math::initialize(err, DUMMY_VAR__);
            stan::math::fill(err,DUMMY_VAR__);
            current_statement_begin__ = 358;
            validate_non_negative_index("ypred", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  ypred(static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypred;  // dummy to suppress unused var warning

            stan::math::initialize(ypred, DUMMY_VAR__);
            stan::math::fill(ypred,DUMMY_VAR__);
            current_statement_begin__ = 359;
            validate_non_negative_index("ystate", "(nldynamics ? nmanifest : 0 )", (nldynamics ? nmanifest : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  ystate(static_cast<Eigen::VectorXd::Index>((nldynamics ? nmanifest : 0 )));
            (void) ystate;  // dummy to suppress unused var warning

            stan::math::initialize(ystate, DUMMY_VAR__);
            stan::math::fill(ystate,DUMMY_VAR__);
            current_statement_begin__ = 360;
            validate_non_negative_index("ypredcov", "nmanifest", nmanifest);
            validate_non_negative_index("ypredcov", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ypredcov(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypredcov;  // dummy to suppress unused var warning

            stan::math::initialize(ypredcov, DUMMY_VAR__);
            stan::math::fill(ypredcov,DUMMY_VAR__);
            current_statement_begin__ = 361;
            validate_non_negative_index("K", "nlatentpop", nlatentpop);
            validate_non_negative_index("K", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            current_statement_begin__ = 362;
            validate_non_negative_index("ypredcov_sqrt", "nmanifest", nmanifest);
            validate_non_negative_index("ypredcov_sqrt", "nmanifest", nmanifest);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ypredcov_sqrt(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(nmanifest));
            (void) ypredcov_sqrt;  // dummy to suppress unused var warning

            stan::math::initialize(ypredcov_sqrt, DUMMY_VAR__);
            stan::math::fill(ypredcov_sqrt,DUMMY_VAR__);
            current_statement_begin__ = 364;
            validate_non_negative_index("kout", "((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))", ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )));
            validate_non_negative_index("kout", "ndatapoints", ndatapoints);
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > kout(ndatapoints, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 ))))));
            stan::math::initialize(kout, DUMMY_VAR__);
            stan::math::fill(kout,DUMMY_VAR__);
            current_statement_begin__ = 366;
            validate_non_negative_index("sigpoints", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
            validate_non_negative_index("sigpoints", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sigpoints(static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )),static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )));
            (void) sigpoints;  // dummy to suppress unused var warning

            stan::math::initialize(sigpoints, DUMMY_VAR__);
            stan::math::fill(sigpoints,DUMMY_VAR__);
            current_statement_begin__ = 367;
            validate_non_negative_index("state", "nlatentpop", nlatentpop);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  state(static_cast<Eigen::VectorXd::Index>(nlatentpop));
            (void) state;  // dummy to suppress unused var warning

            stan::math::initialize(state, DUMMY_VAR__);
            stan::math::fill(state,DUMMY_VAR__);
            current_statement_begin__ = 370;
            validate_non_negative_index("discreteDRIFT", "(nlatent + 1)", (nlatent + 1));
            validate_non_negative_index("discreteDRIFT", "(nlatent + 1)", (nlatent + 1));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  discreteDRIFT(static_cast<Eigen::VectorXd::Index>((nlatent + 1)),static_cast<Eigen::VectorXd::Index>((nlatent + 1)));
            (void) discreteDRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(discreteDRIFT, DUMMY_VAR__);
            stan::math::fill(discreteDRIFT,DUMMY_VAR__);
            current_statement_begin__ = 371;
            validate_non_negative_index("discreteDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("discreteDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  discreteDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) discreteDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(discreteDIFFUSION, DUMMY_VAR__);
            stan::math::fill(discreteDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 374;
            validate_non_negative_index("sT0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sT0MEANS", "get_base1(get_base1(matrixdims,1,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sT0MEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2)));
            (void) sT0MEANS;  // dummy to suppress unused var warning

            stan::math::initialize(sT0MEANS, DUMMY_VAR__);
            stan::math::fill(sT0MEANS,DUMMY_VAR__);
            current_statement_begin__ = 375;
            validate_non_negative_index("sLAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sLAMBDA", "get_base1(get_base1(matrixdims,2,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sLAMBDA(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2)));
            (void) sLAMBDA;  // dummy to suppress unused var warning

            stan::math::initialize(sLAMBDA, DUMMY_VAR__);
            stan::math::fill(sLAMBDA,DUMMY_VAR__);
            current_statement_begin__ = 376;
            validate_non_negative_index("sDRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sDRIFT", "get_base1(get_base1(matrixdims,3,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDRIFT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2)));
            (void) sDRIFT;  // dummy to suppress unused var warning

            stan::math::initialize(sDRIFT, DUMMY_VAR__);
            stan::math::fill(sDRIFT,DUMMY_VAR__);
            current_statement_begin__ = 377;
            validate_non_negative_index("sDIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sDIFFUSION", "get_base1(get_base1(matrixdims,4,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDIFFUSION(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2)));
            (void) sDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(sDIFFUSION, DUMMY_VAR__);
            stan::math::fill(sDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 378;
            validate_non_negative_index("sMANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sMANIFESTVAR", "get_base1(get_base1(matrixdims,5,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sMANIFESTVAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2)));
            (void) sMANIFESTVAR;  // dummy to suppress unused var warning

            stan::math::initialize(sMANIFESTVAR, DUMMY_VAR__);
            stan::math::fill(sMANIFESTVAR,DUMMY_VAR__);
            current_statement_begin__ = 379;
            validate_non_negative_index("sMANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sMANIFESTMEANS", "get_base1(get_base1(matrixdims,6,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sMANIFESTMEANS(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2)));
            (void) sMANIFESTMEANS;  // dummy to suppress unused var warning

            stan::math::initialize(sMANIFESTMEANS, DUMMY_VAR__);
            stan::math::fill(sMANIFESTMEANS,DUMMY_VAR__);
            current_statement_begin__ = 380;
            validate_non_negative_index("sCINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sCINT", "get_base1(get_base1(matrixdims,7,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sCINT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2)));
            (void) sCINT;  // dummy to suppress unused var warning

            stan::math::initialize(sCINT, DUMMY_VAR__);
            stan::math::fill(sCINT,DUMMY_VAR__);
            current_statement_begin__ = 381;
            validate_non_negative_index("sT0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sT0VAR", "get_base1(get_base1(matrixdims,8,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sT0VAR(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2)));
            (void) sT0VAR;  // dummy to suppress unused var warning

            stan::math::initialize(sT0VAR, DUMMY_VAR__);
            stan::math::fill(sT0VAR,DUMMY_VAR__);
            current_statement_begin__ = 382;
            validate_non_negative_index("sTDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),1,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2));
            validate_non_negative_index("sTDPREDEFFECT", "get_base1(get_base1(matrixdims,9,\"matrixdims\",1),2,\"matrixdims\",2)", get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sTDPREDEFFECT(static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2)),static_cast<Eigen::VectorXd::Index>(get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2)));
            (void) sTDPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(sTDPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(sTDPREDEFFECT,DUMMY_VAR__);
            current_statement_begin__ = 384;
            validate_non_negative_index("sasymDIFFUSION", "nlatent", nlatent);
            validate_non_negative_index("sasymDIFFUSION", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sasymDIFFUSION(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) sasymDIFFUSION;  // dummy to suppress unused var warning

            stan::math::initialize(sasymDIFFUSION, DUMMY_VAR__);
            stan::math::fill(sasymDIFFUSION,DUMMY_VAR__);
            current_statement_begin__ = 385;
            validate_non_negative_index("sasymCINT", "(nt0meansstationary ? nlatent : 0 )", (nt0meansstationary ? nlatent : 0 ));
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  sasymCINT(static_cast<Eigen::VectorXd::Index>((nt0meansstationary ? nlatent : 0 )));
            (void) sasymCINT;  // dummy to suppress unused var warning

            stan::math::initialize(sasymCINT, DUMMY_VAR__);
            stan::math::fill(sasymCINT,DUMMY_VAR__);
            current_statement_begin__ = 386;
            validate_non_negative_index("sDIFFUSIONsqrt", "nlatent", nlatent);
            validate_non_negative_index("sDIFFUSIONsqrt", "nlatent", nlatent);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  sDIFFUSIONsqrt(static_cast<Eigen::VectorXd::Index>(nlatent),static_cast<Eigen::VectorXd::Index>(nlatent));
            (void) sDIFFUSIONsqrt;  // dummy to suppress unused var warning

            stan::math::initialize(sDIFFUSIONsqrt, DUMMY_VAR__);
            stan::math::fill(sDIFFUSIONsqrt,DUMMY_VAR__);


            current_statement_begin__ = 389;
            if (as_bool(logical_eq(nldynamics,0))) {
                current_statement_begin__ = 389;
                stan::math::assign(discreteDIFFUSION, rep_matrix(0,nlatent,nlatent));
            }
            current_statement_begin__ = 391;
            if (as_bool(savescores)) {
                current_statement_begin__ = 391;
                stan::math::assign(kout, stan::model::deep_copy(rep_array(rep_vector(99999,rows(get_base1(kout,1,"kout",1))),ndatapoints)));
            }
            current_statement_begin__ = 393;
            for (int rowi = 1; rowi <= (dokalman ? ndatapoints : 1 ); ++rowi) {

                current_statement_begin__ = 394;
                if (as_bool(logical_eq(get_base1(dokalmanrows,rowi,"dokalmanrows",1),1))) {
                    {
                    current_statement_begin__ = 395;
                    validate_non_negative_index("ukfstates", "(nldynamics ? nlatentpop : 0 )", (nldynamics ? nlatentpop : 0 ));
                    validate_non_negative_index("ukfstates", "(ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )", (ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) ));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ukfstates(static_cast<Eigen::VectorXd::Index>((nldynamics ? nlatentpop : 0 )),static_cast<Eigen::VectorXd::Index>((ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )));
                    (void) ukfstates;  // dummy to suppress unused var warning

                    stan::math::initialize(ukfstates, DUMMY_VAR__);
                    stan::math::fill(ukfstates,DUMMY_VAR__);
                    current_statement_begin__ = 396;
                    validate_non_negative_index("ukfmeasures", "(nldynamics ? nmanifest : 0 )", (nldynamics ? nmanifest : 0 ));
                    validate_non_negative_index("ukfmeasures", "(ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )", (ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) ));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  ukfmeasures(static_cast<Eigen::VectorXd::Index>((nldynamics ? nmanifest : 0 )),static_cast<Eigen::VectorXd::Index>((ukffull ? ((2 * nlatentpop) + 2) : (nlatentpop + 2) )));
                    (void) ukfmeasures;  // dummy to suppress unused var warning

                    stan::math::initialize(ukfmeasures, DUMMY_VAR__);
                    stan::math::fill(ukfmeasures,DUMMY_VAR__);


                    current_statement_begin__ = 397;
                    stan::math::assign(si, get_base1(subject,rowi,"subject",1));
                    current_statement_begin__ = 400;
                    if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {
                        {
                        current_statement_begin__ = 403;
                        validate_non_negative_index("subjectvec", "(firstsubject ? 2 : 1 )", (firstsubject ? 2 : 1 ));
                        vector<int> subjectvec((firstsubject ? 2 : 1 ), 0);
                        stan::math::fill(subjectvec, std::numeric_limits<int>::min());


                        current_statement_begin__ = 404;
                        stan::model::assign(subjectvec, 
                                    stan::model::cons_list(stan::model::index_uni(size(subjectvec)), stan::model::nil_index_list()), 
                                    si, 
                                    "assigning variable subjectvec");
                        current_statement_begin__ = 405;
                        if (as_bool(logical_eq(firstsubject,1))) {

                            current_statement_begin__ = 406;
                            stan::math::assign(firstsubject, 0);
                            current_statement_begin__ = 407;
                            stan::model::assign(subjectvec, 
                                        stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                                        0, 
                                        "assigning variable subjectvec");
                        }
                        current_statement_begin__ = 409;
                        for (int subjectveci = 1; subjectveci <= size(subjectvec); ++subjectveci) {
                            {
                            current_statement_begin__ = 410;
                            int subi(0);
                            (void) subi;  // dummy to suppress unused var warning

                            stan::math::fill(subi, std::numeric_limits<int>::min());
                            stan::math::assign(subi,get_base1(subjectvec,subjectveci,"subjectvec",1));
                            current_statement_begin__ = 411;
                            validate_non_negative_index("rawindparams", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawindparams(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) rawindparams;  // dummy to suppress unused var warning

                            stan::math::initialize(rawindparams, DUMMY_VAR__);
                            stan::math::fill(rawindparams,DUMMY_VAR__);
                            current_statement_begin__ = 412;
                            validate_non_negative_index("tipredaddition", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  tipredaddition(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) tipredaddition;  // dummy to suppress unused var warning

                            stan::math::initialize(tipredaddition, DUMMY_VAR__);
                            stan::math::fill(tipredaddition,DUMMY_VAR__);
                            stan::math::assign(tipredaddition,rep_vector(0,nparams));
                            current_statement_begin__ = 413;
                            validate_non_negative_index("indvaraddition", "nparams", nparams);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  indvaraddition(static_cast<Eigen::VectorXd::Index>(nparams));
                            (void) indvaraddition;  // dummy to suppress unused var warning

                            stan::math::initialize(indvaraddition, DUMMY_VAR__);
                            stan::math::fill(indvaraddition,DUMMY_VAR__);
                            stan::math::assign(indvaraddition,rep_vector(0,nparams));


                            current_statement_begin__ = 415;
                            if (as_bool((primitive_value((primitive_value(logical_gt(subi,0)) && primitive_value(logical_gt(nindvarying,0)))) && primitive_value(logical_eq(intoverpop,0))))) {

                                current_statement_begin__ = 416;
                                if (as_bool(logical_eq(fixedsubpars,0))) {
                                    current_statement_begin__ = 416;
                                    stan::model::assign(indvaraddition, 
                                                stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), 
                                                multiply(rawpopcovsqrt,get_base1(baseindparams,subi,"baseindparams",1)), 
                                                "assigning variable indvaraddition");
                                }
                                current_statement_begin__ = 417;
                                if (as_bool(logical_eq(fixedsubpars,1))) {
                                    current_statement_begin__ = 417;
                                    stan::model::assign(indvaraddition, 
                                                stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), 
                                                multiply(rawpopcovsqrt,get_base1(fixedindparams,subi,"fixedindparams",1)), 
                                                "assigning variable indvaraddition");
                                }
                            }
                            current_statement_begin__ = 420;
                            if (as_bool((primitive_value(logical_gt(subi,0)) && primitive_value(logical_gt(ntipred,0))))) {
                                current_statement_begin__ = 420;
                                stan::math::assign(tipredaddition, multiply(TIPREDEFFECT,transpose(get_base1(tipreds,subi,"tipreds",1))));
                            }
                            current_statement_begin__ = 422;
                            stan::math::assign(rawindparams, add(add(rawpopmeans,tipredaddition),indvaraddition));
                            current_statement_begin__ = 424;
                            for (int ri = 1; ri <= size(matsetup); ++ri) {

                                current_statement_begin__ = 425;
                                if (as_bool((primitive_value(logical_lt(subi,2)) || primitive_value((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),0)) && primitive_value((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) || primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),6,"matsetup",2),0))))))))) {
                                    {
                                    current_statement_begin__ = 426;
                                    local_scalar_t__ newval;
                                    (void) newval;  // dummy to suppress unused var warning

                                    stan::math::initialize(newval, DUMMY_VAR__);
                                    stan::math::fill(newval,DUMMY_VAR__);


                                    current_statement_begin__ = 427;
                                    if (as_bool(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),0))) {
                                        current_statement_begin__ = 427;
                                        stan::math::assign(newval, tform(get_base1(rawindparams,get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),"rawindparams",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                    }
                                    current_statement_begin__ = 429;
                                    if (as_bool(logical_lt(get_base1(get_base1(matsetup,ri,"matsetup",1),3,"matsetup",2),1))) {
                                        current_statement_begin__ = 429;
                                        stan::math::assign(newval, get_base1(get_base1(matvalues,ri,"matvalues",1),1,"matvalues",2));
                                    }
                                    current_statement_begin__ = 430;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1))) {
                                        current_statement_begin__ = 430;
                                        stan::model::assign(sT0MEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sT0MEANS");
                                    }
                                    current_statement_begin__ = 431;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2))) {
                                        current_statement_begin__ = 431;
                                        stan::model::assign(sLAMBDA, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sLAMBDA");
                                    }
                                    current_statement_begin__ = 432;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3))) {
                                        current_statement_begin__ = 432;
                                        stan::model::assign(sDRIFT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sDRIFT");
                                    }
                                    current_statement_begin__ = 433;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4))) {
                                        current_statement_begin__ = 433;
                                        stan::model::assign(sDIFFUSION, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sDIFFUSION");
                                    }
                                    current_statement_begin__ = 434;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5))) {
                                        current_statement_begin__ = 434;
                                        stan::model::assign(sMANIFESTVAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sMANIFESTVAR");
                                    }
                                    current_statement_begin__ = 435;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))) {
                                        current_statement_begin__ = 435;
                                        stan::model::assign(sMANIFESTMEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sMANIFESTMEANS");
                                    }
                                    current_statement_begin__ = 436;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))) {
                                        current_statement_begin__ = 436;
                                        stan::model::assign(sCINT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sCINT");
                                    }
                                    current_statement_begin__ = 437;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))) {
                                        current_statement_begin__ = 437;
                                        stan::model::assign(sT0VAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sT0VAR");
                                    }
                                    current_statement_begin__ = 438;
                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                        current_statement_begin__ = 438;
                                        stan::model::assign(sTDPREDEFFECT, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                    newval, 
                                                    "assigning variable sTDPREDEFFECT");
                                    }
                                    }
                                }
                            }
                            current_statement_begin__ = 443;
                            stan::model::assign(state, 
                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                        stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"), 
                                        "assigning variable state");
                            current_statement_begin__ = 447;
                            if (as_bool(logical_lte(subi,get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1)))) {

                                current_statement_begin__ = 448;
                                if (as_bool(logical_eq(nldynamics,1))) {
                                    current_statement_begin__ = 448;
                                    stan::math::assign(sDIFFUSIONsqrt, sDIFFUSION);
                                }
                                current_statement_begin__ = 449;
                                stan::math::assign(sDIFFUSION, stan::model::deep_copy(sdcovsqrt2cov(sDIFFUSION,nldynamics, pstream__)));
                            }
                            current_statement_begin__ = 451;
                            if (as_bool(logical_lte(subi,get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1)))) {

                                current_statement_begin__ = 452;
                                if (as_bool(logical_lt(ndiffusion,nlatent))) {
                                    current_statement_begin__ = 452;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(rep_vector(0,(nlatent * nlatent)),nlatent,nlatent));
                                }
                                current_statement_begin__ = 454;
                                if (as_bool(logical_eq(continuoustime,1))) {
                                    current_statement_begin__ = 454;
                                    stan::model::assign(sasymDIFFUSION, 
                                                stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), 
                                                to_matrix(mdivide_left(minus(kronsum(stan::model::rvalue(sDRIFT, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDRIFT"), pstream__)),to_vector(stan::model::rvalue(sDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDIFFUSION"))),ndiffusion,ndiffusion), 
                                                "assigning variable sasymDIFFUSION");
                                }
                                current_statement_begin__ = 458;
                                if (as_bool(logical_eq(continuoustime,0))) {
                                    current_statement_begin__ = 458;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(multiply(subtract(IIlatent2,sqkron_prod(sDRIFT,sDRIFT, pstream__)),to_vector(stan::model::rvalue(sDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sDIFFUSION"))),ndiffusion,ndiffusion));
                                }
                            }
                            current_statement_begin__ = 462;
                            if (as_bool(logical_lte(subi,get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1)))) {

                                current_statement_begin__ = 463;
                                for (int ri = 1; ri <= nmanifest; ++ri) {
                                    current_statement_begin__ = 463;
                                    stan::model::assign(sMANIFESTVAR, 
                                                stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_uni(ri), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(square(get_base1(sMANIFESTVAR,ri,ri,"sMANIFESTVAR",1))), 
                                                "assigning variable sMANIFESTVAR");
                                }
                            }
                            current_statement_begin__ = 466;
                            if (as_bool(logical_lte(subi,get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1)))) {

                                current_statement_begin__ = 467;
                                stan::math::assign(sT0VAR, stan::model::deep_copy(makesym(sdcovsqrt2cov(sT0VAR,nldynamics, pstream__),verbose,1, pstream__)));
                                current_statement_begin__ = 468;
                                if (as_bool(logical_gt(nt0varstationary,0))) {

                                    current_statement_begin__ = 469;
                                    for (int ri = 1; ri <= nt0varstationary; ++ri) {

                                        current_statement_begin__ = 470;
                                        stan::model::assign(sT0VAR, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),1,"t0varstationary",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),2,"t0varstationary",2)), stan::model::nil_index_list())), 
                                                    get_base1(sasymDIFFUSION,get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),1,"t0varstationary",2),get_base1(get_base1(t0varstationary,ri,"t0varstationary",1),2,"t0varstationary",2),"sasymDIFFUSION",1), 
                                                    "assigning variable sT0VAR");
                                    }
                                }
                            }
                            current_statement_begin__ = 475;
                            if (as_bool(logical_gt(nt0meansstationary,0))) {

                                current_statement_begin__ = 476;
                                if (as_bool(logical_lte(subi,get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1)))) {

                                    current_statement_begin__ = 477;
                                    if (as_bool(logical_eq(continuoustime,1))) {
                                        current_statement_begin__ = 477;
                                        stan::math::assign(sasymCINT, mdivide_left(minus(sDRIFT),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                    }
                                    current_statement_begin__ = 478;
                                    if (as_bool(logical_eq(continuoustime,0))) {
                                        current_statement_begin__ = 478;
                                        stan::math::assign(sasymCINT, mdivide_left(subtract(IIlatent,sDRIFT),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                    }
                                }
                                current_statement_begin__ = 480;
                                if (as_bool(logical_lte(subi,get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1)))) {

                                    current_statement_begin__ = 481;
                                    for (int ri = 1; ri <= nt0meansstationary; ++ri) {

                                        current_statement_begin__ = 482;
                                        stan::model::assign(sT0MEANS, 
                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(t0meansstationary,ri,"t0meansstationary",1),1,"t0meansstationary",2)), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                    get_base1(sasymCINT,get_base1(get_base1(t0meansstationary,ri,"t0meansstationary",1),1,"t0meansstationary",2),"sasymCINT",1), 
                                                    "assigning variable sT0MEANS");
                                    }
                                }
                            }
                            current_statement_begin__ = 488;
                            if (as_bool(logical_gt(subi,0))) {

                                current_statement_begin__ = 489;
                                stan::model::assign(T0MEANS, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(T0MEANSsubindex,subi,"T0MEANSsubindex",1)), stan::model::nil_index_list()), 
                                            sT0MEANS, 
                                            "assigning variable T0MEANS");
                                current_statement_begin__ = 490;
                                stan::model::assign(LAMBDA, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(LAMBDAsubindex,subi,"LAMBDAsubindex",1)), stan::model::nil_index_list()), 
                                            sLAMBDA, 
                                            "assigning variable LAMBDA");
                                current_statement_begin__ = 491;
                                stan::model::assign(DRIFT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(DRIFTsubindex,subi,"DRIFTsubindex",1)), stan::model::nil_index_list()), 
                                            sDRIFT, 
                                            "assigning variable DRIFT");
                                current_statement_begin__ = 492;
                                stan::model::assign(DIFFUSION, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(DIFFUSIONsubindex,subi,"DIFFUSIONsubindex",1)), stan::model::nil_index_list()), 
                                            sDIFFUSION, 
                                            "assigning variable DIFFUSION");
                                current_statement_begin__ = 493;
                                stan::model::assign(MANIFESTVAR, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(MANIFESTVARsubindex,subi,"MANIFESTVARsubindex",1)), stan::model::nil_index_list()), 
                                            sMANIFESTVAR, 
                                            "assigning variable MANIFESTVAR");
                                current_statement_begin__ = 494;
                                stan::model::assign(MANIFESTMEANS, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(MANIFESTMEANSsubindex,subi,"MANIFESTMEANSsubindex",1)), stan::model::nil_index_list()), 
                                            sMANIFESTMEANS, 
                                            "assigning variable MANIFESTMEANS");
                                current_statement_begin__ = 495;
                                stan::model::assign(CINT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(CINTsubindex,subi,"CINTsubindex",1)), stan::model::nil_index_list()), 
                                            sCINT, 
                                            "assigning variable CINT");
                                current_statement_begin__ = 496;
                                stan::model::assign(T0VAR, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(T0VARsubindex,subi,"T0VARsubindex",1)), stan::model::nil_index_list()), 
                                            sT0VAR, 
                                            "assigning variable T0VAR");
                                current_statement_begin__ = 497;
                                stan::model::assign(TDPREDEFFECT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(TDPREDEFFECTsubindex,subi,"TDPREDEFFECTsubindex",1)), stan::model::nil_index_list()), 
                                            sTDPREDEFFECT, 
                                            "assigning variable TDPREDEFFECT");
                                current_statement_begin__ = 498;
                                stan::model::assign(asymDIFFUSION, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(asymDIFFUSIONsubindex,subi,"asymDIFFUSIONsubindex",1)), stan::model::nil_index_list()), 
                                            sasymDIFFUSION, 
                                            "assigning variable asymDIFFUSION");
                                current_statement_begin__ = 499;
                                stan::model::assign(asymCINT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(asymCINTsubindex,subi,"asymCINTsubindex",1)), stan::model::nil_index_list()), 
                                            sasymCINT, 
                                            "assigning variable asymCINT");
                            }
                            current_statement_begin__ = 503;
                            if (as_bool(logical_eq(subi,0))) {

                                current_statement_begin__ = 504;
                                stan::math::assign(pop_T0MEANS, sT0MEANS);
                                current_statement_begin__ = 505;
                                stan::math::assign(pop_LAMBDA, sLAMBDA);
                                current_statement_begin__ = 506;
                                stan::math::assign(pop_DRIFT, sDRIFT);
                                current_statement_begin__ = 507;
                                stan::math::assign(pop_DIFFUSION, sDIFFUSION);
                                current_statement_begin__ = 508;
                                stan::math::assign(pop_MANIFESTVAR, sMANIFESTVAR);
                                current_statement_begin__ = 509;
                                stan::math::assign(pop_MANIFESTMEANS, sMANIFESTMEANS);
                                current_statement_begin__ = 510;
                                stan::math::assign(pop_CINT, sCINT);
                                current_statement_begin__ = 511;
                                stan::math::assign(pop_T0VAR, sT0VAR);
                                current_statement_begin__ = 512;
                                stan::math::assign(pop_TDPREDEFFECT, sTDPREDEFFECT);
                                current_statement_begin__ = 513;
                                stan::math::assign(pop_asymDIFFUSION, sasymDIFFUSION);
                                current_statement_begin__ = 514;
                                stan::math::assign(pop_asymCINT, sasymCINT);
                            }
                            }
                        }
                        current_statement_begin__ = 521;
                        if (as_bool(logical_eq(nldynamics,1))) {

                            current_statement_begin__ = 522;
                            stan::math::assign(eta, rep_vector(0,nlatentpop));
                            current_statement_begin__ = 523;
                            stan::math::assign(sigpoints, rep_matrix(0,nlatentpop,nlatentpop));
                            current_statement_begin__ = 524;
                            if (as_bool(logical_eq(intoverpop,1))) {

                                current_statement_begin__ = 525;
                                if (as_bool(logical_eq(ntipred,0))) {
                                    current_statement_begin__ = 525;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list()), 
                                                stan::model::rvalue(rawpopmeans, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "rawpopmeans"), 
                                                "assigning variable eta");
                                }
                                current_statement_begin__ = 526;
                                if (as_bool(logical_gt(ntipred,0))) {
                                    current_statement_begin__ = 526;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(rawpopmeans, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "rawpopmeans"),multiply(stan::model::rvalue(TIPREDEFFECT, stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), "TIPREDEFFECT"),transpose(get_base1(tipreds,si,"tipreds",1)))), 
                                                "assigning variable eta");
                                }
                            }
                        }
                        current_statement_begin__ = 530;
                        if (as_bool(logical_eq(nldynamics,0))) {

                            current_statement_begin__ = 531;
                            stan::model::assign(state, 
                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                        stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"), 
                                        "assigning variable state");
                            current_statement_begin__ = 533;
                            stan::math::assign(eta, stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS"));
                            current_statement_begin__ = 534;
                            if (as_bool(logical_gt(ntdpred,0))) {
                                current_statement_begin__ = 534;
                                stan::math::assign(eta, add(eta, multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))));
                            }
                            current_statement_begin__ = 535;
                            stan::math::assign(etacov, sT0VAR);
                        }
                        }
                    }
                    current_statement_begin__ = 540;
                    if (as_bool((primitive_value(logical_eq(nldynamics,0)) && primitive_value(logical_eq(get_base1(T0check,rowi,"T0check",1),0))))) {

                        current_statement_begin__ = 541;
                        stan::model::assign(state, 
                                    stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                    stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"), 
                                    "assigning variable state");
                        current_statement_begin__ = 543;
                        if (as_bool(logical_eq(continuoustime,1))) {
                            {
                            current_statement_begin__ = 544;
                            int dtchange(0);
                            (void) dtchange;  // dummy to suppress unused var warning

                            stan::math::fill(dtchange, std::numeric_limits<int>::min());
                            stan::math::assign(dtchange,0);


                            current_statement_begin__ = 545;
                            if (as_bool((primitive_value(logical_eq(si,1)) && primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1))))) {

                                current_statement_begin__ = 546;
                                stan::math::assign(dtchange, 1);
                            } else if (as_bool((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value(logical_neq(get_base1(dT,(rowi - 2),"dT",1),get_base1(dT,rowi,"dT",1)))))) {

                                current_statement_begin__ = 548;
                                stan::math::assign(dtchange, 1);
                            } else if (as_bool((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),0)) && primitive_value(logical_neq(get_base1(dT,(rowi - 1),"dT",1),get_base1(dT,rowi,"dT",1)))))) {
                                current_statement_begin__ = 549;
                                stan::math::assign(dtchange, 1);
                            }
                            current_statement_begin__ = 552;
                            if (as_bool((primitive_value(logical_eq(dtchange,1)) || primitive_value((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value((primitive_value(logical_lte(si,get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1))) || primitive_value(logical_lte(si,get_base1(CINTsubindex,nsubjects,"CINTsubindex",1)))))))))) {

                                current_statement_begin__ = 553;
                                stan::math::assign(discreteDRIFT, expm2(multiply(append_row(append_col(sDRIFT,sCINT),rep_matrix(0,1,(nlatent + 1))),get_base1(dT,rowi,"dT",1)), pstream__));
                            }
                            current_statement_begin__ = 556;
                            if (as_bool((primitive_value(logical_eq(dtchange,1)) || primitive_value((primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1)) && primitive_value((primitive_value(logical_lte(si,get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1))) || primitive_value(logical_lte(si,get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1)))))))))) {

                                current_statement_begin__ = 557;
                                stan::model::assign(discreteDIFFUSION, 
                                            stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), 
                                            subtract(stan::model::rvalue(sasymDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sasymDIFFUSION"),quad_form(stan::model::rvalue(sasymDIFFUSION, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "sasymDIFFUSION"),transpose(stan::model::rvalue(discreteDRIFT, stan::model::cons_list(stan::model::index_multi(derrind), stan::model::cons_list(stan::model::index_multi(derrind), stan::model::nil_index_list())), "discreteDRIFT")))), 
                                            "assigning variable discreteDIFFUSION");
                                current_statement_begin__ = 559;
                                if (as_bool(logical_eq(intoverstates,0))) {
                                    current_statement_begin__ = 559;
                                    stan::math::assign(discreteDIFFUSION, stan::model::deep_copy(cholesky_decompose(makesym(discreteDIFFUSION,verbose,1, pstream__))));
                                }
                            }
                            }
                        }
                        current_statement_begin__ = 563;
                        if (as_bool((primitive_value(logical_eq(continuoustime,0)) && primitive_value(logical_eq(get_base1(T0check,(rowi - 1),"T0check",1),1))))) {

                            current_statement_begin__ = 564;
                            stan::math::assign(discreteDRIFT, append_row(append_col(sDRIFT,sCINT),rep_matrix(0,1,(nlatent + 1))));
                            current_statement_begin__ = 565;
                            stan::model::assign(discreteDRIFT, 
                                        stan::model::cons_list(stan::model::index_uni((nlatent + 1)), stan::model::cons_list(stan::model::index_uni((nlatent + 1)), stan::model::nil_index_list())), 
                                        1, 
                                        "assigning variable discreteDRIFT");
                            current_statement_begin__ = 566;
                            stan::math::assign(discreteDIFFUSION, sDIFFUSION);
                            current_statement_begin__ = 567;
                            if (as_bool(logical_eq(intoverstates,0))) {
                                current_statement_begin__ = 567;
                                stan::math::assign(discreteDIFFUSION, stan::model::deep_copy(cholesky_decompose(makesym(discreteDIFFUSION,verbose,1, pstream__))));
                            }
                        }
                        current_statement_begin__ = 570;
                        stan::math::assign(eta, stan::model::deep_copy(stan::model::rvalue(multiply(discreteDRIFT,append_row(eta,1.0)), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "multiply(discreteDRIFT,append_row(eta,1.0))")));
                        current_statement_begin__ = 571;
                        stan::model::assign(state, 
                                    stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                    stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"), 
                                    "assigning variable state");
                        current_statement_begin__ = 573;
                        if (as_bool(logical_gt(ntdpred,0))) {
                            current_statement_begin__ = 573;
                            stan::math::assign(eta, add(eta, multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))));
                        }
                        current_statement_begin__ = 574;
                        if (as_bool(logical_eq(intoverstates,1))) {

                            current_statement_begin__ = 575;
                            stan::math::assign(etacov, stan::model::deep_copy(quad_form(etacov,transpose(stan::model::rvalue(discreteDRIFT, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "discreteDRIFT")))));
                            current_statement_begin__ = 576;
                            if (as_bool(logical_gt(ndiffusion,0))) {
                                current_statement_begin__ = 576;
                                stan::math::assign(etacov, add(etacov, discreteDIFFUSION));
                            }
                        }
                    }
                    current_statement_begin__ = 581;
                    if (as_bool(logical_eq(nldynamics,1))) {

                        current_statement_begin__ = 582;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                            {
                            current_statement_begin__ = 583;
                            validate_non_negative_index("J", "nlatentpop", nlatentpop);
                            validate_non_negative_index("J", "nlatentpop", nlatentpop);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  J(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
                            (void) J;  // dummy to suppress unused var warning

                            stan::math::initialize(J, DUMMY_VAR__);
                            stan::math::fill(J,DUMMY_VAR__);
                            current_statement_begin__ = 584;
                            validate_non_negative_index("base", "nlatent", nlatent);
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  base(static_cast<Eigen::VectorXd::Index>(nlatent));
                            (void) base;  // dummy to suppress unused var warning

                            stan::math::initialize(base, DUMMY_VAR__);
                            stan::math::fill(base,DUMMY_VAR__);


                            current_statement_begin__ = 585;
                            stan::math::assign(J, rep_matrix(0,nlatentpop,nlatentpop));
                            current_statement_begin__ = 586;
                            if (as_bool(logical_eq(continuoustime,1))) {
                                {
                                current_statement_begin__ = 587;
                                validate_non_negative_index("Je", "nlatentpop", nlatentpop);
                                validate_non_negative_index("Je", "nlatentpop", nlatentpop);
                                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Je(static_cast<Eigen::VectorXd::Index>(nlatentpop),static_cast<Eigen::VectorXd::Index>(nlatentpop));
                                (void) Je;  // dummy to suppress unused var warning

                                stan::math::initialize(Je, DUMMY_VAR__);
                                stan::math::fill(Je,DUMMY_VAR__);
                                current_statement_begin__ = 588;
                                validate_non_negative_index("dQi", "(nlatent * 2)", (nlatent * 2));
                                validate_non_negative_index("dQi", "(nlatent * 2)", (nlatent * 2));
                                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  dQi(static_cast<Eigen::VectorXd::Index>((nlatent * 2)),static_cast<Eigen::VectorXd::Index>((nlatent * 2)));
                                (void) dQi;  // dummy to suppress unused var warning

                                stan::math::initialize(dQi, DUMMY_VAR__);
                                stan::math::fill(dQi,DUMMY_VAR__);


                                current_statement_begin__ = 589;
                                for (int stepi = 1; stepi <= get_base1(integrationsteps,rowi,"integrationsteps",1); ++stepi) {

                                    current_statement_begin__ = 590;
                                    for (int statei = 0; statei <= nlatentpop; ++statei) {

                                        current_statement_begin__ = 591;
                                        if (as_bool(logical_gt(statei,0))) {

                                            current_statement_begin__ = 592;
                                            stan::model::assign(J, 
                                                        stan::model::cons_list(stan::model::index_uni(statei), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                        9.9999999999999995e-07, 
                                                        "assigning variable J");
                                            current_statement_begin__ = 593;
                                            stan::math::assign(state, add(eta,stan::model::rvalue(J, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "J")));
                                        } else {

                                            current_statement_begin__ = 595;
                                            stan::math::assign(state, eta);
                                        }
                                        current_statement_begin__ = 600;
                                        if (as_bool(logical_eq(intoverpop,1))) {

                                            current_statement_begin__ = 601;
                                            for (int ri = 1; ri <= size(matsetup); ++ri) {

                                                current_statement_begin__ = 602;
                                                if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                                    current_statement_begin__ = 603;
                                                    if (as_bool((primitive_value((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4)))) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))))) {
                                                        {
                                                        current_statement_begin__ = 604;
                                                        local_scalar_t__ newval;
                                                        (void) newval;  // dummy to suppress unused var warning

                                                        stan::math::initialize(newval, DUMMY_VAR__);
                                                        stan::math::fill(newval,DUMMY_VAR__);


                                                        current_statement_begin__ = 605;
                                                        stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                        current_statement_begin__ = 606;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),3))) {
                                                            current_statement_begin__ = 606;
                                                            stan::model::assign(sDRIFT, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sDRIFT");
                                                        }
                                                        current_statement_begin__ = 607;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),4))) {
                                                            current_statement_begin__ = 607;
                                                            stan::model::assign(sDIFFUSIONsqrt, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sDIFFUSIONsqrt");
                                                        }
                                                        current_statement_begin__ = 608;
                                                        if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),7))) {
                                                            current_statement_begin__ = 608;
                                                            stan::model::assign(sCINT, 
                                                                        stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                        newval, 
                                                                        "assigning variable sCINT");
                                                        }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        current_statement_begin__ = 613;
                                        if (as_bool(logical_eq(statei,0))) {

                                            current_statement_begin__ = 614;
                                            stan::math::assign(base, add(multiply(sDRIFT,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state")),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")));
                                        }
                                        current_statement_begin__ = 616;
                                        if (as_bool(logical_gt(statei,0))) {

                                            current_statement_begin__ = 617;
                                            stan::model::assign(J, 
                                                        stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                        divide(subtract(add(multiply(sDRIFT,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state")),stan::model::rvalue(sCINT, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sCINT")),base),9.9999999999999995e-07), 
                                                        "assigning variable J");
                                        }
                                    }
                                    current_statement_begin__ = 622;
                                    stan::math::assign(Je, expm2(multiply(J,get_base1(dTsmall,rowi,"dTsmall",1)), pstream__));
                                    current_statement_begin__ = 625;
                                    stan::math::assign(discreteDRIFT, expm2(multiply(append_row(append_col(sDRIFT,sCINT),transpose(rep_vector(0,(nlatent + 1)))),get_base1(dTsmall,rowi,"dTsmall",1)), pstream__));
                                    current_statement_begin__ = 626;
                                    stan::math::assign(sasymDIFFUSION, to_matrix(mdivide_left(minus(kronsum(stan::model::rvalue(J, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "J"), pstream__)),to_vector(tcrossprod(sDIFFUSIONsqrt))),nlatent,nlatent));
                                    current_statement_begin__ = 627;
                                    stan::math::assign(discreteDIFFUSION, subtract(sasymDIFFUSION,quad_form(sasymDIFFUSION,transpose(stan::model::rvalue(Je, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "Je")))));
                                    current_statement_begin__ = 628;
                                    stan::math::assign(etacov, stan::model::deep_copy(quad_form(etacov,transpose(Je))));
                                    current_statement_begin__ = 629;
                                    stan::model::assign(etacov, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(etacov, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "etacov"), discreteDIFFUSION), 
                                                "assigning variable etacov");
                                    current_statement_begin__ = 630;
                                    stan::model::assign(eta, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                stan::model::deep_copy(stan::model::rvalue(multiply(discreteDRIFT,append_row(stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"),1.0)), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "multiply(discreteDRIFT,append_row(eta[1:nlatent],1.0))")), 
                                                "assigning variable eta");
                                }
                                }
                            }
                            current_statement_begin__ = 634;
                            if (as_bool(logical_eq(continuoustime,0))) {

                            }
                            }
                        }
                        current_statement_begin__ = 639;
                        if (as_bool((primitive_value((primitive_value(logical_eq(nlmeasurement,1)) || primitive_value(logical_gt(ntdpred,0)))) || primitive_value(logical_eq(get_base1(T0check,rowi,"T0check",1),1))))) {

                            current_statement_begin__ = 641;
                            if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {

                                current_statement_begin__ = 642;
                                if (as_bool(logical_eq(intoverpop,1))) {
                                    current_statement_begin__ = 642;
                                    stan::model::assign(sigpoints, 
                                                stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::cons_list(stan::model::index_min_max((nlatent + 1), nlatentpop), stan::model::nil_index_list())), 
                                                multiply(rawpopcovsqrt,sqrtukfadjust), 
                                                "assigning variable sigpoints");
                                }
                                current_statement_begin__ = 643;
                                stan::model::assign(sigpoints, 
                                            stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), 
                                            multiply(cholesky_decompose(sT0VAR),sqrtukfadjust), 
                                            "assigning variable sigpoints");
                            }
                            current_statement_begin__ = 646;
                            if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                                current_statement_begin__ = 646;
                                stan::math::assign(sigpoints, multiply(cholesky_decompose(makesym(etacov,verbose,1, pstream__)),sqrtukfadjust));
                            }
                            current_statement_begin__ = 649;
                            for (int statei = 2; statei <= cols(ukfstates); ++statei) {

                                current_statement_begin__ = 651;
                                stan::math::assign(state, eta);
                                current_statement_begin__ = 652;
                                if (as_bool(logical_gt(statei,(2 + nlatentpop)))) {

                                    current_statement_begin__ = 653;
                                    stan::math::assign(state, add(state, minus(stan::model::rvalue(sigpoints, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni((statei - (2 + nlatentpop))), stan::model::nil_index_list())), "sigpoints"))));
                                } else if (as_bool(logical_gt(statei,2))) {
                                    current_statement_begin__ = 655;
                                    stan::math::assign(state, add(state, stan::model::rvalue(sigpoints, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni((statei - 2)), stan::model::nil_index_list())), "sigpoints")));
                                }
                                current_statement_begin__ = 657;
                                if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {

                                    current_statement_begin__ = 659;
                                    if (as_bool(logical_eq(intoverpop,1))) {

                                        current_statement_begin__ = 660;
                                        for (int ri = 1; ri <= size(matsetup); ++ri) {

                                            current_statement_begin__ = 661;
                                            if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                                current_statement_begin__ = 662;
                                                if (as_bool((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))))) {
                                                    {
                                                    current_statement_begin__ = 663;
                                                    local_scalar_t__ newval;
                                                    (void) newval;  // dummy to suppress unused var warning

                                                    stan::math::initialize(newval, DUMMY_VAR__);
                                                    stan::math::fill(newval,DUMMY_VAR__);


                                                    current_statement_begin__ = 664;
                                                    stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                    current_statement_begin__ = 665;
                                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),1))) {
                                                        current_statement_begin__ = 665;
                                                        stan::model::assign(sT0MEANS, 
                                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                    newval, 
                                                                    "assigning variable sT0MEANS");
                                                    }
                                                    current_statement_begin__ = 666;
                                                    if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),8))) {
                                                        current_statement_begin__ = 666;
                                                        stan::model::assign(sT0VAR, 
                                                                    stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                    newval, 
                                                                    "assigning variable sT0VAR");
                                                    }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    current_statement_begin__ = 671;
                                    stan::model::assign(state, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"), stan::model::rvalue(sT0MEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sT0MEANS")), 
                                                "assigning variable state");
                                }
                                current_statement_begin__ = 674;
                                if (as_bool(logical_eq(intoverpop,1))) {

                                    current_statement_begin__ = 675;
                                    for (int ri = 1; ri <= size(matsetup); ++ri) {

                                        current_statement_begin__ = 676;
                                        if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                            current_statement_begin__ = 677;
                                            if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                                {
                                                current_statement_begin__ = 678;
                                                local_scalar_t__ newval;
                                                (void) newval;  // dummy to suppress unused var warning

                                                stan::math::initialize(newval, DUMMY_VAR__);
                                                stan::math::fill(newval,DUMMY_VAR__);


                                                current_statement_begin__ = 679;
                                                stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                current_statement_begin__ = 680;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),9))) {
                                                    current_statement_begin__ = 680;
                                                    stan::model::assign(sTDPREDEFFECT, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sTDPREDEFFECT");
                                                }
                                                }
                                            }
                                        }
                                    }
                                }
                                current_statement_begin__ = 685;
                                if (as_bool(logical_gt(ntdpred,0))) {
                                    current_statement_begin__ = 685;
                                    stan::model::assign(state, 
                                                stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"), multiply(sTDPREDEFFECT,get_base1(tdpreds,rowi,"tdpreds",1))), 
                                                "assigning variable state");
                                }
                                current_statement_begin__ = 686;
                                stan::model::assign(ukfstates, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            state, 
                                            "assigning variable ukfstates");
                                current_statement_begin__ = 687;
                                if (as_bool((primitive_value(logical_eq(statei,2)) && primitive_value(logical_eq(ukffull,1))))) {
                                    current_statement_begin__ = 687;
                                    stan::model::assign(ukfstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                state, 
                                                "assigning variable ukfstates");
                                }
                            }
                            current_statement_begin__ = 690;
                            if (as_bool(logical_eq(ukffull,1))) {

                                current_statement_begin__ = 691;
                                stan::math::assign(eta, colMeans(transpose(ukfstates), pstream__));
                                current_statement_begin__ = 692;
                                stan::math::assign(etacov, divide(cov_of_matrix(transpose(ukfstates), pstream__),asquared));
                            }
                            current_statement_begin__ = 694;
                            if (as_bool(logical_eq(ukffull,0))) {

                                current_statement_begin__ = 695;
                                stan::math::assign(eta, stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"));
                                current_statement_begin__ = 696;
                                stan::math::assign(etacov, divide(divide(tcrossprod(subtract(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(3, (nlatentpop + 2)), stan::model::nil_index_list())), "ukfstates"),rep_matrix(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"),nlatentpop))),asquared),(nlatentpop + 0.5)));
                            }
                        }
                    }
                    current_statement_begin__ = 702;
                    if (as_bool(logical_eq(savescores,1))) {
                        current_statement_begin__ = 702;
                        stan::model::assign(kout, 
                                    stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(((nmanifest * 4) + 1), ((nmanifest * 4) + nlatentpop)), stan::model::nil_index_list())), 
                                    eta, 
                                    "assigning variable kout");
                    }
                    current_statement_begin__ = 703;
                    if (as_bool(logical_gt(verbose,1))) {
                        current_statement_begin__ = 703;
                        if (pstream__) {
                            stan_print(pstream__,"etaprior = ");
                            stan_print(pstream__,eta);
                            stan_print(pstream__," etapriorcov = ");
                            stan_print(pstream__,etacov);
                            *pstream__ << std::endl;
                        }
                    }
                    current_statement_begin__ = 705;
                    if (as_bool((primitive_value(logical_eq(intoverstates,0)) && primitive_value(logical_eq(nldynamics,0))))) {

                        current_statement_begin__ = 706;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),1))) {
                            current_statement_begin__ = 706;
                            stan::math::assign(eta, add(eta, multiply(cholesky_decompose(sT0VAR),stan::model::rvalue(etaupdbasestates, stan::model::cons_list(stan::model::index_min_max((1 + ((rowi - 1) * nlatent)), (rowi * nlatent)), stan::model::nil_index_list()), "etaupdbasestates"))));
                        }
                        current_statement_begin__ = 707;
                        if (as_bool(logical_eq(get_base1(T0check,rowi,"T0check",1),0))) {
                            current_statement_begin__ = 707;
                            stan::math::assign(eta, add(eta, multiply(discreteDIFFUSION,stan::model::rvalue(etaupdbasestates, stan::model::cons_list(stan::model::index_min_max((1 + ((rowi - 1) * nlatent)), (rowi * nlatent)), stan::model::nil_index_list()), "etaupdbasestates"))));
                        }
                    }
                    current_statement_begin__ = 710;
                    if (as_bool(logical_gt(get_base1(nobs_y,rowi,"nobs_y",1),0))) {
                        {
                        current_statement_begin__ = 712;
                        validate_non_negative_index("o", "get_base1(nobs_y,rowi,\"nobs_y\",1)", get_base1(nobs_y,rowi,"nobs_y",1));
                        vector<int> o(get_base1(nobs_y,rowi,"nobs_y",1), 0);
                        stan::math::fill(o, std::numeric_limits<int>::min());
                        stan::math::assign(o,stan::model::rvalue(whichobs_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nobs_y,rowi,"nobs_y",1)), stan::model::nil_index_list())), "whichobs_y"));
                        current_statement_begin__ = 713;
                        validate_non_negative_index("o1", "get_base1(nbinary_y,rowi,\"nbinary_y\",1)", get_base1(nbinary_y,rowi,"nbinary_y",1));
                        vector<int> o1(get_base1(nbinary_y,rowi,"nbinary_y",1), 0);
                        stan::math::fill(o1, std::numeric_limits<int>::min());
                        stan::math::assign(o1,stan::model::rvalue(whichbinary_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nbinary_y,rowi,"nbinary_y",1)), stan::model::nil_index_list())), "whichbinary_y"));
                        current_statement_begin__ = 714;
                        validate_non_negative_index("o0", "get_base1(ncont_y,rowi,\"ncont_y\",1)", get_base1(ncont_y,rowi,"ncont_y",1));
                        vector<int> o0(get_base1(ncont_y,rowi,"ncont_y",1), 0);
                        stan::math::fill(o0, std::numeric_limits<int>::min());
                        stan::math::assign(o0,stan::model::rvalue(whichcont_y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max(1, get_base1(ncont_y,rowi,"ncont_y",1)), stan::model::nil_index_list())), "whichcont_y"));


                        current_statement_begin__ = 716;
                        if (as_bool(logical_eq(nlmeasurement,0))) {

                            current_statement_begin__ = 719;
                            if (as_bool(logical_eq(intoverstates,1))) {

                                current_statement_begin__ = 720;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"))), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 721;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                                    current_statement_begin__ = 721;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), 
                                                to_vector(inv_logit(to_array_1d(add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta")))))), 
                                                "assigning variable ypred");
                                }
                                current_statement_begin__ = 722;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(quad_form(stan::model::rvalue(etacov, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list())), "etacov"),transpose(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"))),stan::model::rvalue(sMANIFESTVAR, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "sMANIFESTVAR")), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 723;
                                for (int wi = 1; wi <= nmanifest; ++wi) {

                                    current_statement_begin__ = 724;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),1)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 724;
                                        stan::model::assign(ypredcov, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), "ypredcov") + stan::math::fabs(((get_base1(ypred,wi,"ypred",1) - 1) * get_base1(ypred,wi,"ypred",1)))), 
                                                    "assigning variable ypredcov");
                                    }
                                    current_statement_begin__ = 725;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),2)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 725;
                                        stan::model::assign(ypredcov, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(wi), stan::model::nil_index_list())), "ypredcov") + square(stan::math::fabs((get_base1(ypred,wi,"ypred",1) - stan::math::round(get_base1(ypred,wi,"ypred",1)))))), 
                                                    "assigning variable ypredcov");
                                    }
                                }
                                current_statement_begin__ = 727;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(multiply(etacov,append_row(transpose(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA")),stan::model::rvalue(rep_matrix(0,(nlatentpop - nlatent),nmanifest), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "rep_matrix(0,(nlatentpop - nlatent),nmanifest)"))),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                                current_statement_begin__ = 728;
                                stan::math::assign(etacov, add(etacov, multiply(multiply(minus(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K")),append_col(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(rep_matrix(0,nmanifest,(nlatentpop - nlatent)), stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "rep_matrix(0,nmanifest,(nlatentpop - nlatent))"))),etacov)));
                            }
                            current_statement_begin__ = 730;
                            if (as_bool(logical_eq(intoverstates,0))) {

                                current_statement_begin__ = 731;
                                if (as_bool(logical_gt(get_base1(ncont_y,rowi,"ncont_y",1),0))) {

                                    current_statement_begin__ = 732;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list()), 
                                                add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta"))), 
                                                "assigning variable ypred");
                                    current_statement_begin__ = 733;
                                    stan::model::assign(ypredcov_sqrt, 
                                                stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                                stan::math::sqrt(stan::model::rvalue(sMANIFESTVAR, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "sMANIFESTVAR")), 
                                                "assigning variable ypredcov_sqrt");
                                }
                                current_statement_begin__ = 735;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                                    current_statement_begin__ = 735;
                                    stan::model::assign(ypred, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), 
                                                to_vector(inv_logit(to_array_1d(add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(stan::model::rvalue(sLAMBDA, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "sLAMBDA"),stan::model::rvalue(eta, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "eta")))))), 
                                                "assigning variable ypred");
                                }
                            }
                        }
                        current_statement_begin__ = 740;
                        if (as_bool(logical_eq(nlmeasurement,1))) {
                            {
                            current_statement_begin__ = 741;
                            validate_non_negative_index("merrorstates", "nmanifest", nmanifest);
                            validate_non_negative_index("merrorstates", "cols(ukfmeasures)", cols(ukfmeasures));
                            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  merrorstates(static_cast<Eigen::VectorXd::Index>(nmanifest),static_cast<Eigen::VectorXd::Index>(cols(ukfmeasures)));
                            (void) merrorstates;  // dummy to suppress unused var warning

                            stan::math::initialize(merrorstates, DUMMY_VAR__);
                            stan::math::fill(merrorstates,DUMMY_VAR__);


                            current_statement_begin__ = 743;
                            for (int statei = 2; statei <= cols(ukfmeasures); ++statei) {

                                current_statement_begin__ = 744;
                                stan::math::assign(state, stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "ukfstates"));
                                current_statement_begin__ = 746;
                                if (as_bool(logical_eq(intoverpop,1))) {

                                    current_statement_begin__ = 747;
                                    for (int ri = 1; ri <= size(matsetup); ++ri) {

                                        current_statement_begin__ = 748;
                                        if (as_bool((primitive_value(logical_gt(get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2),0)) && primitive_value((primitive_value(logical_eq(statei,0)) || primitive_value(logical_eq(statei,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2))))))))) {

                                            current_statement_begin__ = 749;
                                            if (as_bool((primitive_value((primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2)) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5)))) || primitive_value(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))))) {
                                                {
                                                current_statement_begin__ = 750;
                                                local_scalar_t__ newval;
                                                (void) newval;  // dummy to suppress unused var warning

                                                stan::math::initialize(newval, DUMMY_VAR__);
                                                stan::math::fill(newval,DUMMY_VAR__);


                                                current_statement_begin__ = 751;
                                                stan::math::assign(newval, tform(get_base1(state,(nlatent + get_base1(get_base1(matsetup,ri,"matsetup",1),5,"matsetup",2)),"state",1),get_base1(get_base1(matsetup,ri,"matsetup",1),4,"matsetup",2),get_base1(get_base1(matvalues,ri,"matvalues",1),2,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),3,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),4,"matvalues",2),get_base1(get_base1(matvalues,ri,"matvalues",1),6,"matvalues",2), pstream__));
                                                current_statement_begin__ = 752;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),2))) {
                                                    current_statement_begin__ = 752;
                                                    stan::model::assign(sLAMBDA, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sLAMBDA");
                                                }
                                                current_statement_begin__ = 753;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),5))) {
                                                    current_statement_begin__ = 753;
                                                    stan::model::assign(sMANIFESTVAR, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sMANIFESTVAR");
                                                }
                                                current_statement_begin__ = 754;
                                                if (as_bool(logical_eq(get_base1(get_base1(matsetup,ri,"matsetup",1),7,"matsetup",2),6))) {
                                                    current_statement_begin__ = 754;
                                                    stan::model::assign(sMANIFESTMEANS, 
                                                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),1,"matsetup",2)), stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(matsetup,ri,"matsetup",1),2,"matsetup",2)), stan::model::nil_index_list())), 
                                                                newval, 
                                                                "assigning variable sMANIFESTMEANS");
                                                }
                                                }
                                            }
                                        }
                                    }
                                }
                                current_statement_begin__ = 761;
                                stan::model::assign(ukfmeasures, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            add(stan::model::rvalue(sMANIFESTMEANS, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "sMANIFESTMEANS"),multiply(sLAMBDA,stan::model::rvalue(state, stan::model::cons_list(stan::model::index_min_max(1, nlatent), stan::model::nil_index_list()), "state"))), 
                                            "assigning variable ukfmeasures");
                                current_statement_begin__ = 762;
                                if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {

                                    current_statement_begin__ = 763;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(to_vector(inv_logit(to_array_1d(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o1), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "ukfmeasures"))))), 
                                                "assigning variable ukfmeasures");
                                }
                                current_statement_begin__ = 766;
                                stan::model::assign(merrorstates, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                            stan::math::sqrt(diagonal(sMANIFESTVAR)), 
                                            "assigning variable merrorstates");
                                current_statement_begin__ = 767;
                                for (int wi = 1; wi <= nmanifest; ++wi) {

                                    current_statement_begin__ = 768;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),1)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 768;
                                        stan::model::assign(merrorstates, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "merrorstates") + stan::math::fabs(((get_base1(ukfmeasures,wi,statei,"ukfmeasures",1) - 1) * get_base1(ukfmeasures,wi,statei,"ukfmeasures",1)))), 
                                                    "assigning variable merrorstates");
                                    }
                                    current_statement_begin__ = 769;
                                    if (as_bool((primitive_value(logical_eq(get_base1(manifesttype,wi,"manifesttype",1),2)) && primitive_value(logical_neq(get_base1(get_base1(Y,rowi,"Y",1),wi,"Y",2),99999))))) {
                                        current_statement_begin__ = 769;
                                        stan::model::assign(merrorstates, 
                                                    stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), 
                                                    (stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_uni(wi), stan::model::cons_list(stan::model::index_uni(statei), stan::model::nil_index_list())), "merrorstates") + square(stan::math::fabs((get_base1(ukfmeasures,wi,statei,"ukfmeasures",1) - stan::math::round(get_base1(ukfmeasures,wi,statei,"ukfmeasures",1)))))), 
                                                    "assigning variable merrorstates");
                                    }
                                }
                                current_statement_begin__ = 772;
                                if (as_bool((primitive_value(logical_eq(statei,2)) && primitive_value(logical_eq(ukffull,1))))) {

                                    current_statement_begin__ = 773;
                                    stan::model::assign(merrorstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "merrorstates")), 
                                                "assigning variable merrorstates");
                                    current_statement_begin__ = 774;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                                                stan::model::deep_copy(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures")), 
                                                "assigning variable ukfmeasures");
                                }
                            }
                            current_statement_begin__ = 777;
                            if (as_bool(logical_eq(ukffull,1))) {

                                current_statement_begin__ = 778;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            colMeans(transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 779;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(divide(cov_of_matrix(transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__),asquared),diag_matrix(colMeans(transpose(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "merrorstates")), pstream__))), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 780;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(divide(crosscov(transpose(ukfstates),transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "ukfmeasures")), pstream__),asquared),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                            }
                            current_statement_begin__ = 782;
                            if (as_bool(logical_eq(ukffull,0))) {

                                current_statement_begin__ = 783;
                                stan::model::assign(ypred, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                            stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures"), 
                                            "assigning variable ypred");
                                current_statement_begin__ = 784;
                                for (int ci = 3; ci <= cols(ukfmeasures); ++ci) {
                                    current_statement_begin__ = 784;
                                    stan::model::assign(ukfmeasures, 
                                                stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), "ukfmeasures"), minus(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfmeasures"))), 
                                                "assigning variable ukfmeasures");
                                }
                                current_statement_begin__ = 785;
                                for (int ci = 3; ci <= cols(ukfstates); ++ci) {
                                    current_statement_begin__ = 785;
                                    stan::model::assign(ukfstates, 
                                                stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), 
                                                add(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list())), "ukfstates"), minus(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "ukfstates"))), 
                                                "assigning variable ukfstates");
                                }
                                current_statement_begin__ = 786;
                                stan::model::assign(ypredcov, 
                                            stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            add(divide(divide(tcrossprod(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_min_max(3, (nlatentpop + 2)), stan::model::nil_index_list())), "ukfmeasures")),asquared),(nlatentpop + 0.5)),diag_matrix(stan::model::rvalue(merrorstates, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), "merrorstates"))), 
                                            "assigning variable ypredcov");
                                current_statement_begin__ = 787;
                                stan::model::assign(K, 
                                            stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), 
                                            mdivide_right(divide(divide(multiply(stan::model::rvalue(ukfstates, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(3, cols(ukfstates)), stan::model::nil_index_list())), "ukfstates"),transpose(stan::model::rvalue(ukfmeasures, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_min_max(3, cols(ukfmeasures)), stan::model::nil_index_list())), "ukfmeasures"))),asquared),(nlatentpop + 0.5)),stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov")), 
                                            "assigning variable K");
                            }
                            current_statement_begin__ = 789;
                            stan::math::assign(etacov, add(etacov, minus(quad_form(stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "ypredcov"),transpose(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K"))))));
                            }
                        }
                        current_statement_begin__ = 793;
                        stan::model::assign(err, 
                                    stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), 
                                    subtract(stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "Y"),stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "ypred")), 
                                    "assigning variable err");
                        current_statement_begin__ = 795;
                        if (as_bool(logical_eq(savescores,1))) {
                            {
                            current_statement_begin__ = 796;
                            validate_non_negative_index("tmpindex", "get_base1(nobs_y,rowi,\"nobs_y\",1)", get_base1(nobs_y,rowi,"nobs_y",1));
                            vector<int> tmpindex(get_base1(nobs_y,rowi,"nobs_y",1), 0);
                            stan::math::fill(tmpindex, std::numeric_limits<int>::min());
                            stan::math::assign(tmpindex,o);


                            current_statement_begin__ = 797;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 797;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + (nmanifest * 2)), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 798;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "err"), 
                                        "assigning variable kout");
                            current_statement_begin__ = 799;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 799;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + nmanifest), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 800;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "ypred"), 
                                        "assigning variable kout");
                            }
                        }
                        current_statement_begin__ = 802;
                        if (as_bool(logical_eq(intoverstates,1))) {
                            current_statement_begin__ = 802;
                            stan::math::assign(eta, add(eta, multiply(stan::model::rvalue(K, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list())), "K"),stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o), stan::model::nil_index_list()), "err"))));
                        }
                        current_statement_begin__ = 804;
                        if (as_bool(logical_gt(get_base1(nbinary_y,rowi,"nbinary_y",1),0))) {
                            current_statement_begin__ = 804;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), 
                                        add(elt_multiply(stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "Y"),stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), "ypred")),elt_multiply(subtract(1,stan::model::rvalue(Y, stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "Y")),subtract(1,stan::model::rvalue(ypred, stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list()), "ypred")))), 
                                        "assigning variable kout");
                        }
                        current_statement_begin__ = 806;
                        if (as_bool(logical_gt(verbose,1))) {

                            current_statement_begin__ = 807;
                            if (pstream__) {
                                stan_print(pstream__,"rowi ");
                                stan_print(pstream__,rowi);
                                stan_print(pstream__,"  si ");
                                stan_print(pstream__,si);
                                stan_print(pstream__,"  eta ");
                                stan_print(pstream__,eta);
                                stan_print(pstream__,"  etacov ");
                                stan_print(pstream__,etacov);
                                stan_print(pstream__,"  ypred ");
                                stan_print(pstream__,ypred);
                                stan_print(pstream__,"  ypredcov ");
                                stan_print(pstream__,ypredcov);
                                stan_print(pstream__,"  K ");
                                stan_print(pstream__,K);
                                stan_print(pstream__,"  sDRIFT ");
                                stan_print(pstream__,sDRIFT);
                                stan_print(pstream__," sDIFFUSION ");
                                stan_print(pstream__,sDIFFUSION);
                                stan_print(pstream__," sCINT ");
                                stan_print(pstream__,sCINT);
                                stan_print(pstream__,"  sMANIFESTVAR ");
                                stan_print(pstream__,diagonal(sMANIFESTVAR));
                                stan_print(pstream__,"  sMANIFESTMEANS ");
                                stan_print(pstream__,sMANIFESTMEANS);
                                stan_print(pstream__,"  sT0VAR");
                                stan_print(pstream__,sT0VAR);
                                stan_print(pstream__," sT0MEANS ");
                                stan_print(pstream__,sT0MEANS);
                                stan_print(pstream__,"discreteDRIFT ");
                                stan_print(pstream__,discreteDRIFT);
                                stan_print(pstream__,"  discreteDIFFUSION ");
                                stan_print(pstream__,discreteDIFFUSION);
                                stan_print(pstream__,"  sasymDIFFUSION ");
                                stan_print(pstream__,sasymDIFFUSION);
                                stan_print(pstream__,"  rawpopsd ");
                                stan_print(pstream__,rawpopsd);
                                stan_print(pstream__,"  rawpopsdbase ");
                                stan_print(pstream__,rawpopsdbase);
                                stan_print(pstream__,"  rawpopmeans ");
                                stan_print(pstream__,rawpopmeans);
                                *pstream__ << std::endl;
                            }
                        }
                        current_statement_begin__ = 814;
                        if (as_bool(logical_gt(verbose,2))) {
                            current_statement_begin__ = 814;
                            if (pstream__) {
                                stan_print(pstream__,"ukfstates ");
                                stan_print(pstream__,ukfstates);
                                stan_print(pstream__,"  ukfmeasures ");
                                stan_print(pstream__,ukfmeasures);
                                *pstream__ << std::endl;
                            }
                        }
                        current_statement_begin__ = 816;
                        if (as_bool(logical_gt(size(o0),0))) {
                            {
                            current_statement_begin__ = 817;
                            validate_non_negative_index("tmpindex", "get_base1(ncont_y,rowi,\"ncont_y\",1)", get_base1(ncont_y,rowi,"ncont_y",1));
                            vector<int> tmpindex(get_base1(ncont_y,rowi,"ncont_y",1), 0);
                            stan::math::fill(tmpindex, std::numeric_limits<int>::min());
                            stan::math::assign(tmpindex,o0);


                            current_statement_begin__ = 818;
                            for (int oi = 1; oi <= get_base1(ncont_y,rowi,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 818;
                                stan::model::assign(tmpindex, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(tmpindex, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "tmpindex") + nmanifest), 
                                            "assigning variable tmpindex");
                            }
                            current_statement_begin__ = 819;
                            if (as_bool(logical_eq(intoverstates,1))) {
                                current_statement_begin__ = 819;
                                stan::model::assign(ypredcov_sqrt, 
                                            stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                            cholesky_decompose(makesym(stan::model::rvalue(ypredcov, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov"),verbose,1, pstream__)), 
                                            "assigning variable ypredcov_sqrt");
                            }
                            current_statement_begin__ = 820;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), 
                                        mdivide_left_tri_low(stan::model::rvalue(ypredcov_sqrt, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov_sqrt"),stan::model::rvalue(err, stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list()), "err")), 
                                        "assigning variable kout");
                            current_statement_begin__ = 821;
                            stan::model::assign(kout, 
                                        stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_multi(tmpindex), stan::model::nil_index_list())), 
                                        stan::math::log(diagonal(stan::model::rvalue(ypredcov_sqrt, stan::model::cons_list(stan::model::index_multi(o0), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "ypredcov_sqrt"))), 
                                        "assigning variable kout");
                            }
                        }
                        }
                    }
                    current_statement_begin__ = 825;
                    if (as_bool(logical_eq(savescores,1))) {
                        current_statement_begin__ = 825;
                        stan::model::assign(kout, 
                                    stan::model::cons_list(stan::model::index_uni(rowi), stan::model::cons_list(stan::model::index_min_max((((nmanifest * 4) + nlatentpop) + 1), (((nmanifest * 4) + nlatentpop) + nlatentpop)), stan::model::nil_index_list())), 
                                    eta, 
                                    "assigning variable kout");
                    }
                    }
                }
            }
            current_statement_begin__ = 828;
            if (as_bool(logical_eq(dokalman,1))) {

                current_statement_begin__ = 829;
                if (as_bool(logical_gt(sum(nbinary_y),0))) {
                    {
                    current_statement_begin__ = 830;
                    validate_non_negative_index("binaryll", "sum(nbinary_y)", sum(nbinary_y));
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  binaryll(static_cast<Eigen::VectorXd::Index>(sum(nbinary_y)));
                    (void) binaryll;  // dummy to suppress unused var warning

                    stan::math::initialize(binaryll, DUMMY_VAR__);
                    stan::math::fill(binaryll,DUMMY_VAR__);


                    current_statement_begin__ = 831;
                    stan::math::assign(counter, 1);
                    current_statement_begin__ = 832;
                    for (int ri = 1; ri <= ndatapoints; ++ri) {

                        current_statement_begin__ = 833;
                        if (as_bool(logical_eq(get_base1(dokalmanrows,ri,"dokalmanrows",1),1))) {
                            {
                            current_statement_begin__ = 834;
                            validate_non_negative_index("o1", "get_base1(nbinary_y,ri,\"nbinary_y\",1)", get_base1(nbinary_y,ri,"nbinary_y",1));
                            vector<int> o1(get_base1(nbinary_y,ri,"nbinary_y",1), 0);
                            stan::math::fill(o1, std::numeric_limits<int>::min());
                            stan::math::assign(o1,stan::model::rvalue(whichbinary_y, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_min_max(1, get_base1(nbinary_y,ri,"nbinary_y",1)), stan::model::nil_index_list())), "whichbinary_y"));


                            current_statement_begin__ = 835;
                            stan::model::assign(binaryll, 
                                        stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(nbinary_y,ri,"nbinary_y",1)) - 1)), stan::model::nil_index_list()), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o1), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable binaryll");
                            current_statement_begin__ = 836;
                            stan::math::assign(counter, (counter + get_base1(nbinary_y,ri,"nbinary_y",1)));
                            }
                        }
                    }
                    current_statement_begin__ = 839;
                    stan::math::assign(ll, (ll + sum(stan::math::log(stan::model::rvalue(binaryll, stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list()), "binaryll")))));
                    }
                }
                current_statement_begin__ = 842;
                if (as_bool(logical_gt(sum(ncont_y),0))) {
                    {
                    current_statement_begin__ = 843;
                    validate_non_negative_index("errtrans", "sum(ncont_y)", sum(ncont_y));
                    validate_non_negative_index("errtrans", "2", 2);
                    vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > errtrans(2, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(sum(ncont_y)))));
                    stan::math::initialize(errtrans, DUMMY_VAR__);
                    stan::math::fill(errtrans,DUMMY_VAR__);


                    current_statement_begin__ = 844;
                    stan::math::assign(counter, 1);
                    current_statement_begin__ = 845;
                    for (int ri = 1; ri <= ndatapoints; ++ri) {

                        current_statement_begin__ = 846;
                        if (as_bool(logical_eq(get_base1(dokalmanrows,ri,"dokalmanrows",1),1))) {
                            {
                            current_statement_begin__ = 847;
                            validate_non_negative_index("o0", "get_base1(ncont_y,ri,\"ncont_y\",1)", get_base1(ncont_y,ri,"ncont_y",1));
                            vector<int> o0(get_base1(ncont_y,ri,"ncont_y",1), 0);
                            stan::math::fill(o0, std::numeric_limits<int>::min());
                            stan::math::assign(o0,stan::model::rvalue(whichcont_y, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_min_max(1, get_base1(ncont_y,ri,"ncont_y",1)), stan::model::nil_index_list())), "whichcont_y"));


                            current_statement_begin__ = 848;
                            stan::model::assign(errtrans, 
                                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(ncont_y,ri,"ncont_y",1)) - 1)), stan::model::nil_index_list())), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable errtrans");
                            current_statement_begin__ = 849;
                            for (int oi = 1; oi <= get_base1(ncont_y,ri,"ncont_y",1); ++oi) {
                                current_statement_begin__ = 849;
                                stan::model::assign(o0, 
                                            stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), 
                                            (stan::model::rvalue(o0, stan::model::cons_list(stan::model::index_uni(oi), stan::model::nil_index_list()), "o0") + nmanifest), 
                                            "assigning variable o0");
                            }
                            current_statement_begin__ = 850;
                            stan::model::assign(errtrans, 
                                        stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_min_max(counter, ((counter + get_base1(ncont_y,ri,"ncont_y",1)) - 1)), stan::model::nil_index_list())), 
                                        stan::model::rvalue(kout, stan::model::cons_list(stan::model::index_uni(ri), stan::model::cons_list(stan::model::index_multi(o0), stan::model::nil_index_list())), "kout"), 
                                        "assigning variable errtrans");
                            current_statement_begin__ = 851;
                            stan::math::assign(counter, (counter + get_base1(ncont_y,ri,"ncont_y",1)));
                            }
                        }
                    }
                    current_statement_begin__ = 854;
                    stan::math::assign(ll, (ll + (normal_log(stan::model::rvalue(errtrans, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list())), "errtrans"),0,1) - sum(stan::model::rvalue(errtrans, stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_min_max(1, (counter - 1)), stan::model::nil_index_list())), "errtrans")))));
                    }
                }
                current_statement_begin__ = 856;
                if (as_bool(savescores)) {
                    current_statement_begin__ = 856;
                    stan::math::assign(kalman, kout);
                }
            }
            }

            // validate transformed parameters
            current_statement_begin__ = 274;
            current_statement_begin__ = 275;
            current_statement_begin__ = 276;
            current_statement_begin__ = 277;
            current_statement_begin__ = 278;
            current_statement_begin__ = 279;
            current_statement_begin__ = 280;
            current_statement_begin__ = 281;
            current_statement_begin__ = 282;
            current_statement_begin__ = 283;
            current_statement_begin__ = 284;
            current_statement_begin__ = 285;
            current_statement_begin__ = 286;
            current_statement_begin__ = 288;
            current_statement_begin__ = 289;
            current_statement_begin__ = 292;
            current_statement_begin__ = 293;
            current_statement_begin__ = 294;
            current_statement_begin__ = 295;
            current_statement_begin__ = 296;
            current_statement_begin__ = 297;
            current_statement_begin__ = 298;
            current_statement_begin__ = 299;
            current_statement_begin__ = 300;
            current_statement_begin__ = 302;
            current_statement_begin__ = 303;
            current_statement_begin__ = 307;
            current_statement_begin__ = 308;

            // write transformed parameters
            if (include_tparams__) {
            for (int k_0__ = 0; k_0__ < nindvarying; ++k_0__) {
            vars__.push_back(rawpopsd[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < nindvarying; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nindvarying; ++k_0__) {
                vars__.push_back(rawpopcovsqrt(k_0__, k_1__));
                }
            }
        vars__.push_back(ll);
            for (int k_1__ = 0; k_1__ < ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )); ++k_1__) {
                for (int k_0__ = 0; k_0__ < (savescores ? ndatapoints : 0 ); ++k_0__) {
                vars__.push_back(kalman[k_0__][k_1__]);
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1); ++k_0__) {
                    vars__.push_back(T0MEANS[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1); ++k_0__) {
                    vars__.push_back(LAMBDA[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1); ++k_0__) {
                    vars__.push_back(DRIFT[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1); ++k_0__) {
                    vars__.push_back(DIFFUSION[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1); ++k_0__) {
                    vars__.push_back(MANIFESTVAR[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1); ++k_0__) {
                    vars__.push_back(MANIFESTMEANS[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(CINTsubindex,nsubjects,"CINTsubindex",1); ++k_0__) {
                    vars__.push_back(CINT[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1); ++k_0__) {
                    vars__.push_back(T0VAR[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1); ++k_0__) {
                    vars__.push_back(TDPREDEFFECT[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < nlatent; ++k_2__) {
                for (int k_1__ = 0; k_1__ < nlatent; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1); ++k_0__) {
                    vars__.push_back(asymDIFFUSION[k_0__](k_1__, k_2__));
                    }
                }
            }
            for (int k_1__ = 0; k_1__ < (nt0meansstationary ? nlatent : 0 ); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1); ++k_0__) {
                vars__.push_back(asymCINT[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_T0MEANS(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_LAMBDA(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_DRIFT(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_DIFFUSION(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_MANIFESTVAR(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_MANIFESTMEANS(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_CINT(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_T0VAR(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 0; k_0__ < get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                vars__.push_back(pop_TDPREDEFFECT(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < nlatent; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nlatent; ++k_0__) {
                vars__.push_back(pop_asymDIFFUSION(k_0__, k_1__));
                }
            }
            for (int k_0__ = 0; k_0__ < (nt0meansstationary ? nlatent : 0 ); ++k_0__) {
            vars__.push_back(pop_asymCINT[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < (ntipred ? ntipred : 0 ); ++k_1__) {
                for (int k_0__ = 0; k_0__ < (ntipred ? nsubjects : 0 ); ++k_0__) {
                vars__.push_back(tipreds(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < ntipred; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nparams; ++k_0__) {
                vars__.push_back(TIPREDEFFECT(k_0__, k_1__));
                }
            }
            }
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 889;
            validate_non_negative_index("popmeans", "nparams", nparams);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  popmeans(static_cast<Eigen::VectorXd::Index>(nparams));
            (void) popmeans;  // dummy to suppress unused var warning

            stan::math::initialize(popmeans, DUMMY_VAR__);
            stan::math::fill(popmeans,DUMMY_VAR__);
            current_statement_begin__ = 890;
            validate_non_negative_index("popsd", "nparams", nparams);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  popsd(static_cast<Eigen::VectorXd::Index>(nparams));
            (void) popsd;  // dummy to suppress unused var warning

            stan::math::initialize(popsd, DUMMY_VAR__);
            stan::math::fill(popsd,DUMMY_VAR__);
            stan::math::assign(popsd,rep_vector(0,nparams));
            current_statement_begin__ = 891;
            validate_non_negative_index("rawpopcov", "nindvarying", nindvarying);
            validate_non_negative_index("rawpopcov", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  rawpopcov(static_cast<Eigen::VectorXd::Index>(nindvarying),static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopcov;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopcov, DUMMY_VAR__);
            stan::math::fill(rawpopcov,DUMMY_VAR__);
            stan::math::assign(rawpopcov,tcrossprod(rawpopcovsqrt));
            current_statement_begin__ = 892;
            validate_non_negative_index("rawpopcorr", "nindvarying", nindvarying);
            validate_non_negative_index("rawpopcorr", "nindvarying", nindvarying);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  rawpopcorr(static_cast<Eigen::VectorXd::Index>(nindvarying),static_cast<Eigen::VectorXd::Index>(nindvarying));
            (void) rawpopcorr;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopcorr, DUMMY_VAR__);
            stan::math::fill(rawpopcorr,DUMMY_VAR__);
            stan::math::assign(rawpopcorr,quad_form_diag(rawpopcov,inv_sqrt(diagonal(rawpopcov))));
            current_statement_begin__ = 893;
            validate_non_negative_index("linearTIPREDEFFECT", "nparams", nparams);
            validate_non_negative_index("linearTIPREDEFFECT", "ntipred", ntipred);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  linearTIPREDEFFECT(static_cast<Eigen::VectorXd::Index>(nparams),static_cast<Eigen::VectorXd::Index>(ntipred));
            (void) linearTIPREDEFFECT;  // dummy to suppress unused var warning

            stan::math::initialize(linearTIPREDEFFECT, DUMMY_VAR__);
            stan::math::fill(linearTIPREDEFFECT,DUMMY_VAR__);


            {
            current_statement_begin__ = 897;
            validate_non_negative_index("rawpopsdfull", "nparams", nparams);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  rawpopsdfull(static_cast<Eigen::VectorXd::Index>(nparams));
            (void) rawpopsdfull;  // dummy to suppress unused var warning

            stan::math::initialize(rawpopsdfull, DUMMY_VAR__);
            stan::math::fill(rawpopsdfull,DUMMY_VAR__);


            current_statement_begin__ = 898;
            stan::model::assign(rawpopsdfull, 
                        stan::model::cons_list(stan::model::index_multi(indvaryingindex), stan::model::nil_index_list()), 
                        stan::math::sqrt(diagonal(rawpopcov)), 
                        "assigning variable rawpopsdfull");
            current_statement_begin__ = 900;
            for (int ri = 1; ri <= get_base1(dims(popsetup),1,"dims(popsetup)",1); ++ri) {

                current_statement_begin__ = 901;
                if (as_bool(logical_neq(get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),0))) {

                    current_statement_begin__ = 903;
                    stan::model::assign(popmeans, 
                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2)), stan::model::nil_index_list()), 
                                tform(get_base1(rawpopmeans,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopmeans",1),get_base1(get_base1(popsetup,ri,"popsetup",1),4,"popsetup",2),get_base1(get_base1(popvalues,ri,"popvalues",1),2,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),3,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),4,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),6,"popvalues",2), pstream__), 
                                "assigning variable popmeans");
                    current_statement_begin__ = 905;
                    stan::model::assign(popsd, 
                                stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2)), stan::model::nil_index_list()), 
                                (get_base1(get_base1(popsetup,ri,"popsetup",1),5,"popsetup",2) ? stan::math::promote_scalar<local_scalar_t__>((stan::math::fabs((tform((get_base1(rawpopmeans,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopmeans",1) + get_base1(rawpopsdfull,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopsdfull",1)),get_base1(get_base1(popsetup,ri,"popsetup",1),4,"popsetup",2),get_base1(get_base1(popvalues,ri,"popvalues",1),2,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),3,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),4,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),6,"popvalues",2), pstream__) - tform((get_base1(rawpopmeans,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopmeans",1) - get_base1(rawpopsdfull,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopsdfull",1)),get_base1(get_base1(popsetup,ri,"popsetup",1),4,"popsetup",2),get_base1(get_base1(popvalues,ri,"popvalues",1),2,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),3,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),4,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),6,"popvalues",2), pstream__))) / 2)) : stan::math::promote_scalar<local_scalar_t__>(0) ), 
                                "assigning variable popsd");
                    current_statement_begin__ = 912;
                    if (as_bool(logical_gt(ntipred,0))) {

                        current_statement_begin__ = 913;
                        for (int tij = 1; tij <= ntipred; ++tij) {

                            current_statement_begin__ = 914;
                            if (as_bool(logical_eq(get_base1(get_base1(TIPREDEFFECTsetup,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"TIPREDEFFECTsetup",1),tij,"TIPREDEFFECTsetup",2),0))) {

                                current_statement_begin__ = 915;
                                stan::model::assign(linearTIPREDEFFECT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2)), stan::model::cons_list(stan::model::index_uni(tij), stan::model::nil_index_list())), 
                                            0, 
                                            "assigning variable linearTIPREDEFFECT");
                            } else {

                                current_statement_begin__ = 917;
                                stan::model::assign(linearTIPREDEFFECT, 
                                            stan::model::cons_list(stan::model::index_uni(get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2)), stan::model::cons_list(stan::model::index_uni(tij), stan::model::nil_index_list())), 
                                            (((tform((get_base1(rawpopmeans,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopmeans",1) + (get_base1(TIPREDEFFECT,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),tij,"TIPREDEFFECT",1) * 0.01)),get_base1(get_base1(popsetup,ri,"popsetup",1),4,"popsetup",2),get_base1(get_base1(popvalues,ri,"popvalues",1),2,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),3,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),4,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),6,"popvalues",2), pstream__) - tform((get_base1(rawpopmeans,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),"rawpopmeans",1) - (get_base1(TIPREDEFFECT,get_base1(get_base1(popsetup,ri,"popsetup",1),3,"popsetup",2),tij,"TIPREDEFFECT",1) * 0.01)),get_base1(get_base1(popsetup,ri,"popsetup",1),4,"popsetup",2),get_base1(get_base1(popvalues,ri,"popvalues",1),2,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),3,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),4,"popvalues",2),get_base1(get_base1(popvalues,ri,"popvalues",1),6,"popvalues",2), pstream__)) / 2) * 100), 
                                            "assigning variable linearTIPREDEFFECT");
                            }
                        }
                    }
                }
            }
            }

            // validate generated quantities
            current_statement_begin__ = 889;
            current_statement_begin__ = 890;
            current_statement_begin__ = 891;
            current_statement_begin__ = 892;
            current_statement_begin__ = 893;

            // write generated quantities
            for (int k_0__ = 0; k_0__ < nparams; ++k_0__) {
            vars__.push_back(popmeans[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < nparams; ++k_0__) {
            vars__.push_back(popsd[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < nindvarying; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nindvarying; ++k_0__) {
                vars__.push_back(rawpopcov(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < nindvarying; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nindvarying; ++k_0__) {
                vars__.push_back(rawpopcorr(k_0__, k_1__));
                }
            }
            for (int k_1__ = 0; k_1__ < ntipred; ++k_1__) {
                for (int k_0__ = 0; k_0__ < nparams; ++k_0__) {
                vars__.push_back(linearTIPREDEFFECT(k_0__, k_1__));
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_ctsm";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rawpopmeans" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rawpopsdbase" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nindvaryingoffdiagonals; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sqrtpcov" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "baseindparams" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= ntipredeffects; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tipredeffectparams" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nmissingtipreds; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tipredsimputed" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (intoverstates ? 0 : (nlatent * ndatapoints) ); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "etaupdbasestates" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopsd" << '.' << k_0__;
                param_names__.push_back(param_name_stream__.str());
            }
            for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "rawpopcovsqrt" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            param_name_stream__.str(std::string());
            param_name_stream__ << "ll";
            param_names__.push_back(param_name_stream__.str());
            for (int k_1__ = 1; k_1__ <= ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (savescores ? ndatapoints : 0 ); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "kalman" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "T0MEANS" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "LAMBDA" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "DRIFT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "DIFFUSION" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "MANIFESTVAR" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "MANIFESTMEANS" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(CINTsubindex,nsubjects,"CINTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "CINT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "T0VAR" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "TDPREDEFFECT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= nlatent; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= nlatent; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "asymDIFFUSION" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_1__ = 1; k_1__ <= (nt0meansstationary ? nlatent : 0 ); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "asymCINT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_T0MEANS" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_LAMBDA" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_DRIFT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_DIFFUSION" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_MANIFESTVAR" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_MANIFESTMEANS" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_CINT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_T0VAR" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_TDPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= nlatent; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nlatent; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_asymDIFFUSION" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_0__ = 1; k_0__ <= (nt0meansstationary ? nlatent : 0 ); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "pop_asymCINT" << '.' << k_0__;
                param_names__.push_back(param_name_stream__.str());
            }
            for (int k_1__ = 1; k_1__ <= (ntipred ? ntipred : 0 ); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (ntipred ? nsubjects : 0 ); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "tipreds" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= ntipred; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "TIPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }


        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "popmeans" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "popsd" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopcov" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopcorr" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= ntipred; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "linearTIPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rawpopmeans" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "rawpopsdbase" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nindvaryingoffdiagonals; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sqrtpcov" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= (fixedsubpars ? 0 : (intoverpop ? 0 : nindvarying ) ); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (fixedsubpars ? 0 : (intoverpop ? 0 : nsubjects ) ); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "baseindparams" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= ntipredeffects; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tipredeffectparams" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nmissingtipreds; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "tipredsimputed" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (intoverstates ? 0 : (nlatent * ndatapoints) ); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "etaupdbasestates" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopsd" << '.' << k_0__;
                param_names__.push_back(param_name_stream__.str());
            }
            for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "rawpopcovsqrt" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            param_name_stream__.str(std::string());
            param_name_stream__ << "ll";
            param_names__.push_back(param_name_stream__.str());
            for (int k_1__ = 1; k_1__ <= ((nmanifest + nmanifest) + (savescores ? ((nmanifest * 2) + (nlatentpop * 2)) : 0 )); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (savescores ? ndatapoints : 0 ); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "kalman" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(T0MEANSsubindex,nsubjects,"T0MEANSsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "T0MEANS" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(LAMBDAsubindex,nsubjects,"LAMBDAsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "LAMBDA" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(DRIFTsubindex,nsubjects,"DRIFTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "DRIFT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(DIFFUSIONsubindex,nsubjects,"DIFFUSIONsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "DIFFUSION" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(MANIFESTVARsubindex,nsubjects,"MANIFESTVARsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "MANIFESTVAR" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(MANIFESTMEANSsubindex,nsubjects,"MANIFESTMEANSsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "MANIFESTMEANS" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(CINTsubindex,nsubjects,"CINTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "CINT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(T0VARsubindex,nsubjects,"T0VARsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "T0VAR" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_2__) {
                for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(TDPREDEFFECTsubindex,nsubjects,"TDPREDEFFECTsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "TDPREDEFFECT" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_2__ = 1; k_2__ <= nlatent; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= nlatent; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= get_base1(asymDIFFUSIONsubindex,nsubjects,"asymDIFFUSIONsubindex",1); ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "asymDIFFUSION" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
            for (int k_1__ = 1; k_1__ <= (nt0meansstationary ? nlatent : 0 ); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(asymCINTsubindex,nsubjects,"asymCINTsubindex",1); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "asymCINT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,1,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_T0MEANS" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,2,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_LAMBDA" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,3,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_DRIFT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,4,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_DIFFUSION" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,5,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_MANIFESTVAR" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,6,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_MANIFESTMEANS" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,7,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_CINT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,8,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_T0VAR" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),2,"matrixdims",2); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= get_base1(get_base1(matrixdims,9,"matrixdims",1),1,"matrixdims",2); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_TDPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= nlatent; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nlatent; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "pop_asymDIFFUSION" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_0__ = 1; k_0__ <= (nt0meansstationary ? nlatent : 0 ); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "pop_asymCINT" << '.' << k_0__;
                param_names__.push_back(param_name_stream__.str());
            }
            for (int k_1__ = 1; k_1__ <= (ntipred ? ntipred : 0 ); ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (ntipred ? nsubjects : 0 ); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "tipreds" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_1__ = 1; k_1__ <= ntipred; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "TIPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }


        if (!include_gqs__) return;
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "popmeans" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "popsd" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopcov" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= nindvarying; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nindvarying; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "rawpopcorr" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= ntipred; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= nparams; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "linearTIPREDEFFECT" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}

typedef model_ctsm_namespace::model_ctsm stan_model;


#endif
