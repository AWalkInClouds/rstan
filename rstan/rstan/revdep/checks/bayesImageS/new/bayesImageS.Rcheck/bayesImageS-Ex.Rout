
R Under development (unstable) (2019-04-20 r76407) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bayesImageS"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bayesImageS')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("getBlocks")
> ### * getBlocks
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getBlocks
> ### Title: Get Blocks of a Graph
> ### Aliases: getBlocks
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   #Example 1: split a line into 2 blocks
>   getBlocks(mask=c(1,1,1,1,0,0,1,1,0), nblock=2)
[[1]]
[1] 1 3 5

[[2]]
[1] 2 4 6

>   
>   #Example 2: split a 4*4 2D graph into 4 blocks in order
>   #           to use the chequerboard idea for a neighbourhood structure
>   #           corresponding to the second-order Markov random field.
>   getBlocks(mask=matrix(1, nrow=4, ncol=4), nblock=4)
[[1]]
[1]  6  8 14 16

[[2]]
[1]  5  7 13 15

[[3]]
[1]  2  4 10 12

[[4]]
[1]  1  3  9 11

>   
>   #Example 3: split a 3*3*3 3D graph into 8 blocks
>   #           in order to use the chequerboard idea for a neighbourhood
>   #           structure based on the 18 neighbors definition, where the
>   #           neighbors of a vertex comprise its available
>   #           adjacencies sharing the same edges or faces.
>   mask <- array(1, dim=rep(3,3))
>   getBlocks(mask, nblock=8)
[[1]]
[1] 14

[[2]]
[1] 13 15

[[3]]
[1] 11 17

[[4]]
[1] 10 12 16 18

[[5]]
[1]  5 23

[[6]]
[1]  4  6 22 24

[[7]]
[1]  2  8 20 26

[[8]]
[1]  1  3  7  9 19 21 25 27

> 
> 
> 
> cleanEx()
> nameEx("getEdges")
> ### * getEdges
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getEdges
> ### Title: Get Edges of a Graph
> ### Aliases: getEdges
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   #Example 1: get all edges of a 1D graph. 
>   mask <- c(0,0,rep(1,4),0,1,1,0,0)
>   getEdges(mask, neiStruc=2)
     [,1] [,2]
[1,]    1    2
[2,]    2    3
[3,]    3    4
[4,]    5    6
>   
>   #Example 2: get all edges of a 2D graph based on neighbourhood structure
>   #           corresponding to the first-order Markov random field.
>   mask <- matrix(1 ,nrow=2, ncol=3)
>   getEdges(mask, neiStruc=c(2,2,0,0))
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    1    3
[5,]    2    4
[6,]    3    5
[7,]    4    6
>   
>   #Example 3: get all edges of a 2D graph based on neighbourhood structure
>   #           corresponding to the second-order Markov random field.
>   mask <- matrix(1 ,nrow=3, ncol=3)
>   getEdges(mask, neiStruc=c(2,2,2,2))
      [,1] [,2]
 [1,]    1    2
 [2,]    2    3
 [3,]    4    5
 [4,]    5    6
 [5,]    7    8
 [6,]    8    9
 [7,]    1    4
 [8,]    2    5
 [9,]    3    6
[10,]    4    7
[11,]    5    8
[12,]    6    9
[13,]    1    5
[14,]    2    6
[15,]    4    8
[16,]    5    9
[17,]    2    4
[18,]    3    5
[19,]    5    7
[20,]    6    8
>   
>   #Example 4: get all edges of a 3D graph based on 6 neighbours structure
>   #           where the neighbours of a vertex comprise its available
>   #           N,S,E,W, upper and lower adjacencies. To achieve it, there
>   #           are several ways, including the two below.
>   mask <- array(1, dim=rep(3,3))
>   n61 <- matrix(c(2,2,0,0,
+                   0,2,0,0,
+                   0,0,0,0), nrow=3, byrow=TRUE)
>   n62 <- matrix(c(2,0,0,0,
+                   0,2,0,0,
+                   2,0,0,0), nrow=3, byrow=TRUE)
>   e1 <- getEdges(mask, neiStruc=n61)
>   e2 <- getEdges(mask, neiStruc=n62)
>   e1 <- e1[order(e1[,1], e1[,2]),]
>   e2 <- e2[order(e2[,1], e2[,2]),]
>   all(e1==e2)
[1] TRUE
>   
>   #Example 5: get all edges of a 3D graph based on 18 neighbours structure
>   #           where the neighbours of a vertex comprise its available
>   #           adjacencies sharing the same edges or faces.
>   #           To achieve it, there are several ways, including the one below.
>   
>   n18 <- matrix(c(2,2,2,2,
+                   0,2,2,2,
+                   0,0,2,2), nrow=3, byrow=TRUE)  
>   mask <- array(1, dim=rep(3,3))
>   getEdges(mask, neiStruc=n18)
       [,1] [,2]
  [1,]    1    2
  [2,]    2    3
  [3,]    4    5
  [4,]    5    6
  [5,]    7    8
  [6,]    8    9
  [7,]   10   11
  [8,]   11   12
  [9,]   13   14
 [10,]   14   15
 [11,]   16   17
 [12,]   17   18
 [13,]   19   20
 [14,]   20   21
 [15,]   22   23
 [16,]   23   24
 [17,]   25   26
 [18,]   26   27
 [19,]    1    4
 [20,]    2    5
 [21,]    3    6
 [22,]    4    7
 [23,]    5    8
 [24,]    6    9
 [25,]   10   13
 [26,]   11   14
 [27,]   12   15
 [28,]   13   16
 [29,]   14   17
 [30,]   15   18
 [31,]   19   22
 [32,]   20   23
 [33,]   21   24
 [34,]   22   25
 [35,]   23   26
 [36,]   24   27
 [37,]    1    5
 [38,]    2    6
 [39,]    4    8
 [40,]    5    9
 [41,]   10   14
 [42,]   11   15
 [43,]   13   17
 [44,]   14   18
 [45,]   19   23
 [46,]   20   24
 [47,]   22   26
 [48,]   23   27
 [49,]    2    4
 [50,]    3    5
 [51,]    5    7
 [52,]    6    8
 [53,]   11   13
 [54,]   12   14
 [55,]   14   16
 [56,]   15   17
 [57,]   20   22
 [58,]   21   23
 [59,]   23   25
 [60,]   24   26
 [61,]    1   10
 [62,]    2   11
 [63,]    3   12
 [64,]    4   13
 [65,]    5   14
 [66,]    6   15
 [67,]    7   16
 [68,]    8   17
 [69,]    9   18
 [70,]   10   19
 [71,]   11   20
 [72,]   12   21
 [73,]   13   22
 [74,]   14   23
 [75,]   15   24
 [76,]   16   25
 [77,]   17   26
 [78,]   18   27
 [79,]    1   11
 [80,]    2   12
 [81,]    4   14
 [82,]    5   15
 [83,]    7   17
 [84,]    8   18
 [85,]   10   20
 [86,]   11   21
 [87,]   13   23
 [88,]   14   24
 [89,]   16   26
 [90,]   17   27
 [91,]    2   10
 [92,]    3   11
 [93,]    5   13
 [94,]    6   14
 [95,]    8   16
 [96,]    9   17
 [97,]   11   19
 [98,]   12   20
 [99,]   14   22
[100,]   15   23
[101,]   17   25
[102,]   18   26
[103,]    1   13
[104,]    2   14
[105,]    3   15
[106,]    4   16
[107,]    5   17
[108,]    6   18
[109,]   10   22
[110,]   11   23
[111,]   12   24
[112,]   13   25
[113,]   14   26
[114,]   15   27
[115,]    4   10
[116,]    5   11
[117,]    6   12
[118,]    7   13
[119,]    8   14
[120,]    9   15
[121,]   13   19
[122,]   14   20
[123,]   15   21
[124,]   16   22
[125,]   17   23
[126,]   18   24
> 
> 
> 
> cleanEx()
> nameEx("getNeighbors")
> ### * getNeighbors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getNeighbors
> ### Title: Get Neighbours of All Vertices of a Graph
> ### Aliases: getNeighbors
> ### Keywords: spatial
> 
> ### ** Examples
> 
>   #Example 1: get all neighbours of a 1D graph.
>   mask <- c(0,0,rep(1,4),0,1,1,0,0,1,1,1)
>   getNeighbors(mask, neiStruc=2)
      [,1] [,2]
 [1,]   10    2
 [2,]    1    3
 [3,]    2    4
 [4,]    3   10
 [5,]   10    6
 [6,]    5   10
 [7,]   10    8
 [8,]    7    9
 [9,]    8   10
>   
>   #Example 2: get all neighbours of a 2D graph based on neighbourhood structure
>   #           corresponding to the second-order Markov random field.
>   mask <- matrix(1, nrow=2, ncol=3)
>   getNeighbors(mask, neiStruc=c(2,2,2,2))
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    7    2    7    3    7    4    7    7
[2,]    1    7    7    4    7    7    7    3
[3,]    7    4    1    5    7    6    2    7
[4,]    3    7    2    6    1    7    7    5
[5,]    7    6    3    7    7    7    4    7
[6,]    5    7    4    7    3    7    7    7
>   
>   #Example 3: get all neighbours of a 3D graph based on 6 neighbours structure
>   #           where the neighbours of a vertex comprise its available
>   #           N,S,E,W, upper and lower adjacencies. To achieve it, there
>   #           are several ways, including the two below.
>   mask <- array(1, dim=rep(3,3))
>   n61 <- matrix(c(2,2,0,0,
+                   0,2,0,0,
+                   0,0,0,0), nrow=3, byrow=TRUE)
>   n62 <- matrix(c(2,0,0,0,
+                   0,2,0,0,
+                   2,0,0,0), nrow=3, byrow=TRUE)
>   n1 <- getNeighbors(mask, neiStruc=n61)
>   n2 <- getNeighbors(mask, neiStruc=n62)
>   n1 <- apply(n1, 1, sort)
>   n2 <- apply(n2, 1, sort)
>   all(n1==n2)
[1] TRUE
>   
>   #Example 4: get all neighbours of a 3D graph based on 18 neighbours structure
>   #           where the neighbours of a vertex comprise its available
>   #           adjacencies sharing the same edges or faces.
>   #           To achieve it, there are several ways, including the one below.
>   
>   n18 <- matrix(c(2,2,2,2,
+                   0,2,2,2,
+                   0,0,2,2), nrow=3, byrow=TRUE)  
>   mask <- array(1, dim=rep(3,3))
>   getNeighbors(mask, neiStruc=n18)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]
 [1,]   28    2   28    4   28    5   28   28   28    10    28    11    28
 [2,]    1    3   28    5   28    6   28    4   28    11    28    12    28
 [3,]    2   28   28    6   28   28   28    5   28    12    28    28    28
 [4,]   28    5    1    7   28    8    2   28   28    13    28    14    28
 [5,]    4    6    2    8    1    9    3    7   28    14    28    15    28
 [6,]    5   28    3    9    2   28   28    8   28    15    28    28    28
 [7,]   28    8    4   28   28   28    5   28   28    16    28    17    28
 [8,]    7    9    5   28    4   28    6   28   28    17    28    18    28
 [9,]    8   28    6   28    5   28   28   28   28    18    28    28    28
[10,]   28   11   28   13   28   14   28   28    1    19    28    20     2
[11,]   10   12   28   14   28   15   28   13    2    20     1    21     3
[12,]   11   28   28   15   28   28   28   14    3    21     2    28    28
[13,]   28   14   10   16   28   17   11   28    4    22    28    23     5
[14,]   13   15   11   17   10   18   12   16    5    23     4    24     6
[15,]   14   28   12   18   11   28   28   17    6    24     5    28    28
[16,]   28   17   13   28   28   28   14   28    7    25    28    26     8
[17,]   16   18   14   28   13   28   15   28    8    26     7    27     9
[18,]   17   28   15   28   14   28   28   28    9    27     8    28    28
[19,]   28   20   28   22   28   23   28   28   10    28    28    28    11
[20,]   19   21   28   23   28   24   28   22   11    28    10    28    12
[21,]   20   28   28   24   28   28   28   23   12    28    11    28    28
[22,]   28   23   19   25   28   26   20   28   13    28    28    28    14
[23,]   22   24   20   26   19   27   21   25   14    28    13    28    15
[24,]   23   28   21   27   20   28   28   26   15    28    14    28    28
[25,]   28   26   22   28   28   28   23   28   16    28    28    28    17
[26,]   25   27   23   28   22   28   24   28   17    28    16    28    18
[27,]   26   28   24   28   23   28   28   28   18    28    17    28    28
      [,14] [,15] [,16] [,17] [,18]
 [1,]    28    28    13    28    28
 [2,]    10    28    14    28    28
 [3,]    11    28    15    28    28
 [4,]    28    28    16    28    10
 [5,]    13    28    17    28    11
 [6,]    14    28    18    28    12
 [7,]    28    28    28    28    13
 [8,]    16    28    28    28    14
 [9,]    17    28    28    28    15
[10,]    28    28    22     4    28
[11,]    19    28    23     5    28
[12,]    20    28    24     6    28
[13,]    28     1    25     7    19
[14,]    22     2    26     8    20
[15,]    23     3    27     9    21
[16,]    28     4    28    28    22
[17,]    25     5    28    28    23
[18,]    26     6    28    28    24
[19,]    28    28    28    13    28
[20,]    28    28    28    14    28
[21,]    28    28    28    15    28
[22,]    28    10    28    16    28
[23,]    28    11    28    17    28
[24,]    28    12    28    18    28
[25,]    28    13    28    28    28
[26,]    28    14    28    28    28
[27,]    28    15    28    28    28
> 
> 
> 
> cleanEx()
> nameEx("gibbsNorm")
> ### * gibbsNorm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gibbsNorm
> ### Title: Fit a univariate normal (Gaussian) distribution to the observed
> ###   data.
> ### Aliases: gibbsNorm
> 
> ### ** Examples
> 
> y <- rnorm(100,mean=5,sd=2)
> res.norm <- gibbsNorm(y, priors=list(mu=0, mu.sd=1e6, sigma=1e-3, sigma.nu=1e-3))
> summary(res.norm$mu[501:1000])
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  4.634   5.099   5.221   5.220   5.341   5.766 
> summary(res.norm$sigma[501:1000])
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  1.432   1.715   1.822   1.820   1.905   2.291 
> 
> 
> 
> cleanEx()
> nameEx("mcmcPottsNoData")
> ### * mcmcPottsNoData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mcmcPottsNoData
> ### Title: Simulate pixel labels using chequerboard Gibbs sampling.
> ### Aliases: mcmcPottsNoData
> 
> ### ** Examples
> 
> # Swendsen-Wang for a 2x2 lattice
> neigh <- matrix(c(5,2,5,3,  1,5,5,4,  5,4,1,5,  3,5,2,5), nrow=4, ncol=4, byrow=TRUE)
> blocks <- list(c(1,4), c(2,3))
> res.Gibbs <- mcmcPottsNoData(0.7, 3, neigh, blocks, niter=200)
> res.Gibbs$z
     [,1] [,2] [,3]
[1,]    0    0    1
[2,]    1    0    0
[3,]    0    0    1
[4,]    0    1    0
[5,]    0    0    0
> res.Gibbs$sum[200]
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("swNoData")
> ### * swNoData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: swNoData
> ### Title: Simulate pixel labels using the Swendsen-Wang algorithm.
> ### Aliases: swNoData
> 
> ### ** Examples
> 
> # Swendsen-Wang for a 2x2 lattice
> neigh <- matrix(c(5,2,5,3,  1,5,5,4,  5,4,1,5,  3,5,2,5), nrow=4, ncol=4, byrow=TRUE)
> blocks <- list(c(1,4), c(2,3))
> res.sw <- swNoData(0.7, 3, neigh, blocks, niter=200)
> res.sw$z
     [,1] [,2] [,3]
[1,]    0    0    1
[2,]    0    1    0
[3,]    1    0    0
[4,]    0    1    0
[5,]    0    0    0
> res.sw$sum[200]
[1] 1
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.196 0.008 0.205 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
